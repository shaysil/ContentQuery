{"version":3,"file":"classNamesFunction.js","sourceRoot":"../src/","sources":["classNamesFunction.ts"],"names":[],"mappings":";;AAAA,uDAA+F;AAW/F;;;GAGG;AACH,4BACE,OAAwC;IAExC,iBAAiB;IAFjB,wBAAA,EAAA,YAAwC;IAIxC,IAAM,aAAa,GAAG,UACpB,qBAAiF,EACjF,UAA2C;QAA3C,2BAAA,EAAA,aAA0B,EAAiB;QAE3C,gGAAgG;QAChG,4DAA4D;QAC5D,sGAAsG;QACtG,0GAA0G;QAC1G,IAAI,qBAAqB,KAAK,SAAS,EAAE;YACvC,OAAO,EAAmC,CAAC;SAC5C;QAED,IAAM,QAAQ,GACZ,qBAAqB,IAAI,CAAC,OAAO,qBAAqB,KAAK,UAAU,CAAC,CAAC,CAAC,qBAAqB,CAAC,UAAW,CAAC,CAAC,CAAC,CAAC,qBAAqB,CAAC,CAAC;QAEtI,OAAO,6BAAc,CAAC,QAAqB,CAAC,CAAC;IAC/C,CAAC,CAAC;IAEF,OAAO,aAAa,CAAC;AACvB,CAAC;AAxBD,gDAwBC","sourcesContent":["import { mergeStyleSets, IStyle, IStyleSet, IProcessedStyleSet } from '@uifabric/merge-styles';\nimport { IStyleFunctionOrObject } from '@uifabric/merge-styles';\n\n// TODO: deprecate disableCaching option if not used by classNamesFunction for optimization.\nexport interface IClassNamesFunctionOptions {\n  /**\n   * Disables class caching for scenarios where styleProp parts mutate frequently.\n   */\n  disableCaching?: boolean;\n}\n\n/**\n * Creates a getClassNames function which calls getStyles given the props, and injects them\n * into mergeStyleSets.\n */\nexport function classNamesFunction<TStyleProps extends {}, TStyleSet extends IStyleSet<TStyleSet>>(\n  options: IClassNamesFunctionOptions = {}\n): (getStyles: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined, styleProps?: TStyleProps) => IProcessedStyleSet<TStyleSet> {\n  // TODO: memoize.\n\n  const getClassNames = (\n    styleFunctionOrObject: IStyleFunctionOrObject<TStyleProps, TStyleSet> | undefined,\n    styleProps: TStyleProps = {} as TStyleProps\n  ): IProcessedStyleSet<TStyleSet> => {\n    // styleSet might be undefined if styleFunctionOrObject is undefined, but getStyles should never\n    // ordinarily be undefined (it would hardly make any sense).\n    // However, because we usually use `props.styles` as the argument to an invocation of this method, and\n    // `props.styles` itself is defined as optional, this avoids the need to use `!` at all invocation points.\n    if (styleFunctionOrObject === undefined) {\n      return {} as IProcessedStyleSet<TStyleSet>;\n    }\n\n    const styleSet =\n      styleFunctionOrObject && (typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps!) : styleFunctionOrObject);\n\n    return mergeStyleSets(styleSet as TStyleSet);\n  };\n\n  return getClassNames;\n}\n"]}