define(["require", "exports", "tslib", "@uifabric/utilities/lib/warn", "@uifabric/utilities/lib/GlobalSettings", "@uifabric/merge-styles/lib/index"], function (require, exports, tslib_1, warn_1, GlobalSettings_1, index_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ICON_SETTING_NAME = 'icons';
    var _iconSettings = GlobalSettings_1.GlobalSettings.getValue(ICON_SETTING_NAME, {
        __options: {
            disableWarnings: false,
            warnOnMissingIcons: true
        },
        __remapped: {}
    });
    /**
     * Registers a given subset of icons.
     *
     * @param iconSubset - the icon subset definition.
     */
    function registerIcons(iconSubset, options) {
        var subset = tslib_1.__assign({}, iconSubset, { isRegistered: false, className: undefined });
        var icons = iconSubset.icons;
        // Grab options, optionally mix user provided ones on top.
        options = options ? tslib_1.__assign({}, _iconSettings.__options, options) : _iconSettings.__options;
        for (var iconName in icons) {
            if (icons.hasOwnProperty(iconName)) {
                var code = icons[iconName];
                var normalizedIconName = iconName.toLowerCase();
                if (_iconSettings[normalizedIconName]) {
                    _warnDuplicateIcon(iconName);
                }
                else {
                    _iconSettings[normalizedIconName] = {
                        code: code,
                        subset: subset
                    };
                }
            }
        }
    }
    exports.registerIcons = registerIcons;
    /**
     * Remaps one icon name to another.
     */
    function registerIconAlias(iconName, mappedToName) {
        _iconSettings.__remapped[iconName.toLowerCase()] = mappedToName.toLowerCase();
    }
    exports.registerIconAlias = registerIconAlias;
    /**
     * Gets an icon definition. If an icon is requested but the subset has yet to be registered,
     * it will get registered immediately.
     *
     * @public
     * @param name - Name of icon.
     */
    function getIcon(name) {
        var icon = undefined;
        var options = _iconSettings.__options;
        name = name ? name.toLowerCase() : '';
        name = _iconSettings.__remapped[name] || name;
        if (name) {
            icon = _iconSettings[name];
            if (icon) {
                var subset = icon.subset;
                if (subset.fontFace && !subset.isRegistered) {
                    // Register font face for given icons.
                    index_1.fontFace(subset.fontFace);
                    // Generate a base class name for the given font.
                    subset.className = index_1.mergeStyles(subset.style, {
                        fontFamily: subset.fontFace.fontFamily,
                        fontWeight: subset.fontFace.fontWeight || 'normal',
                        fontStyle: subset.fontFace.fontStyle || 'normal'
                    }).toString();
                    subset.isRegistered = true;
                }
            }
            else {
                if (!options.disableWarnings && options.warnOnMissingIcons) {
                    warn_1.warn("The icon \"" + name + "\" was used but not registered. See http://aka.ms/fabric-icon-usage for more information.");
                }
            }
        }
        return icon;
    }
    exports.getIcon = getIcon;
    /**
     * Sets the icon options.
     *
     * @public
     */
    function setIconOptions(options) {
        _iconSettings.__options = tslib_1.__assign({}, _iconSettings.__options, options);
    }
    exports.setIconOptions = setIconOptions;
    var _missingIcons = [];
    var _missingIconsTimer = undefined;
    function _warnDuplicateIcon(iconName) {
        var options = _iconSettings.__options;
        var warningDelay = 2000;
        var maxIconsInMessage = 10;
        if (!options.disableWarnings) {
            _missingIcons.push(iconName);
            if (_missingIconsTimer === undefined) {
                _missingIconsTimer = setTimeout(function () {
                    warn_1.warn("Some icons were re-registered. Applications should only call registerIcons for any given " +
                        "icon once. Redefining what an icon is may have unintended consequences. Duplicates " +
                        "include: \n" +
                        _missingIcons.slice(0, maxIconsInMessage).join(', ') +
                        (_missingIcons.length > maxIconsInMessage ? " (+ " + (_missingIcons.length - maxIconsInMessage) + " more)" : ''));
                    _missingIconsTimer = undefined;
                    _missingIcons = [];
                }, warningDelay);
            }
        }
    }
});
//# sourceMappingURL=icons.js.map