"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
exports.eolSequence = {
    isEol: true
};
/**
 * @beta
 */
var ColorValue;
(function (ColorValue) {
    ColorValue[ColorValue["Black"] = 0] = "Black";
    ColorValue[ColorValue["Red"] = 1] = "Red";
    ColorValue[ColorValue["Green"] = 2] = "Green";
    ColorValue[ColorValue["Yellow"] = 3] = "Yellow";
    ColorValue[ColorValue["Blue"] = 4] = "Blue";
    ColorValue[ColorValue["Magenta"] = 5] = "Magenta";
    ColorValue[ColorValue["Cyan"] = 6] = "Cyan";
    ColorValue[ColorValue["White"] = 7] = "White";
    ColorValue[ColorValue["Gray"] = 8] = "Gray";
})(ColorValue = exports.ColorValue || (exports.ColorValue = {}));
/**
 * The static functions on this class are used to produce colored text
 * for use with the node-core-library terminal.
 *
 * @example
 * terminal.writeLine(Colors.green('Green Text!'), ' ', Colors.blue('Blue Text!'));
 *
 * @beta
 */
class Colors {
    static black(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Black });
    }
    static red(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Red });
    }
    static green(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Green });
    }
    static yellow(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Yellow });
    }
    static blue(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Blue });
    }
    static magenta(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Magenta });
    }
    static cyan(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Cyan });
    }
    static white(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.White });
    }
    static gray(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { foregroundColor: ColorValue.Gray });
    }
    static blackBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Black });
    }
    static redBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Red });
    }
    static greenBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Green });
    }
    static yellowBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Yellow });
    }
    static blueBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Blue });
    }
    static magentaBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Magenta });
    }
    static cyanBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Cyan });
    }
    static whiteBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.White });
    }
    static grayBackground(text) {
        return Object.assign({}, Colors._normalizeStringOrColorableSequence(text), { backgroundColor: ColorValue.Gray });
    }
    /**
     * @internal
     */
    static _normalizeStringOrColorableSequence(value) {
        if (typeof value === 'string') {
            return {
                text: value
            };
        }
        else {
            return value;
        }
    }
}
exports.Colors = Colors;
//# sourceMappingURL=Colors.js.map