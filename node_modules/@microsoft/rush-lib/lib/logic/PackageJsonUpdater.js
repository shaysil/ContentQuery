"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const semver = require("semver");
const InstallManager_1 = require("./InstallManager");
const VersionMismatchFinder_1 = require("../api/VersionMismatchFinder");
const PurgeManager_1 = require("./PurgeManager");
const Utilities_1 = require("../utilities/Utilities");
/**
 * A helper class for managing the dependencies of various package.json files.
 * @internal
 */
class PackageJsonUpdater {
    constructor(rushConfiguration, rushGlobalFolder) {
        this._rushConfiguration = rushConfiguration;
        this._rushGlobalFolder = rushGlobalFolder;
    }
    /**
     * Adds a dependency to a particular project. The core business logic for "rush add".
     */
    doRushAdd(options) {
        const { currentProject, packageName, initialVersion, devDependency, updateOtherPackages, skipUpdate, debugInstall, rangeStyle, variant } = options;
        const implicitlyPinned = InstallManager_1.InstallManager.collectImplicitlyPreferredVersions(this._rushConfiguration, {
            variant
        });
        const version = this._getNormalizedVersionSpec(packageName, initialVersion, implicitlyPinned.get(packageName), rangeStyle);
        console.log();
        console.log(colors.green(`Updating projects to use `)
            + packageName + '@' + colors.cyan(version));
        console.log();
        const currentProjectUpdate = {
            project: currentProject,
            packageName,
            newVersion: version,
            dependencyType: devDependency ? "devDependencies" /* Dev */ : undefined
        };
        this.updateProject(currentProjectUpdate);
        const otherPackageUpdates = [];
        if (this._rushConfiguration.ensureConsistentVersions || updateOtherPackages) {
            // we need to do a mismatch check
            const mismatchFinder = VersionMismatchFinder_1.VersionMismatchFinder.getMismatches(this._rushConfiguration, {
                variant: variant
            });
            const mismatches = mismatchFinder.getMismatches();
            if (mismatches.length) {
                if (!updateOtherPackages) {
                    return Promise.reject(new Error(`Adding '${packageName}@${version}' to ${currentProject.packageName}`
                        + ` causes mismatched dependencies. Use the "--make-consistent" flag to update other packages to use this`
                        + ` version, or do not specify a SemVer range.`));
                }
                // otherwise we need to go update a bunch of other projects
                const mismatchedVersions = mismatchFinder.getVersionsOfMismatch(packageName);
                if (mismatchedVersions) {
                    for (const mismatchedVersion of mismatchedVersions) {
                        for (const consumer of mismatchFinder.getConsumersOfMismatch(packageName, mismatchedVersion)) {
                            if (consumer !== currentProject.packageName) {
                                otherPackageUpdates.push({
                                    project: this._rushConfiguration.getProjectByName(consumer),
                                    packageName: packageName,
                                    newVersion: version
                                });
                            }
                        }
                    }
                }
            }
        }
        this.updateProjects(otherPackageUpdates);
        for (const project of this._rushConfiguration.projects) {
            if (project.packageJsonEditor.saveIfModified()) {
                console.log(colors.green('Wrote ') + project.packageJsonEditor.filePath);
            }
        }
        if (skipUpdate) {
            return Promise.resolve();
        }
        const purgeManager = new PurgeManager_1.PurgeManager(this._rushConfiguration, this._rushGlobalFolder);
        const installManagerOptions = {
            debug: debugInstall,
            allowShrinkwrapUpdates: true,
            bypassPolicy: false,
            noLink: false,
            fullUpgrade: false,
            recheckShrinkwrap: false,
            networkConcurrency: undefined,
            collectLogFile: false,
            variant: variant
        };
        const installManager = new InstallManager_1.InstallManager(this._rushConfiguration, this._rushGlobalFolder, purgeManager, installManagerOptions);
        console.log();
        console.log(colors.green('Running "rush update"'));
        console.log();
        return installManager.doInstall()
            .then(() => {
            purgeManager.deleteAll();
        })
            .catch((error) => {
            purgeManager.deleteAll();
            throw error;
        });
    }
    /**
     * Updates several projects' package.json files
     */
    updateProjects(projectUpdates) {
        for (const update of projectUpdates) {
            this.updateProject(update);
        }
    }
    /**
     * Updates a single project's package.json file
     */
    updateProject(options) {
        let { dependencyType } = options;
        const { project, packageName, newVersion } = options;
        const packageJson = project.packageJsonEditor;
        const oldDependency = packageJson.tryGetDependency(packageName);
        const oldDevDependency = packageJson.tryGetDevDependency(packageName);
        const oldDependencyType = oldDevDependency ? oldDevDependency.dependencyType :
            oldDependency ? oldDependency.dependencyType : undefined;
        dependencyType = dependencyType || oldDependencyType || "dependencies" /* Regular */;
        packageJson.addOrUpdateDependency(packageName, newVersion, dependencyType);
    }
    /**
     * Selects an appropriate version number for a particular package, given an optional initial SemVer spec.
     * If ensureConsistentVersions, tries to pick a version that will be consistent.
     * Otherwise, will choose the latest semver matching the initialSpec and append the proper range style.
     * @param packageName - the name of the package to be used
     * @param initialSpec - a semver pattern that should be used to find the latest version matching the spec
     * @param implicitlyPinnedVersion - the implicityly preferred (aka common/primary) version of the package in use
     * @param rangeStyle - if this version is selected by querying registry, then this range specifier is prepended to
     *   the selected version.
     */
    _getNormalizedVersionSpec(packageName, initialSpec, implicitlyPinnedVersion, rangeStyle) {
        console.log(colors.gray(`Determining new version for dependency: ${packageName}`));
        if (initialSpec) {
            console.log(`Specified version selector: ${colors.cyan(initialSpec)}`);
        }
        else {
            console.log(`No version selector was specified, so the version will be determined automatically.`);
        }
        console.log();
        // if ensureConsistentVersions => reuse the pinned version
        // else, query the registry and use the latest that satisfies semver spec
        if (initialSpec && implicitlyPinnedVersion && initialSpec === implicitlyPinnedVersion) {
            console.log(colors.green('Assigning "')
                + colors.cyan(initialSpec)
                + colors.green(`" for "${packageName}" because it matches what other projects are using in this repo.`));
            return initialSpec;
        }
        if (this._rushConfiguration.ensureConsistentVersions && !initialSpec && implicitlyPinnedVersion) {
            console.log(`Assigning the version range "${colors.cyan(implicitlyPinnedVersion)}" for "${packageName}" because`
                + ` it is already used by other projects in this repo.`);
            return implicitlyPinnedVersion;
        }
        let selectedVersion;
        if (this._rushConfiguration.packageManager === 'yarn') {
            throw new Error('The Yarn package manager is not currently supported by the "rush add" command.');
        }
        if (initialSpec && initialSpec !== 'latest') {
            console.log(colors.gray('Finding newest version that satisfies the selector: ') + initialSpec);
            console.log();
            console.log(`Querying registry for all versions of "${packageName}"...`);
            const allVersions = Utilities_1.Utilities.executeCommandAndCaptureOutput(this._rushConfiguration.packageManagerToolFilename, ['view', packageName, 'versions', '--json'], this._rushConfiguration.commonTempFolder);
            let versionList = JSON.parse(allVersions);
            versionList = versionList.sort((a, b) => { return semver.gt(a, b) ? -1 : 1; });
            console.log(colors.gray(`Found ${versionList.length} available versions.`));
            for (const version of versionList) {
                if (semver.satisfies(version, initialSpec)) {
                    selectedVersion = version;
                    console.log(`Found latest version: ${colors.cyan(selectedVersion)}`);
                    break;
                }
            }
            if (!selectedVersion) {
                throw new Error(`Unable to find a version of "${packageName}" that satisfies`
                    + ` the version range "${initialSpec}"`);
            }
        }
        else {
            if (initialSpec !== 'latest') {
                console.log(colors.gray(`The "ensureConsistentVersions" policy is NOT active,`
                    + ` so we will assign the latest version.`));
                console.log();
            }
            console.log(`Querying NPM registry for latest version of "${packageName}"...`);
            selectedVersion = Utilities_1.Utilities.executeCommandAndCaptureOutput(this._rushConfiguration.packageManagerToolFilename, ['view', `${packageName}@latest`, 'version'], this._rushConfiguration.commonTempFolder).trim();
            console.log();
            console.log(`Found latest version: ${colors.cyan(selectedVersion)}`);
        }
        console.log();
        if (rangeStyle === "caret" /* Caret */) {
            console.log(colors.grey(`Assigning version "^${selectedVersion}" for "${packageName}" because the "--caret"`
                + ` flag was specified.`));
            return '^' + selectedVersion;
        }
        else if (rangeStyle === "exact" /* Exact */) {
            console.log(colors.grey(`Assigning version "${selectedVersion}" for "${packageName}" because the "--exact"`
                + ` flag was specified.`));
            return selectedVersion;
        }
        else {
            console.log(colors.gray(`Assigning version "~${selectedVersion}" for "${packageName}".`));
            return '~' + selectedVersion;
        }
    }
}
exports.PackageJsonUpdater = PackageJsonUpdater;
//# sourceMappingURL=PackageJsonUpdater.js.map