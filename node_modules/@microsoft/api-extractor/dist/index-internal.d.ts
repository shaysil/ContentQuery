/**
 * API Extractor helps you build better TypeScript library packages.
 * It helps with validation, documentation, and reviewing of the exported API
 * for a TypeScript library.
 * 
 * @packagedocumentation
 */

import { DocDeclarationReference } from '@microsoft/tsdoc';
import { IJsonFileSaveOptions } from '@microsoft/node-core-library';
import { IStringBuilder } from '@microsoft/node-core-library';
import { JsonSchema } from '@microsoft/node-core-library';
import * as ts from 'typescript';
import * as tsdoc from '@microsoft/tsdoc';

/**
 * Represents a TypeScript function call signature.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiCallSignature` represents a TypeScript declaration such as `(x: number, y: number): number`
 * in this example:
 *
 * ```ts
 * export interface IChooser {
 *   // A call signature:
 *   (x: number, y: number): number;
 *
 *   // Another overload for this call signature:
 *   (x: string, y: string): string;
 * }
 *
 * function chooseFirst<T>(x: T, y: T): T {
 *   return x;
 * }
 *
 * let chooser: IChooser = chooseFirst;
 * ```
 *
 * @public
 */
export declare class ApiCallSignature extends ApiCallSignature_base {
    static getCanonicalReference(overloadIndex: number): string;
    constructor(options: IApiCallSignatureOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiCallSignature_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin);

/**
 * Represents a TypeScript class declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiClass` represents a TypeScript declaration such as this:
 *
 * ```ts
 * export class X { }
 * ```
 *
 * @public
 */
export declare class ApiClass extends ApiClass_base {
    /**
     * The base class that this class inherits from (using the `extends` keyword), or undefined if there is no base class.
     */
    readonly extendsType: HeritageType | undefined;
    private readonly _implementsTypes;
    static getCanonicalReference(name: string): string;
    /** @override */
    static onDeserializeInto(options: Partial<IApiClassOptions>, jsonObject: IApiClassJson): void;
    constructor(options: IApiClassOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    /**
     * The list of interfaces that this class implements using the `implements` keyword.
     */
    readonly implementsTypes: ReadonlyArray<HeritageType>;
    /** @override */
    serializeInto(jsonObject: Partial<IApiClassJson>): void;
}

declare const ApiClass_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Represents a TypeScript construct signature that belongs to an `ApiInterface`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiConstructSignature` represents a construct signature using the `new` keyword such as in this example:
 *
 * ```ts
 * export interface IVector {
 *   x: number;
 *   y: number;
 * }
 *
 * export interface IVectorConstructor {
 *   // A construct signature:
 *   new(x: number, y: number): IVector;
 * }
 *
 * export function createVector(vectorConstructor: IVectorConstructor,
 *   x: number, y: number): IVector {
 *   return new vectorConstructor(x, y);
 * }
 *
 * class Vector implements IVector {
 *   public x: number;
 *   public y: number;
 *   public constructor(x: number, y: number) {
 *     this.x = x;
 *     this.y = y;
 *   }
 * }
 *
 * let vector: Vector = createVector(Vector, 1, 2);
 * ```
 *
 * Compare with {@link ApiConstructor}, which describes the class constructor itself.
 *
 * @public
 */
export declare class ApiConstructSignature extends ApiConstructSignature_base {
    static getCanonicalReference(overloadIndex: number): string;
    constructor(options: IApiConstructSignatureOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiConstructSignature_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin);

/**
 * Represents a TypeScript class constructor declaration that belongs to an `ApiClass`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiConstructor` represents a declaration using the `constructor` keyword such as in this example:
 *
 * ```ts
 * export class Vector {
 *   public x: number;
 *   public y: number;
 *
 *   // A class constructor:
 *   public constructor(x: number, y: number) {
 *     this.x = x;
 *     this.y = y;
 *   }
 * }
 * ```
 *
 * Compare with {@link ApiConstructSignature}, which describes the construct signature for a class constructor.
 *
 * @public
 */
export declare class ApiConstructor extends ApiConstructor_base {
    static getCanonicalReference(isStatic: boolean, overloadIndex: number): string;
    constructor(options: IApiConstructorOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiConstructor_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiStaticMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin);

/**
 * The base class for API items that have an associated source code excerpt containing a TypeScript declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * Most `ApiItem` subclasses have declarations and thus extend `ApiDeclaredItem`.  Counterexamples include
 * `ApiModel` and `ApiPackage`, which do not have any corresponding TypeScript source code.
 *
 * @public
 */
export declare class ApiDeclaredItem extends ApiDocumentedItem {
    private _excerptTokens;
    private _excerpt;
    /** @override */
    static onDeserializeInto(options: Partial<IApiDeclaredItemOptions>, jsonObject: IApiDeclaredItemJson): void;
    constructor(options: IApiDeclaredItemOptions);
    /**
     * The source code excerpt where the API item is declared.
     */
    readonly excerpt: Excerpt;
    /**
     * The individual source code tokens that comprise the main excerpt.
     */
    readonly excerptTokens: ReadonlyArray<ExcerptToken>;
    /**
     * If the API item has certain important modifier tags such as `@sealed`, `@virtual`, or `@override`,
     * this prepends them as a doc comment above the excerpt.
     */
    getExcerptWithModifiers(): string;
    /** @override */
    serializeInto(jsonObject: Partial<IApiDeclaredItemJson>): void;
    /**
     * Constructs a new {@link Excerpt} corresponding to the provided token range.
     */
    buildExcerpt(tokenRange: IExcerptTokenRange): Excerpt;
}

/**
 * An abstract base class for API declarations that can have an associated TSDoc comment.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * @public
 */
export declare class ApiDocumentedItem extends ApiItem {
    private _tsdocComment;
    /** @override */
    static onDeserializeInto(options: Partial<IApiDocumentedItemOptions>, jsonObject: IApiItemJson): void;
    constructor(options: IApiDocumentedItemOptions);
    readonly tsdocComment: tsdoc.DocComment | undefined;
    /** @override */
    serializeInto(jsonObject: Partial<IApiDocumentedItemJson>): void;
}

/**
 * Represents the entry point for an NPM package.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiEntryPoint` represents the entry point to an NPM package.  For example, suppose the package.json file
 * looks like this:
 *
 * ```json
 * {
 *   "name": "example-library",
 *   "version": "1.0.0",
 *   "main": "./lib/index.js",
 *   "typings": "./lib/index.d.ts"
 * }
 * ```
 *
 * In this example, the `ApiEntryPoint` would represent the TypeScript module for `./lib/index.js`.
 *
 * @public
 */
export declare class ApiEntryPoint extends ApiEntryPoint_base {
    constructor(options: IApiEntryPointOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiEntryPoint_base: typeof ApiItem & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Represents a TypeScript enum declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiEnum` represents an enum declaration such as `FontSizes` in the example below:
 *
 * ```ts
 * export enum FontSizes {
 *   Small = 100,
 *   Medium = 200,
 *   Large = 300
 * }
 * ```
 *
 * @public
 */
export declare class ApiEnum extends ApiEnum_base {
    static getCanonicalReference(name: string): string;
    constructor(options: IApiEnumOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly members: ReadonlyArray<ApiEnumMember>;
    /** @override */
    readonly canonicalReference: string;
    /** @override */
    addMember(member: ApiEnumMember): void;
}

/**
 * Represents a member of a TypeScript enum declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiEnumMember` represents an enum member such as `Small = 100` in the example below:
 *
 * ```ts
 * export enum FontSizes {
 *   Small = 100,
 *   Medium = 200,
 *   Large = 300
 * }
 * ```
 *
 * @public
 */
export declare class ApiEnumMember extends ApiEnumMember_base {
    /**
     * An {@link Excerpt} that describes the value of the enum member.
     */
    readonly initializerExcerpt: Excerpt;
    static getCanonicalReference(name: string): string;
    /** @override */
    static onDeserializeInto(options: Partial<IApiEnumMemberOptions>, jsonObject: IApiEnumMemberJson): void;
    constructor(options: IApiEnumMemberOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    /** @override */
    serializeInto(jsonObject: Partial<IApiEnumMemberJson>): void;
}

declare const ApiEnumMember_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin);

declare const ApiEnum_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Represents a TypeScript function declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiFunction` represents a TypeScript declaration such as this example:
 *
 * ```ts
 * export function getAverage(x: number, y: number): number {
 *   return (x + y) / 2.0;
 * }
 * ```
 *
 * Functions are exported by an entry point module or by a namespace.  Compare with {@link ApiMethod}, which
 * represents a function that is a member of a class.
 *
 * @public
 */
export declare class ApiFunction extends ApiFunction_base {
    static getCanonicalReference(name: string, overloadIndex: number): string;
    constructor(options: IApiFunctionOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiFunction_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin) & (new (...args: any[]) => ApiNameMixin);

/**
 * Represents a TypeScript index signature.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiIndexSignature` represents a TypeScript declaration such as `[x: number]: number` in this example:
 *
 * ```ts
 * export interface INumberTable {
 *   // An index signature
 *   [value: number]: number;
 *
 *   // An overloaded index signature
 *   [name: string]: number;
 * }
 * ```
 *
 * @public
 */
export declare class ApiIndexSignature extends ApiIndexSignature_base {
    static getCanonicalReference(overloadIndex: number): string;
    constructor(options: IApiIndexSignatureOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiIndexSignature_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin);

/**
 * Represents a TypeScript class declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiInterface` represents a TypeScript declaration such as this:
 *
 * ```ts
 * export interface X extends Y {
 * }
 * ```
 *
 * @public
 */
export declare class ApiInterface extends ApiInterface_base {
    private readonly _extendsTypes;
    static getCanonicalReference(name: string): string;
    /** @override */
    static onDeserializeInto(options: Partial<IApiInterfaceOptions>, jsonObject: IApiInterfaceJson): void;
    constructor(options: IApiInterfaceOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    /**
     * The list of base interfaces that this interface inherits from using the `extends` keyword.
     */
    readonly extendsTypes: ReadonlyArray<HeritageType>;
    /** @override */
    serializeInto(jsonObject: Partial<IApiInterfaceJson>): void;
}

declare const ApiInterface_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * The abstract base class for all members of an `ApiModel` object.
 *
 * @remarks
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 * @public
 */
export declare class ApiItem {
    [ApiItem_parent]: ApiItem | undefined;
    static deserialize(jsonObject: IApiItemJson): ApiItem;
    /** @virtual */
    static onDeserializeInto(options: Partial<IApiItemOptions>, jsonObject: IApiItemJson): void;
    constructor(options: IApiItemOptions);
    /** @virtual */
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
    /** @virtual */
    readonly kind: ApiItemKind;
    /** @virtual */
    readonly canonicalReference: string;
    /**
     * Returns a name for this object that can be used in diagnostic messages, for example.
     *
     * @remarks
     * For an object that inherits ApiNameMixin, this will return the declared name (e.g. the name of a TypeScript
     * function).  Otherwise, it will return a string such as "(call signature)" or "(model)".
     *
     * @virtual
     */
    readonly displayName: string;
    /**
     * If this item was added to a ApiItemContainerMixin item, then this returns the container item.
     * If this is an Parameter that was added to a method or function, then this returns the function item.
     * Otherwise, it returns undefined.
     * @virtual
     */
    readonly parent: ApiItem | undefined;
    /**
     * This property supports a visitor pattern for walking the tree.
     * For items with ApiItemContainerMixin, it returns the contained items.
     * Otherwise it returns an empty array.
     * @virtual
     */
    readonly members: ReadonlyArray<ApiItem>;
    /**
     * Returns the chain of ancestors, starting from the root of the tree, and ending with the this item.
     */
    getHierarchy(): ReadonlyArray<ApiItem>;
    /**
     * This returns a scoped name such as `"Namespace1.Namespace2.MyClass.myMember()"`.  It does not include the
     * package name or entry point.
     *
     * @remarks
     * If called on an ApiEntrypoint, ApiPackage, or ApiModel item, the result is an empty string.
     */
    getScopedNameWithinPackage(): string;
    /**
     * If this item is an ApiPackage or has an ApiPackage as one of its parents, then that object is returned.
     * Otherwise undefined is returned.
     */
    getAssociatedPackage(): ApiPackage | undefined;
    /** @virtual */
    getSortKey(): string;
}

/**
 * Mixin function for {@link (ApiDeclaredItem:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiItemContainerMixin:interface)} functionality.
 *
 * @public
 */
export declare function ApiItemContainerMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * The mixin base class for API items that act as containers for other child items.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * Examples of `ApiItemContainerMixin` child classes include `ApiModel`, `ApiPackage`, `ApiEntryPoint`,
 * and `ApiEnum`.  But note that `Parameter` is not considered a "member" of an `ApiMethod`; this relationship
 * is modeled using {@link ApiParameterListMixin.parameters} instead of {@link ApiItemContainerMixin.members}.
 *
 * @public
 */
export declare interface ApiItemContainerMixin extends ApiItem {
    /**
     * Returns the members of this container, sorted alphabetically.
     */
    readonly members: ReadonlyArray<ApiItem>;
    /**
     * Adds a new member to the container.
     *
     * @remarks
     * An ApiItem cannot be added to more than one container.
     */
    addMember(member: ApiItem): void;
    /**
     * Attempts to retrieve a member using its canonicalReference, or returns undefined if no matching member was found.
     */
    tryGetMember(canonicalReference: string): ApiItem | undefined;
    /**
     * Returns a list of members with the specified name.
     */
    findMembersByName(name: string): ReadonlyArray<ApiItem>;
    /** @override */
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
}

/**
 * Static members for {@link (ApiItemContainerMixin:interface)}.
 * @public
 */
export declare namespace ApiItemContainerMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiItemContainerMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiItemContainerMixin;
}

/**
 * The type returned by the {@link ApiItem.kind} property, which can be used to easily distinguish subclasses of
 * {@link ApiItem}.
 *
 * @public
 */
export declare const enum ApiItemKind {
    CallSignature = "CallSignature",
    Class = "Class",
    Constructor = "Constructor",
    ConstructSignature = "ConstructSignature",
    EntryPoint = "EntryPoint",
    Enum = "Enum",
    EnumMember = "EnumMember",
    Function = "Function",
    IndexSignature = "IndexSignature",
    Interface = "Interface",
    Method = "Method",
    MethodSignature = "MethodSignature",
    Model = "Model",
    Namespace = "Namespace",
    Package = "Package",
    Property = "Property",
    PropertySignature = "PropertySignature",
    TypeAlias = "TypeAlias",
    Variable = "Variable",
    None = "None"
}

declare const ApiItem_parent: unique symbol;

/**
 * Represents a TypeScript member function declaration that belongs to an `ApiClass`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiMethod` represents a TypeScript declaration such as the `render` member function in this example:
 *
 * ```ts
 * export class Widget {
 *   public render(): void { }
 * }
 * ```
 *
 * Compare with {@link ApiMethodSignature}, which represents a method belonging to an interface.
 * For example, a class method can be `static` but an interface method cannot.
 *
 * @public
 */
export declare class ApiMethod extends ApiMethod_base {
    static getCanonicalReference(name: string, isStatic: boolean, overloadIndex: number): string;
    constructor(options: IApiMethodOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

/**
 * Represents a TypeScript member function declaration that belongs to an `ApiInterface`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiMethodSignature` represents a TypeScript declaration such as the `render` member function in this example:
 *
 * ```ts
 * export interface IWidget {
 *   render(): void;
 * }
 * ```
 *
 * Compare with {@link ApiMethod}, which represents a method belonging to a class.
 * For example, a class method can be `static` but an interface method cannot.
 *
 * @public
 */
export declare class ApiMethodSignature extends ApiMethodSignature_base {
    static getCanonicalReference(name: string, overloadIndex: number): string;
    constructor(options: IApiMethodSignatureOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiMethodSignature_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin) & (new (...args: any[]) => ApiNameMixin);

declare const ApiMethod_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiStaticMixin) & (new (...args: any[]) => ApiReturnTypeMixin) & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiParameterListMixin) & (new (...args: any[]) => ApiNameMixin);

/**
 * A serializable representation of a collection of API declarations.
 *
 * @remarks
 *
 * An `ApiModel` represents a collection of API declarations that can be serialized to disk.  It captures all the
 * important information needed to generate documentation, without any reliance on the TypeScript compiler engine.
 *
 * An `ApiModel` acts as the root of a tree of objects that all inherit from the `ApiItem` base class.
 * The tree children are determined by the {@link ApiItemContainerMixin} mixin base class.  The model contains
 * packages.  Packages have an entry point (today, only one).  And the entry point can contain various types
 * of API declarations.  The container relationships might look like this:
 *
 * ```
 * Things that can contain other things:
 *
 * - ApiModel
 *   - ApiPackage
 *     - ApiEntryPoint
 *       - ApiClass
 *         - ApiMethod
 *         - ApiProperty
 *       - ApiEnum
 *         - ApiEnumMember
 *       - ApiInterface
 *         - ApiMethodSignature
 *         - ApiPropertySignature
 *       - ApiNamespace
 *         - (ApiClass, ApiEnum, ApiInterace, ...)
 *
 * ```
 *
 * Normally, API Extractor writes an .api.json file to disk for each project that it builds.  Then, a tool like
 * API Documenter can load the various `ApiPackage` objects into a single `ApiModel` and process them as a group.
 * This is useful because compilation generally occurs separately (e.g. because projects may reside in different
 * Git repos, or because they build with different TypeScript compiler configurations that may be incompatible),
 * whereas API Documenter cannot detect broken hyperlinks without seeing the entire documentation set.
 *
 * @public
 */
export declare class ApiModel extends ApiModel_base {
    private readonly _resolver;
    private _packagesByName;
    constructor();
    loadPackage(apiJsonFilename: string): ApiPackage;
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    readonly packages: ReadonlyArray<ApiPackage>;
    /** @override */
    addMember(member: ApiPackage): void;
    /**
     * Efficiently finds a package by the NPM package name.
     *
     * @remarks
     *
     * If the NPM scope is omitted in the package name, it will still be found provided that it is an unambiguous match.
     * For example, it's often convenient to write `{@link node-core-library#JsonFile}` instead of
     * `{@link @microsoft/node-core-library#JsonFile}`.
     */
    tryGetPackageByName(packageName: string): ApiPackage | undefined;
    resolveDeclarationReference(declarationReference: DocDeclarationReference, contextApiItem: ApiItem | undefined): IResolveDeclarationReferenceResult;
}

declare const ApiModel_base: typeof ApiItem & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Mixin function for {@link (ApiNameMixin:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiNameMixin:interface)} functionality.
 *
 * @public
 */
declare function ApiNameMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiNameMixin);

/**
 * The mixin base class for API items that have a name.  For example, a class has a name, but a class constructor
 * does not.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * @public
 */
declare interface ApiNameMixin extends ApiItem {
    /**
     * The exported name of this API item.
     *
     * @remarks
     * Note that due tue type aliasing, the exported name may be different from the locally declared name.
     */
    readonly name: string;
    /** @override */
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
}

/**
 * Static members for {@link (ApiNameMixin:interface)}.
 * @public
 */
declare namespace ApiNameMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiNameMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    function isBaseClassOf(apiItem: ApiItem): apiItem is ApiNameMixin;
}

/**
 * Represents a TypeScript namespace declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiNamespace` represents a TypeScript declaration such `X` or `Y` in this example:
 *
 * ```ts
 * export namespace X {
 *   export namespace Y {
 *     export interface IWidget {
 *       render(): void;
 *     }
 *   }
 * }
 * ```
 *
 * @public
 */
export declare class ApiNamespace extends ApiNamespace_base {
    static getCanonicalReference(name: string): string;
    constructor(options: IApiNamespaceOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiNamespace_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Represents an NPM package containing API declarations.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * @public
 */
export declare class ApiPackage extends ApiPackage_base {
    static loadFromJsonFile(apiJsonFilename: string): ApiPackage;
    constructor(options: IApiPackageOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    readonly entryPoints: ReadonlyArray<ApiEntryPoint>;
    /** @override */
    addMember(member: ApiEntryPoint): void;
    findEntryPointsByPath(importPath: string): ReadonlyArray<ApiEntryPoint>;
    saveToJsonFile(apiJsonFilename: string, options?: IJsonFileSaveOptions): void;
}

declare const ApiPackage_base: typeof ApiDocumentedItem & (new (...args: any[]) => ApiNameMixin) & (new (...args: any[]) => ApiItemContainerMixin);

/**
 * Mixin function for {@link (ApiParameterListMixin:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiParameterListMixin:interface)} functionality.
 *
 * @public
 */
export declare function ApiParameterListMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiParameterListMixin);

/**
 * The mixin base class for API items that can have function parameters (but not necessarily a return value).
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * @public
 */
export declare interface ApiParameterListMixin extends ApiItem {
    /**
     * When a function has multiple overloaded declarations, this zero-based integer index can be used to unqiuely
     * identify them.
     *
     * @remarks
     *
     * Consider this overloaded declaration:
     *
     * ```ts
     * export namespace Versioning {
     *   export function addVersions(x: number, y: number): number;
     *   export function addVersions(x: string, y: string): string;
     *   export function addVersions(x: number|string, y: number|string): number|string {
     *     // . . .
     *   }
     * }
     * ```
     *
     * In the above example, there are two overloaded declarations.  The overload using numbers will have
     * `overloadIndex = 0`.  The overload using strings will have `overloadIndex = 1`.  The third declaration that
     * accepts all possible inputs is considered part of the implementation, and is not processed by API Extractor.
     */
    readonly overloadIndex: number;
    /**
     * The function parameters.
     */
    readonly parameters: ReadonlyArray<Parameter>;
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
}

/**
 * Static members for {@link (ApiParameterListMixin:interface)}.
 * @public
 */
export declare namespace ApiParameterListMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiParameterListMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiParameterListMixin;
}

/**
 * Represents a TypeScript property declaration that belongs to an `ApiClass`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiProperty` represents a TypeScript declaration such as the `width` and `height` members in this example:
 *
 * ```ts
 * export class Widget {
 *   public width: number = 100;
 *
 *   public get height(): number {
 *     if (this.isSquashed()) {
 *       return 0;
 *     } else {
 *       return this.clientArea.height;
 *     }
 *   }
 * }
 * ```
 *
 * Note that member variables are also considered to be properties.
 *
 * If the property has both a getter function and setter function, they will be represented by a single `ApiProperty`
 * and must have a single documentation comment.
 *
 * Compare with {@link ApiPropertySignature}, which represents a property belonging to an interface.
 * For example, a class property can be `static` but an interface property cannot.
 *
 * @public
 */
export declare class ApiProperty extends ApiProperty_base {
    static getCanonicalReference(name: string, isStatic: boolean): string;
    constructor(options: IApiPropertyOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

/**
 * The abstract base class for {@link ApiProperty} and {@link ApiPropertySignature}.
 *
 * @public
 */
export declare class ApiPropertyItem extends ApiPropertyItem_base {
    /**
     * An {@link Excerpt} that describes the type of the property.
     */
    readonly propertyTypeExcerpt: Excerpt;
    /** @override */
    static onDeserializeInto(options: Partial<IApiPropertyItemOptions>, jsonObject: IApiPropertyItemJson): void;
    constructor(options: IApiPropertyItemOptions);
    /**
     * Returns true if this property should be documented as an event.
     *
     * @remarks
     * The `@eventProperty` TSDoc modifier can be added to readonly properties to indicate that they return an
     * event object that event handlers can be attached to.  The event-handling API is implementation-defined, but
     * typically the return type would be a class with members such as `addHandler()` and `removeHandler()`.
     * The documentation should display such properties under an "Events" heading instead of the
     * usual "Properties" heading.
     */
    readonly isEventProperty: boolean;
    /** @override */
    serializeInto(jsonObject: Partial<IApiPropertyItemJson>): void;
}

declare const ApiPropertyItem_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin);

/**
 * Represents a TypeScript property declaration that belongs to an `ApiInterface`.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiPropertySignature` represents a TypeScript declaration such as the `width` and `height` members in this example:
 *
 * ```ts
 * export interface IWidget {
 *   readonly width: number;
 *   height: number;
 * }
 * ```
 *
 * Compare with {@link ApiProperty}, which represents a property belonging to a class.
 * For example, a class property can be `static` but an interface property cannot.
 *
 * @public
 */
export declare class ApiPropertySignature extends ApiPropertyItem {
    static getCanonicalReference(name: string): string;
    constructor(options: IApiPropertySignatureOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiProperty_base: typeof ApiPropertyItem & (new (...args: any[]) => ApiStaticMixin);

/**
 * Mixin function for {@link (ApiReleaseTagMixin:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiReleaseTagMixin:interface)} functionality.
 *
 * @public
 */
export declare function ApiReleaseTagMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiReleaseTagMixin);

/**
 * The mixin base class for API items that can be attributed with a TSDoc tag such as `@internal`,
 * `@alpha`, `@beta`, or `@public`.  These "release tags" indicate the support level for an API.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * @public
 */
export declare interface ApiReleaseTagMixin extends ApiItem {
    /**
     * The effective release tag for this declaration.  If it is not explicitly specified, the value may be
     * inherited from a containing declaration.
     *
     * @remarks
     * For example, an `ApiEnumMember` may inherit its release tag from the containing `ApiEnum`.
     */
    readonly releaseTag: ReleaseTag;
    /** @override */
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
}

/**
 * Static members for {@link (ApiReleaseTagMixin:interface)}.
 * @public
 */
export declare namespace ApiReleaseTagMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiReleaseTagMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiReleaseTagMixin;
}

/**
 * Mixin function for {@link (ApiReturnTypeMixin:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiReturnTypeMixin:interface)} functionality.
 *
 * @public
 */
export declare function ApiReturnTypeMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiReturnTypeMixin);

/**
 * The mixin base class for API items that are functions that return a value.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * @public
 */
export declare interface ApiReturnTypeMixin extends ApiItem {
    /**
     * An {@link Excerpt} that describes the type of the function's return value.
     */
    readonly returnTypeExcerpt: Excerpt;
    /** @override */
    serializeInto(jsonObject: Partial<IApiReturnTypeMixinJson>): void;
}

/**
 * Static members for {@link (ApiReturnTypeMixin:interface)}.
 * @public
 */
export declare namespace ApiReturnTypeMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiReturnTypeMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiReturnTypeMixin;
}

/**
 * Mixin function for {@link (ApiStaticMixin:interface)}.
 *
 * @param baseClass - The base class to be extended
 * @returns A child class that extends baseClass, adding the {@link (ApiStaticMixin:interface)} functionality.
 *
 * @public
 */
export declare function ApiStaticMixin<TBaseClass extends IApiItemConstructor>(baseClass: TBaseClass): TBaseClass & (new (...args: any[]) => ApiStaticMixin);

/**
 * The mixin base class for API items that can have the TypeScript `static` keyword applied to them.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.  The non-abstract classes (e.g. `ApiClass`, `ApiEnum`, `ApiInterface`, etc.) use
 * TypeScript "mixin" functions (e.g. `ApiDeclaredItem`, `ApiItemContainerMixin`, etc.) to add various
 * features that cannot be represented as a normal inheritance chain (since TypeScript does not allow a child class
 * to extend more than one base class).  The "mixin" is a TypeScript merged declaration with three components:
 * the function that generates a subclass, an interface that describes the members of the subclass, and
 * a namespace containing static members of the class.
 *
 * @public
 */
export declare interface ApiStaticMixin extends ApiItem {
    /**
     * Whether the declaration has the TypeScript `static` keyword.
     */
    readonly isStatic: boolean;
    /** @override */
    serializeInto(jsonObject: Partial<IApiItemJson>): void;
}

/**
 * Static members for {@link (ApiStaticMixin:interface)}.
 * @public
 */
export declare namespace ApiStaticMixin {
    /**
     * A type guard that tests whether the specified `ApiItem` subclass extends the `ApiStaticMixin` mixin.
     *
     * @remarks
     *
     * The JavaScript `instanceof` operator cannot be used to test for mixin inheritance, because each invocation of
     * the mixin function produces a different subclass.  (This could be mitigated by `Symbol.hasInstance`, however
     * the TypeScript type system cannot invoke a runtime test.)
     */
    export function isBaseClassOf(apiItem: ApiItem): apiItem is ApiStaticMixin;
}

/**
 * Represents a TypeScript type alias declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiTypeAlias` represents a definition such as one of these examples:
 *
 * ```ts
 * // A union type:
 * export type Shape = Square | Triangle | Circle;
 *
 * // A generic type alias:
 * export type BoxedValue<T> = { value: T };
 *
 * export type BoxedArray<T> = { array: T[] };
 *
 * // A conditional type alias:
 * export type Boxed<T> = T extends any[] ? BoxedArray<T[number]> : BoxedValue<T>;
 *
 * ```
 *
 * @public
 */
export declare class ApiTypeAlias extends ApiTypeAlias_base {
    static getCanonicalReference(name: string): string;
    constructor(options: IApiTypeAliasOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
}

declare const ApiTypeAlias_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin);

/**
 * Represents a TypeScript variable declaration.
 *
 * @remarks
 *
 * This is part of the {@link ApiModel} hierarchy of classes, which are serializable representations of
 * API declarations.
 *
 * `ApiVariable` represents an exported `const` or `let` object such as these examples:
 *
 * ```ts
 * // A variable declaration
 * export let verboseLogging: boolean;
 *
 * // A constant variable declaration with an initializer
 * export const canvas: IWidget = createCanvas();
 * ```
 *
 * @public
 */
export declare class ApiVariable extends ApiVariable_base {
    /**
     * An {@link Excerpt} that describes the type of the variable.
     */
    readonly variableTypeExcerpt: Excerpt;
    /** @override */
    static onDeserializeInto(options: Partial<IApiVariableOptions>, jsonObject: IApiVariableJson): void;
    static getCanonicalReference(name: string): string;
    constructor(options: IApiVariableOptions);
    /** @override */
    readonly kind: ApiItemKind;
    /** @override */
    readonly canonicalReference: string;
    /** @override */
    serializeInto(jsonObject: Partial<IApiVariableJson>): void;
}

declare const ApiVariable_base: typeof ApiDeclaredItem & (new (...args: any[]) => ApiReleaseTagMixin) & (new (...args: any[]) => ApiNameMixin);

export declare type Constructor<T = {}> = new (...args: any[]) => T;

/**
 * This class is used by {@link (ApiDeclaredItem:interface)} to represent a source code excerpt containing
 * a TypeScript declaration.
 *
 * @remarks
 *
 * The main excerpt is parsed into an array of tokens, and the main excerpt's token range will span all of these
 * tokens.  The declaration may also have have "captured" excerpts, which are other subranges of tokens.
 * For example, if the main excerpt is a function declaration, it will also have a captured excerpt corresponding
 * to the return type of the function.
 *
 * An excerpt may be empty (i.e. a token range containing zero tokens).  For example, if a function's return value
 * is not explicitly declared, then the returnTypeExcerpt will be empty.  By contrast, a class constructor cannot
 * have a return value, so ApiConstructor has no returnTypeExcerpt property at all.
 *
 * @public
 */
export declare class Excerpt {
    readonly tokenRange: Readonly<IExcerptTokenRange>;
    readonly tokens: ReadonlyArray<ExcerptToken>;
    private _text;
    constructor(tokens: ReadonlyArray<ExcerptToken>, tokenRange: IExcerptTokenRange);
    readonly text: string;
}

/** @public */
export declare class ExcerptToken {
    readonly kind: ExcerptTokenKind;
    readonly text: string;
    constructor(kind: ExcerptTokenKind, text: string);
}

/** @public */
export declare const enum ExcerptTokenKind {
    Content = "Content",
    Reference = "Reference"
}

/**
 * Used to invoke the API Extractor tool.
 * @public
 */
export declare class Extractor {
    /**
     * The JSON Schema for API Extractor config file (api-extractor-config.schema.json).
     */
    static jsonSchema: JsonSchema;
    /**
     * Returns the version number of the API Extractor NPM package.
     */
    static readonly version: string;
    /**
     * Returns the package name of the API Extractor NPM package.
     */
    static readonly packageName: string;
    private static _getPackageJson;
    private static _defaultConfig;
    private static _declarationFileExtensionRegExp;
    private static _defaultLogger;
    private readonly _actualConfig;
    private readonly _program;
    private readonly _localBuild;
    private readonly _monitoredLogger;
    private readonly _absoluteRootFolder;
    /**
     * Given a list of absolute file paths, return a list containing only the declaration
     * files.  Duplicates are also eliminated.
     *
     * @remarks
     * The tsconfig.json settings specify the compiler's input (a set of *.ts source files,
     * plus some *.d.ts declaration files used for legacy typings).  However API Extractor
     * analyzes the compiler's output (a set of *.d.ts entry point files, plus any legacy
     * typings).  This requires API Extractor to generate a special file list when it invokes
     * the compiler.
     *
     * For configType=tsconfig this happens automatically, but for configType=runtime it is
     * the responsibility of the custom tooling.  The generateFilePathsForAnalysis() function
     * is provided to facilitate that.  Duplicates are removed so that entry points can be
     * appended without worrying whether they may already appear in the tsconfig.json file list.
     */
    static generateFilePathsForAnalysis(inputFilePaths: string[]): string[];
    /**
     * Invokes the API Extractor engine, using the api extractor configuration file.
     * @param jsonConfigFile - Path to api extractor json config file.
     * @param options - IExtractor options.
     */
    static processProjectFromConfigFile(jsonConfigFile: string, options?: IExtractorOptions): void;
    /**
     * Loads the api extractor config file in Extractor Config object.
     * The jsonConfigFile path specified is relative to project directory path.
     * @param jsonConfigFile - Path to api extractor json config file.
     */
    static loadConfigObject(jsonConfigFile: string): IExtractorConfig;
    private static _applyConfigDefaults;
    constructor(config: IExtractorConfig, options?: IExtractorOptions);
    /**
     * Returns the normalized configuration object after defaults have been applied.
     *
     * @remarks
     * This is a read-only object.  The caller should NOT modify any member of this object.
     * It is provided for diagnostic purposes.  For example, a build script could write
     * this object to a JSON file to report the final configuration options used by API Extractor.
     */
    readonly actualConfig: IExtractorConfig;
    /**
     * Invokes the API Extractor engine, using the configuration that was passed to the constructor.
     * @deprecated Use {@link Extractor.processProject} instead.
     */
    analyzeProject(options?: IAnalyzeProjectOptions): void;
    /**
     * Invokes the API Extractor engine, using the configuration that was passed to the constructor.
     * @param options - provides additional runtime state that is NOT part of the API Extractor
     *     config file.
     * @returns true for a successful build, or false if the tool chain should fail the build
     *
     * @remarks
     *
     * This function returns false to indicate that the build failed, i.e. the command-line tool
     * would return a nonzero exit code.  Normally the build fails if there are any errors or
     * warnings; however, if options.localBuild=true then warnings are ignored.
     */
    processProject(options?: IAnalyzeProjectOptions): boolean;
    private _generateRollupDtsFiles;
    private _generateRollupDtsFile;
    private _getShortFilePath;
    /**
     * Update the parsed command line to use paths from the specified TS compiler folder, if
     * a TS compiler folder is specified.
     */
    private _updateCommandLineForTypescriptPackage;
}

/**
 * Configuration values used for the {@link IExtractorValidationRulesConfig} block.
 * @public
 */
export declare const enum ExtractorValidationRulePolicy {
    /**
     * Violations of the rule will be reported as build errors.
     */
    error = "error",
    /**
     * Violations of the rule are silently ignored.
     */
    allow = "allow"
}

/**
 * Represents a type referenced via an "extends" or "implements" heritage clause for a TypeScript class.
 * @remarks
 *
 * For example, consider this declaration:
 *
 * ```ts
 * export class Widget extends Controls.WidgetBase implements Controls.IWidget, IDisposable {
 *   // . . .
 * }
 * ```
 *
 * The heritage types are `Controls.WidgetBase`, `Controls.IWidget`, and `IDisposable`.
 * @public
 */
export declare class HeritageType {
    /**
     * An excerpt corresponding to the referenced type.
     * @remarks
     *
     * For example, consider this declaration:
     *
     * ```ts
     * export class Widget extends Controls.WidgetBase implements Controls.IWidget, IDisposable {
     *   // . . .
     * }
     * ```
     *
     * The excerpt might be `Controls.WidgetBase`, `Controls.IWidget`, or `IDisposable`.
     */
    readonly excerpt: Excerpt;
    constructor(excerpt: Excerpt);
}

/**
 * Options for {@link Extractor.processProject}.
 * @public
 */
export declare interface IAnalyzeProjectOptions {
    /**
     * If omitted, then the {@link IExtractorConfig.project} config will be used by default.
     */
    projectConfig?: IExtractorProjectConfig;
}

/**
 * Constructor options for {@link ApiCallSignature}.
 * @public
 */
export declare interface IApiCallSignatureOptions extends IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiDeclaredItemOptions {
}

declare interface IApiClassJson extends IApiDeclaredItemJson {
    extendsTokenRange?: IExcerptTokenRange;
    implementsTokenRanges: IExcerptTokenRange[];
}

/**
 * Constructor options for {@link ApiClass}.
 * @public
 */
export declare interface IApiClassOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
    extendsTokenRange: IExcerptTokenRange | undefined;
    implementsTokenRanges: IExcerptTokenRange[];
}

/**
 * Constructor options for {@link ApiConstructor}.
 * @public
 */
export declare interface IApiConstructSignatureOptions extends IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiDeclaredItemOptions {
}

/**
 * Constructor options for {@link ApiConstructor}.
 * @public
 */
export declare interface IApiConstructorOptions extends IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiStaticMixinOptions, IApiDeclaredItemOptions {
}

declare interface IApiDeclaredItemJson extends IApiDocumentedItemJson {
    excerptTokens: IExcerptToken[];
}

/**
 * Constructor options for {@link (ApiDeclaredItem:interface)}.
 * @public
 */
export declare interface IApiDeclaredItemOptions extends IApiDocumentedItemOptions {
    excerptTokens: IExcerptToken[];
}

declare interface IApiDocumentedItemJson extends IApiItemJson {
    docComment: string;
}

/**
 * Constructor options for {@link ApiDocumentedItem}.
 * @public
 */
export declare interface IApiDocumentedItemOptions extends IApiItemOptions {
    docComment: tsdoc.DocComment | undefined;
}

/**
 * Constructor options for {@link ApiEntryPoint}.
 * @public
 */
export declare interface IApiEntryPointOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions {
}

declare interface IApiEnumMemberJson extends IApiDeclaredItemJson {
    initializerTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link ApiEnumMember}.
 * @public
 */
export declare interface IApiEnumMemberOptions extends IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
    initializerTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link ApiEnum}.
 * @public
 */
export declare interface IApiEnumOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
}

/**
 * Constructor options for {@link ApiFunction}.
 * @public
 */
export declare interface IApiFunctionOptions extends IApiNameMixinOptions, IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiDeclaredItemOptions {
}

/**
 * Constructor options for {@link ApiIndexSignature}.
 * @public
 */
export declare interface IApiIndexSignatureOptions extends IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiDeclaredItemOptions {
}

declare interface IApiInterfaceJson extends IApiDeclaredItemJson {
    extendsTokenRanges: IExcerptTokenRange[];
}

/**
 * Constructor options for {@link ApiInterface}.
 * @public
 */
export declare interface IApiInterfaceOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
    extendsTokenRanges: IExcerptTokenRange[];
}

declare interface IApiItemConstructor extends Constructor<ApiItem>, PropertiesOf<typeof ApiItem> {
}

/**
 * Constructor options for {@link (ApiItemContainerMixin:interface)}.
 * @public
 */
export declare interface IApiItemContainerMixinOptions extends IApiItemOptions {
    members?: ApiItem[];
}

declare interface IApiItemJson {
    kind: ApiItemKind;
    canonicalReference: string;
}

/**
 * Constructor options for {@link ApiItem}.
 * @public
 */
export declare interface IApiItemOptions {
}

/**
 * Constructor options for {@link ApiMethod}.
 * @public
 */
export declare interface IApiMethodOptions extends IApiNameMixinOptions, IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiStaticMixinOptions, IApiDeclaredItemOptions {
}

/** @public */
export declare interface IApiMethodSignatureOptions extends IApiNameMixinOptions, IApiParameterListMixinOptions, IApiReleaseTagMixinOptions, IApiReturnTypeMixinOptions, IApiDeclaredItemOptions {
}

/**
 * Constructor options for {@link (IApiNameMixinOptions:interface)}.
 * @public
 */
declare interface IApiNameMixinOptions extends IApiItemOptions {
    name: string;
}

/**
 * Constructor options for {@link ApiClass}.
 * @public
 */
export declare interface IApiNamespaceOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
}

/**
 * Constructor options for {@link ApiPackage}.
 * @public
 */
export declare interface IApiPackageOptions extends IApiItemContainerMixinOptions, IApiNameMixinOptions, IApiDocumentedItemOptions {
}

/**
 * Constructor options for {@link (ApiParameterListMixin:interface)}.
 * @public
 */
export declare interface IApiParameterListMixinOptions extends IApiItemOptions {
    overloadIndex: number;
    parameters: IApiParameterOptions[];
}

/**
 * Represents parameter information that is part of {@link IApiParameterListMixinOptions}
 * @public
 */
declare interface IApiParameterOptions {
    parameterName: string;
    parameterTypeTokenRange: IExcerptTokenRange;
}

declare interface IApiPropertyItemJson extends IApiDeclaredItemJson {
    propertyTypeTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link ApiPropertyItem}.
 * @public
 */
export declare interface IApiPropertyItemOptions extends IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
    propertyTypeTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link ApiProperty}.
 * @public
 */
export declare interface IApiPropertyOptions extends IApiPropertyItemOptions, IApiStaticMixinOptions {
}

/**
 * Constructor options for {@link ApiPropertySignature}.
 * @public
 */
export declare interface IApiPropertySignatureOptions extends IApiPropertyItemOptions {
}

/**
 * Constructor options for {@link (ApiReleaseTagMixin:interface)}.
 * @public
 */
export declare interface IApiReleaseTagMixinOptions extends IApiItemOptions {
    releaseTag: ReleaseTag;
}

declare interface IApiReturnTypeMixinJson extends IApiItemJson {
    returnTypeTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link (ApiReturnTypeMixin:interface)}.
 * @public
 */
export declare interface IApiReturnTypeMixinOptions extends IApiItemOptions {
    returnTypeTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link (IApiStaticMixinOptions:interface)}.
 * @public
 */
export declare interface IApiStaticMixinOptions extends IApiItemOptions {
    isStatic: boolean;
}

/**
 * Constructor options for {@link ApiTypeAlias}.
 * @public
 */
export declare interface IApiTypeAliasOptions extends IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
}

declare interface IApiVariableJson extends IApiDeclaredItemJson {
    variableTypeTokenRange: IExcerptTokenRange;
}

/**
 * Constructor options for {@link ApiVariable}.
 * @public
 */
export declare interface IApiVariableOptions extends IApiNameMixinOptions, IApiReleaseTagMixinOptions, IApiDeclaredItemOptions {
    variableTypeTokenRange: IExcerptTokenRange;
}

/** @public */
export declare interface IExcerptToken {
    readonly kind: ExcerptTokenKind;
    text: string;
}

/** @public */
export declare interface IExcerptTokenRange {
    startIndex: number;
    endIndex: number;
}

/**
 * Configures how the API JSON files (*.api.json) will be generated.
 *
 * @public
 */
export declare interface IExtractorApiJsonFileConfig {
    /**
     * Whether to generate API JSON files at all.  The default is true.
     */
    enabled: boolean;
    /**
     * Specifies where the *.api.json file should be written.
     *
     * The default value is "./dist"
     */
    outputFolder?: string;
}

/**
 * Configures how the API review files (*.api.ts) will be generated.
 *
 * @public
 */
export declare interface IExtractorApiReviewFileConfig {
    /**
     * Whether to generate review files at all.  The default is true.
     */
    enabled: boolean;
    /**
     * The file path of the folder containing API review file, relative to
     * the project folder.  This is part of an API review workflow:  During a build,
     * the API Extractor will output an API file, e.g. "my-project/temp/my-project.api.ts".
     * It will then compare this file against the last reviewed file,
     * e.g. "../api-review/my-project.api.ts" (assuming that apiReviewFolder is "../api-review").
     * If the files are different, the build will fail with an error message that instructs
     * the developer to update the approved file, and then commit it to Git.  When they
     * create a Pull Request, a branch policy will look for changes under "api-review/*"
     * and require signoff from the appropriate reviewers.
     *
     * The default value is "./etc".
     *
     * Example: "config" (for a standalone project)
     * Example: "../../common/api-review"  (for a Git repository with Rush)
     */
    apiReviewFolder?: string;
    /**
     * The *.api.ts report is saved into this folder.  During a production build
     * (i.e. when IExtractorRuntimeOptions.productionBuild=true) the temporary file will
     * be compared with the file in apiReviewFolder; if there are differences, and error
     * will be reported.  During a non-production build, the temporary file will be
     * automatically copied to the apiReviewFolder.
     *
     * The default value is "./temp".
     */
    tempFolder?: string;
}

/**
 * Configuration options for the API Extractor tool.  These options can be loaded
 * from a JSON config file.
 *
 * @public
 */
export declare interface IExtractorConfig {
    /**
     * Path to json config file from which config should extend.
     * The path specified in this field is relative to current config file path.
     */
    extends?: string;
    /**
     * Determines how the TypeScript compiler will be invoked.
     * The compiler.configType selects the type of configuration;
     * Different options are available according to the configuration type.
     */
    compiler: IExtractorTsconfigCompilerConfig | IExtractorRuntimeCompilerConfig;
    /**
     * {@inheritdoc IExtractorPoliciesConfig}
     */
    policies?: IExtractorPoliciesConfig;
    /**
     * {@inheritdoc IExtractorValidationRulesConfig}
     */
    validationRules?: IExtractorValidationRulesConfig;
    /**
     * {@inheritdoc IExtractorProjectConfig}
     */
    project: IExtractorProjectConfig;
    /**
     * {@inheritdoc IExtractorApiReviewFileConfig}
     */
    apiReviewFile?: IExtractorApiReviewFileConfig;
    /**
     * {@inheritdoc IExtractorApiJsonFileConfig}
     */
    apiJsonFile?: IExtractorApiJsonFileConfig;
    /**
     * {@inheritdoc IExtractorDtsRollupConfig}
     * @beta
     */
    dtsRollup?: IExtractorDtsRollupConfig;
}

/**
 * Configures how the *.d.ts rollup files will be generated.
 *
 * @remarks
 * API Extractor can generate a consolidated *.d.ts file that contains all
 * the exported typings for the package entry point.  It can also trim
 * \@alpha, \@beta, and \@internal definitions according to the release type.
 *
 * @beta
 */
export declare interface IExtractorDtsRollupConfig {
    /**
     * Whether to generate rollup *.d.ts files.  The default is false.
     */
    enabled: boolean;
    /**
     * If "trimming" is false (the default), then a single *.d.ts rollup file will be generated in the
     * "publishFolder".  If "trimming" is true, then three separate *.d.ts rollups will be
     * generated in "publishFolderForInternal", "publishFolderForBeta", and "publishFolderForPublic".
     *
     * @remarks
     * In either case, "mainDtsRollupPath" indicates the relative file path.
     */
    trimming?: boolean;
    /**
     * This setting is only used if "trimming" is false.
     * It indicates the folder where "npm publish" will be run.  The default value is "./dist".
     */
    publishFolder?: string;
    /**
     * This setting is only used if "trimming" is true.
     * It indicates the folder where "npm publish" will be run for an internal release.
     * The default value is "./dist/internal".
     *
     * @remarks
     * An internal release will contain all definitions that are reachable from the entry point.
     */
    publishFolderForInternal?: string;
    /**
     * This setting is only used if "trimming" is true.
     * It indicates the folder where "npm publish" will be run for a beta release.
     * The default value is "./dist/beta".
     *
     * @remarks
     * A beta release will contain all definitions that are reachable from the entry point,
     * except definitions marked as \@alpha or \@internal.
     */
    publishFolderForBeta?: string;
    /**
     * This setting is only used if "trimming" is true.
     * It indicates the folder where "npm publish" will be run for a public release.
     * The default value is "./dist/public".
     *
     * @remarks
     * A public release will contain all definitions that are reachable from the entry point,
     * except definitions marked as \@beta, \@alpha, or \@internal.
     */
    publishFolderForPublic?: string;
    /**
     * Specifies the relative path for the *.d.ts rollup file to be generated for the
     * package's main entry point.  The default value is an empty string, which causes
     * the path to be automatically inferred from the "typings" field of the project's
     * package.json file.
     *
     * @remarks
     * If specified, the value must be a relative path that can be combined with one of
     * the publish folder settings.
     */
    mainDtsRollupPath?: string;
}

/**
 * Runtime options for Extractor.
 *
 * @public
 */
export declare interface IExtractorOptions {
    /**
     * If IExtractorConfig.project.configType = 'runtime', then the TypeScript compiler state
     * must be provided via this option.
     */
    compilerProgram?: ts.Program;
    /**
     * Allows the caller to handle API Extractor errors; otherwise, they will be logged
     * to the console.
     */
    customLogger?: Partial<ILogger>;
    /**
     * Indicates that API Extractor is running as part of a local build, e.g. on developer's
     * machine. This disables certain validation that would normally be performed
     * for a ship/production build. For example, the *.api.ts review file is
     * automatically local in a debug build.
     *
     * The default value is false.
     */
    localBuild?: boolean;
    /**
     * By default API Extractor uses its own TypeScript compiler version to analyze your project.
     * This can often cause compiler errors due to incompatibilities between different TS versions.
     * Use this option to specify the folder path for your compiler version.
     *
     * @remarks
     * This option only applies when compiler.config.configType is set to "tsconfig"
     *
     * @beta
     */
    typescriptCompilerFolder?: string;
    /**
     * This option causes the typechecker to be invoked with the --skipLibCheck option. This option is not
     * recommended and may cause API Extractor to produce incomplete or incorrect declarations, but it
     * may be required when dependencies contain declarations that are incompatible with the TypeScript engine
     * that API Extractor uses for its analysis. If this option is used, it is strongly recommended that broken
     * dependencies be fixed or upgraded.
     *
     * @remarks
     * This option only applies when compiler.config.configType is set to "tsconfig"
     */
    skipLibCheck?: boolean;
}

/**
 * These policies determine how API Extractor validates various best practices for API design.
 *
 * @public
 */
export declare interface IExtractorPoliciesConfig {
    /**
     * Controls how API Extractor treats the TypeScript namespace keyword:
     *
     * conservative - (the default) namespaces may only be used to represent tables of constants
     *
     * permissive - arbitrary nesting of namespaces is allowed
     */
    namespaceSupport?: 'conservative' | 'permissive';
}

/**
 * Describes a specific project that will be analyzed.  In principle, multiple individual
 * projects can be processed while reusing a common compiler state.
 *
 * @public
 */
export declare interface IExtractorProjectConfig {
    /**
     * Specifies the TypeScript *.d.ts file that will be treated as the entry point
     * for compilation.  Typically this corresponds to the "typings" or "types" field
     * from package.json, but secondary entry points are also possible.
     *
     * @remarks
     * The file extension must not be *.ts.  API Extractor does NOT process TypeScript
     * source code, but instead the output of the compiler.  This is needed for compatibility
     * with preprocessors and also custom tooling that produces TypeScript-compatible outputs
     * without using the real compiler.  It also speeds up the analysis by avoiding the
     * need to parse implementation code.
     */
    entryPointSourceFile: string;
}

/**
 * With this configuration, API Extractor is configured using an already prepared compiler state
 * that is provided programmatically at runtime.  This can potentially enable faster builds,
 * by reusing the same compiler invocation for tsc, tslint, and API Extractor.
 *
 * If configType='runtime' is specified, then IExtractorRuntimeOptions.compilerProgram must be
 * provided.
 *
 * @public
 */
export declare interface IExtractorRuntimeCompilerConfig {
    configType: 'runtime';
}

/**
 * With this configuration, API Extractor configures the compiler based on settings that
 * it finds in the project's tsconfig.json file.
 *
 * @public
 */
export declare interface IExtractorTsconfigCompilerConfig {
    configType: 'tsconfig';
    /**
     * The root folder for the project.
     * @remarks
     * This folder typically contains the tsconfig.json and package.json config files.
     */
    rootFolder: string;
    /**
     * Override the tsconfig.json file contents.
     *
     * @remarks
     * Provides already parsed tsconfig.json contents conforming to the TypeScript tsconfig schema:
     * http://json.schemastore.org/tsconfig
     *
     * If omitted, then by default the tsconfig.json file will be loaded from the root folder.
     */
    overrideTsconfig?: {};
}

/**
 * Configuration for various validation checks that ensure good API design
 *
 * @public
 */
export declare interface IExtractorValidationRulesConfig {
    /**
     * This rule checks for top-level API items that are missing a release tag such as \@beta or \@internal.
     * If "allow" is chosen, then missing release tags will be assumed to be \@public.
     * The default policy is "error".
     */
    missingReleaseTags?: ExtractorValidationRulePolicy;
}

/**
 * Provides a custom logging service to API Extractor.
 * @public
 */
export declare interface ILogger {
    /**
     * Log a message that will only be shown in a "verbose" logging mode.
     */
    logVerbose(message: string): void;
    /**
     * Log a normal message.
     */
    logInfo(message: string): void;
    /**
     * Log a warning message.  Typically it is shown in yellow and will break a production build.
     */
    logWarning(message: string): void;
    /**
     * Log an error message.  Typically it is shown in red and will break a production build.
     */
    logError(message: string): void;
}

/**
 * Constructor options for {@link Parameter}.
 * @public
 */
export declare interface IParameterOptions {
    name: string;
    parameterTypeExcerpt: Excerpt;
    parent: ApiParameterListMixin;
}

/**
 * Result object for {@link ApiModel.resolveDeclarationReference}.
 *
 * @public
 */
export declare interface IResolveDeclarationReferenceResult {
    /**
     * The referenced ApiItem, if the declaration reference could be resolved.
     */
    resolvedApiItem: ApiItem | undefined;
    /**
     * If resolvedApiItem is undefined, then this will always contain an error message explaining why the
     * resolution failed.
     */
    errorMessage: string | undefined;
}

/**
  * A utility for writing indented text.
  *
  * @remarks
  *
  * Note that the indentation is inserted at the last possible opportunity.
  * For example, this code...
  *
  * ```ts
  *   writer.write('begin\n');
  *   writer.increaseIndent();
  *   writer.write('one\ntwo\n');
  *   writer.decreaseIndent();
  *   writer.increaseIndent();
  *   writer.decreaseIndent();
  *   writer.write('end');
  * ```
  *
  * ...would produce this output:
  *
  * ```
  *   begin
  *     one
  *     two
  *   end
  * ```
  *
  * @beta
  */
export declare class IndentedWriter {
    /**
     * The text characters used to create one level of indentation.
     * Two spaces by default.
     */
    defaultIndentPrefix: string;
    private readonly _builder;
    private _latestChunk;
    private _previousChunk;
    private _atStartOfLine;
    private readonly _indentStack;
    private _indentText;
    constructor(builder?: IStringBuilder);
    /**
     * Retrieves the output that was built so far.
     */
    getText(): string;
    toString(): string;
    /**
     * Increases the indentation.  Normally the indentation is two spaces,
     * however an arbitrary prefix can optional be specified.  (For example,
     * the prefix could be "// " to indent and comment simultaneously.)
     * Each call to IndentedWriter.increaseIndent() must be followed by a
     * corresponding call to IndentedWriter.decreaseIndent().
     */
    increaseIndent(indentPrefix?: string): void;
    /**
     * Decreases the indentation, reverting the effect of the corresponding call
     * to IndentedWriter.increaseIndent().
     */
    decreaseIndent(): void;
    /**
     * A shorthand for ensuring that increaseIndent()/decreaseIndent() occur
     * in pairs.
     */
    indentScope(scope: () => void, indentPrefix?: string): void;
    /**
     * Adds a newline if the file pointer is not already at the start of the line (or start of the stream).
     */
    ensureNewLine(): void;
    /**
     * Adds up to two newlines to ensure that there is a blank line above the current line.
     */
    ensureSkippedLine(): void;
    /**
     * Returns the last character that was written, or an empty string if no characters have been written yet.
     */
    peekLastCharacter(): string;
    /**
     * Returns the second to last character that was written, or an empty string if less than one characters
     * have been written yet.
     */
    peekSecondLastCharacter(): string;
    /**
     * Writes some text to the internal string buffer, applying indentation according
     * to the current indentation level.  If the string contains multiple newlines,
     * each line will be indented separately.
     */
    write(message: string): void;
    /**
     * A shorthand for writing an optional message, followed by a newline.
     * Indentation is applied following the semantics of IndentedWriter.write().
     */
    writeLine(message?: string): void;
    /**
     * Writes a string that does not contain any newline characters.
     */
    private _writeLinePart;
    private _writeNewLine;
    private _write;
    private _updateIndentText;
}

/**
 * Represents a named parameter for a function-like declaration.
 *
 * @remarks
 *
 * `Parameter` represents a TypeScript declaration such as `x: number` in this example:
 *
 * ```ts
 * export function add(x: number, y: number): number {
 *   return x + y;
 * }
 * ```
 *
 * `Parameter` objects belong to the {@link ApiParameterListMixin.parameters} collection.
 *
 * @public
 */
export declare class Parameter {
    /**
     * An {@link Excerpt} that describes the type of the parameter.
     */
    readonly parameterTypeExcerpt: Excerpt;
    /**
     * The parameter name.
     */
    name: string;
    private _parent;
    constructor(options: IParameterOptions);
    /**
     * Returns the `@param` documentation for this parameter, if present.
     */
    readonly tsdocParamBlock: tsdoc.DocParamBlock | undefined;
}

export declare type PropertiesOf<T> = {
    [K in keyof T]: T[K];
};

/**
  * A "release tag" is a custom TSDoc tag that is applied to an API to communicate the level of support
  * provided for third-party developers.
  *
  * @remarks
  *
  * The four release tags are: `@internal`, `@alpha`, `@beta`, and `@public`. They are applied to API items such
  * as classes, member functions, enums, etc.  The release tag applies recursively to members of a container
  * (e.g. class or interface). For example, if a class is marked as `@beta`, then all of its members automatically
  * have this status; you DON'T need add the `@beta` tag to each member function. However, you could add
  * `@internal` to a member function to give it a different release status.
  *
  * @public
  */
export declare enum ReleaseTag {
    /**
     * No release tag was specified in the AEDoc summary.
     */
    None = 0,
    /**
     * Indicates that an API item is meant only for usage by other NPM packages from the same
     * maintainer. Third parties should never use "internal" APIs. (To emphasize this, their
     * names are prefixed by underscores.)
     */
    Internal = 1,
    /**
     * Indicates that an API item is eventually intended to be public, but currently is in an
     * early stage of development. Third parties should not use "alpha" APIs.
     */
    Alpha = 2,
    /**
     * Indicates that an API item has been released in an experimental state. Third parties are
     * encouraged to try it and provide feedback. However, a "beta" API should NOT be used
     * in production.
     */
    Beta = 3,
    /**
     * Indicates that an API item has been officially released. It is part of the supported
     * contract (e.g. SemVer) for a package.
     */
    Public = 4
}
