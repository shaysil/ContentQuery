"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const Collector_1 = require("../collector/Collector");
const TypeScriptHelpers_1 = require("../analyzer/TypeScriptHelpers");
const Span_1 = require("../analyzer/Span");
const AstDeclaration_1 = require("../analyzer/AstDeclaration");
const tsdoc_1 = require("@microsoft/tsdoc");
const ReleaseTag_1 = require("../aedoc/ReleaseTag");
const node_core_library_1 = require("@microsoft/node-core-library");
class ReviewFileGenerator {
    /**
     * Compares the contents of two API files that were created using ApiFileGenerator,
     * and returns true if they are equivalent.  Note that these files are not normally edited
     * by a human; the "equivalence" comparison here is intended to ignore spurious changes that
     * might be introduced by a tool, e.g. Git newline normalization or an editor that strips
     * whitespace when saving.
     */
    static areEquivalentApiFileContents(actualFileContent, expectedFileContent) {
        // NOTE: "\s" also matches "\r" and "\n"
        const normalizedActual = actualFileContent.replace(/[\s]+/g, ' ');
        const normalizedExpected = expectedFileContent.replace(/[\s]+/g, ' ');
        return normalizedActual === normalizedExpected;
    }
    static generateReviewFileContent(collector) {
        const output = new tsdoc_1.StringBuilder();
        for (const entity of collector.entities) {
            if (entity.exported) {
                if (!entity.astSymbol.astImport) {
                    // Emit all the declarations for this entry
                    for (const astDeclaration of entity.astSymbol.astDeclarations || []) {
                        output.append(ReviewFileGenerator._getAedocSynopsis(collector, astDeclaration));
                        const span = new Span_1.Span(astDeclaration.declaration);
                        ReviewFileGenerator._modifySpan(collector, span, entity, astDeclaration);
                        span.writeModifiedText(output);
                        output.append('\n\n');
                    }
                }
                else {
                    // This definition is reexported from another package, so write it as an "export" line
                    // In general, we don't report on external packages; if that's important we assume API Extractor
                    // would be enabled for the upstream project.  But see GitHub issue #896 for a possible exception.
                    const astImport = entity.astSymbol.astImport;
                    if (astImport.exportName === '*') {
                        output.append(`export * as ${entity.nameForEmit}`);
                    }
                    else if (entity.nameForEmit !== astImport.exportName) {
                        output.append(`export { ${astImport.exportName} as ${entity.nameForEmit} }`);
                    }
                    else {
                        output.append(`export { ${astImport.exportName} }`);
                    }
                    output.append(` from '${astImport.modulePath}';\n`);
                }
            }
        }
        if (collector.starExportedExternalModulePaths.length > 0) {
            output.append('\n');
            for (const starExportedExternalModulePath of collector.starExportedExternalModulePaths) {
                output.append(`export * from "${starExportedExternalModulePath}";\n`);
            }
        }
        if (collector.package.tsdocComment === undefined) {
            output.append('\n');
            ReviewFileGenerator._writeLineAsComment(output, '(No @packageDocumentation comment for this package)');
        }
        return output.toString();
    }
    /**
     * Before writing out a declaration, _modifySpan() applies various fixups to make it nice.
     */
    static _modifySpan(collector, span, entity, astDeclaration) {
        // Should we process this declaration at all?
        if ((astDeclaration.modifierFlags & ts.ModifierFlags.Private) !== 0) { // tslint:disable-line:no-bitwise
            span.modification.skipAll();
            return;
        }
        let recurseChildren = true;
        let sortChildren = false;
        switch (span.kind) {
            case ts.SyntaxKind.JSDocComment:
                span.modification.skipAll();
                // For now, we don't transform JSDoc comment nodes at all
                recurseChildren = false;
                break;
            case ts.SyntaxKind.ExportKeyword:
            case ts.SyntaxKind.DefaultKeyword:
                span.modification.skipAll();
                break;
            case ts.SyntaxKind.SyntaxList:
                if (span.parent) {
                    if (AstDeclaration_1.AstDeclaration.isSupportedSyntaxKind(span.parent.kind)) {
                        // If the immediate parent is an API declaration, and the immediate children are API declarations,
                        // then sort the children alphabetically
                        sortChildren = true;
                    }
                    else if (span.parent.kind === ts.SyntaxKind.ModuleBlock) {
                        // Namespaces are special because their chain goes ModuleDeclaration -> ModuleBlock -> SyntaxList
                        sortChildren = true;
                    }
                }
                break;
            case ts.SyntaxKind.VariableDeclaration:
                if (!span.parent) {
                    // The VariableDeclaration node is part of a VariableDeclarationList, however
                    // the Entry.followedSymbol points to the VariableDeclaration part because
                    // multiple definitions might share the same VariableDeclarationList.
                    //
                    // Since we are emitting a separate declaration for each one, we need to look upwards
                    // in the ts.Node tree and write a copy of the enclosing VariableDeclarationList
                    // content (e.g. "var" from "var x=1, y=2").
                    const list = TypeScriptHelpers_1.TypeScriptHelpers.matchAncestor(span.node, [ts.SyntaxKind.VariableDeclarationList, ts.SyntaxKind.VariableDeclaration]);
                    if (!list) {
                        // This should not happen unless the compiler API changes somehow
                        throw new node_core_library_1.InternalError('Unsupported variable declaration');
                    }
                    const listPrefix = list.getSourceFile().text
                        .substring(list.getStart(), list.declarations[0].getStart());
                    span.modification.prefix = 'declare ' + listPrefix + span.modification.prefix;
                    span.modification.suffix = ';';
                }
                break;
            case ts.SyntaxKind.Identifier:
                let nameFixup = false;
                const identifierSymbol = collector.typeChecker.getSymbolAtLocation(span.node);
                if (identifierSymbol) {
                    const followedSymbol = TypeScriptHelpers_1.TypeScriptHelpers.followAliases(identifierSymbol, collector.typeChecker);
                    const referencedEntity = collector.tryGetEntityBySymbol(followedSymbol);
                    if (referencedEntity) {
                        if (!referencedEntity.nameForEmit) {
                            // This should never happen
                            throw new Error('referencedEntry.uniqueName is undefined');
                        }
                        span.modification.prefix = referencedEntity.nameForEmit;
                        nameFixup = true;
                        // For debugging:
                        // span.modification.prefix += '/*R=FIX*/';
                    }
                }
                if (!nameFixup) {
                    // For debugging:
                    // span.modification.prefix += '/*R=KEEP*/';
                }
                break;
        }
        if (recurseChildren) {
            for (const child of span.children) {
                let childAstDeclaration = astDeclaration;
                if (AstDeclaration_1.AstDeclaration.isSupportedSyntaxKind(child.kind)) {
                    childAstDeclaration = collector.astSymbolTable.getChildAstDeclarationByNode(child.node, astDeclaration);
                    if (sortChildren) {
                        span.modification.sortChildren = true;
                        child.modification.sortKey = Collector_1.Collector.getSortKeyIgnoringUnderscore(childAstDeclaration.astSymbol.localName);
                    }
                    const aedocSynopsis = ReviewFileGenerator._getAedocSynopsis(collector, childAstDeclaration);
                    const indentedAedocSynopsis = ReviewFileGenerator._addIndentAfterNewlines(aedocSynopsis, child.getIndent());
                    child.modification.prefix = indentedAedocSynopsis + child.modification.prefix;
                }
                ReviewFileGenerator._modifySpan(collector, child, entity, childAstDeclaration);
            }
        }
    }
    /**
     * Writes a synopsis of the AEDoc comments, which indicates the release tag,
     * whether the item has been documented, and any warnings that were detected
     * by the analysis.
     */
    static _getAedocSynopsis(collector, astDeclaration) {
        const output = new tsdoc_1.StringBuilder();
        const declarationMetadata = collector.fetchMetadata(astDeclaration);
        const symbolMetadata = collector.fetchMetadata(astDeclaration.astSymbol);
        const footerParts = [];
        if (!symbolMetadata.releaseTagSameAsParent) {
            switch (symbolMetadata.releaseTag) {
                case ReleaseTag_1.ReleaseTag.Internal:
                    footerParts.push('@internal');
                    break;
                case ReleaseTag_1.ReleaseTag.Alpha:
                    footerParts.push('@alpha');
                    break;
                case ReleaseTag_1.ReleaseTag.Beta:
                    footerParts.push('@beta');
                    break;
                case ReleaseTag_1.ReleaseTag.Public:
                    footerParts.push('@public');
                    break;
            }
        }
        if (declarationMetadata.isSealed) {
            footerParts.push('@sealed');
        }
        if (declarationMetadata.isVirtual) {
            footerParts.push('@virtual');
        }
        if (declarationMetadata.isOverride) {
            footerParts.push('@override');
        }
        if (declarationMetadata.isEventProperty) {
            footerParts.push('@eventproperty');
        }
        if (declarationMetadata.tsdocComment) {
            if (declarationMetadata.tsdocComment.deprecatedBlock) {
                footerParts.push('@deprecated');
            }
        }
        if (declarationMetadata.needsDocumentation) {
            footerParts.push('(undocumented)');
        }
        if (footerParts.length > 0) {
            ReviewFileGenerator._writeLineAsComment(output, footerParts.join(' '));
        }
        return output.toString();
    }
    static _writeLineAsComment(output, line) {
        output.append('// ');
        output.append(line);
        output.append('\n');
    }
    static _addIndentAfterNewlines(text, indent) {
        if (text.length === 0 || indent.length === 0) {
            return text;
        }
        return node_core_library_1.Text.replaceAll(text, '\n', '\n' + indent);
    }
}
exports.ReviewFileGenerator = ReviewFileGenerator;
//# sourceMappingURL=ReviewFileGenerator.js.map