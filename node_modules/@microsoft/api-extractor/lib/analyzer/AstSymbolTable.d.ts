import * as ts from 'typescript';
import { PackageJsonLookup } from '@microsoft/node-core-library';
import { AstDeclaration } from './AstDeclaration';
import { AstSymbol } from './AstSymbol';
import { AstModule, AstModuleExportInfo } from './AstModule';
import { ILogger } from '../api/ILogger';
/**
 * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.
 * It maintains a cache of already constructed objects.  AstSymbolTable constructs
 * AstModule objects, but otherwise the state that it maintains  is agnostic of
 * any particular entry point.  (For example, it does not track whether a given AstSymbol
 * is "exported" or not.)
 *
 * Internally, AstSymbolTable relies on ExportAnalyzer to crawl import statements and determine where symbols
 * are declared (i.e. the AstImport information needed to import them).
 */
export declare class AstSymbolTable {
    private readonly _program;
    private readonly _typeChecker;
    private readonly _packageMetadataManager;
    private readonly _exportAnalyzer;
    /**
     * A mapping from ts.Symbol --> AstSymbol
     * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys
     * are possible.
     *
     * After following type aliases, we use this map to look up the corresponding AstSymbol.
     */
    private readonly _astSymbolsBySymbol;
    /**
     * A mapping from ts.Declaration --> AstDeclaration
     */
    private readonly _astDeclarationsByDeclaration;
    /**
     * A mapping from AstImport.key --> AstSymbol.
     *
     * If AstSymbol.astImport is undefined, then it is not included in the map.
     */
    private readonly _astSymbolsByImportKey;
    constructor(program: ts.Program, typeChecker: ts.TypeChecker, packageJsonLookup: PackageJsonLookup, logger: ILogger);
    /**
     * For a given source file, this analyzes all of its exports and produces an AstModule
     * object.
     */
    fetchEntryPointModule(sourceFile: ts.SourceFile): AstModule;
    fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo;
    fetchReferencedAstSymbol(symbol: ts.Symbol, sourceFile: ts.SourceFile): AstSymbol | undefined;
    /**
     * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation
     * starts from the root symbol and then fills out all children of all declarations, and
     * also calculates AstDeclaration.referencedAstSymbols for all declarations.
     * If the symbol is not imported, any non-imported references are also analyzed.
     *
     * @remarks
     * This is an expensive operation, so we only perform it for top-level exports of an
     * the AstModule.  For example, if some code references a nested class inside
     * a namespace from another library, we do not analyze any of that class's siblings
     * or members.  (We do always construct its parents however, since AstDefinition.parent
     * is immutable, and needed e.g. to calculate release tag inheritance.)
     */
    analyze(astSymbol: AstSymbol): void;
    /**
     * Looks up the AstSymbol corresponding to the given ts.Symbol.
     * This will not analyze or construct any new AstSymbol objects.
     */
    tryGetAstSymbol(symbol: ts.Symbol): AstSymbol | undefined;
    /**
     * For a given astDeclaration, this efficiently finds the child corresponding to the
     * specified ts.Node.  It is assumed that isAstDeclaration() would return true for
     * that node type, and that the node is an immediate child of the provided AstDeclaration.
     */
    getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration;
    /**
     * Used by analyze to recursively analyze the entire child tree.
     */
    private _analyzeChildTree;
    private _fetchAstDeclaration;
    private _fetchAstSymbolForNode;
    private _fetchAstSymbol;
    /**
     * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.
     */
    private _tryFindFirstAstDeclarationParent;
}
