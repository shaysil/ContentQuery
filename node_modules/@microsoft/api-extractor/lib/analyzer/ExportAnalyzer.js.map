{"version":3,"file":"ExportAnalyzer.js","sourceRoot":"","sources":["../../src/analyzer/ExportAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { InternalError } from '@microsoft/node-core-library';\r\n\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { IAstImportOptions } from './AstImport';\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { TypeScriptInternals } from './TypeScriptInternals';\r\nimport { TypeScriptMessageFormatter } from './TypeScriptMessageFormatter';\r\n\r\n/**\r\n * Exposes the minimal APIs from AstSymbolTable that are needed by ExportAnalyzer.\r\n *\r\n * In particular, we want ExportAnalyzer to be able to call AstSymbolTable._fetchAstSymbol() even though it\r\n * is a very private API that should not be exposed to any other components.\r\n */\r\nexport interface IAstSymbolTable {\r\n  fetchAstSymbol(followedSymbol: ts.Symbol, addIfMissing: boolean,\r\n    astImportOptions: IAstImportOptions | undefined, localName?: string): AstSymbol | undefined;\r\n\r\n  analyze(astSymbol: AstSymbol): void;\r\n}\r\n\r\n/**\r\n * Used with ExportAnalyzer.fetchAstModuleBySourceFile() to provide contextual information about how the source file\r\n * was imported.\r\n */\r\ninterface IAstModuleReference {\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * string `\"some-package\"`.\r\n   */\r\n  moduleSpecifier: string;\r\n\r\n  /**\r\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\r\n   * symbol for `X`.\r\n   */\r\n  moduleSpecifierSymbol: ts.Symbol;\r\n}\r\n\r\n/**\r\n * The ExportAnalyzer is an internal part of AstSymbolTable that has been moved out into its own source file\r\n * because it is a complex and mostly self-contained algorithm.\r\n *\r\n * Its job is to build up AstModule objects by crawling import statements to discover where declarations come from.\r\n * This is conceptually the same as the compiler's own TypeChecker.getExportsOfModule(), except that when\r\n * ExportAnalyzer encounters a declaration that was imported from an external package, it remembers how it was imported\r\n * (i.e. the AstImport object).  Today the compiler API does not expose this information, which is crucial for\r\n * generating .d.ts rollups.\r\n */\r\nexport class ExportAnalyzer {\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _astSymbolTable: IAstSymbolTable;\r\n\r\n  private readonly _astModulesBySourceFile: Map<ts.SourceFile, AstModule>\r\n    = new Map<ts.SourceFile, AstModule>();\r\n\r\n  // Used with isImportableAmbientSourceFile()\r\n  private readonly _importableAmbientSourceFiles: Set<ts.SourceFile> = new Set<ts.SourceFile>();\r\n\r\n  public constructor(program: ts.Program, typeChecker: ts.TypeChecker, astSymbolTable: IAstSymbolTable) {\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._astSymbolTable = astSymbolTable;\r\n  }\r\n\r\n  /**\r\n   * For a given source file, this analyzes all of its exports and produces an AstModule object.\r\n   *\r\n   * @param moduleReference - contextual information about the import statement that took us to this source file,\r\n   * or `undefined` if this source file is the initial entry point\r\n   */\r\n  public fetchAstModuleBySourceFile(sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined): AstModule {\r\n\r\n    // Don't traverse into a module that we already processed before:\r\n    // The compiler allows m1 to have \"export * from 'm2'\" and \"export * from 'm3'\",\r\n    // even if m2 and m3 both have \"export * from 'm4'\".\r\n    let astModule: AstModule | undefined = this._astModulesBySourceFile.get(sourceFile);\r\n\r\n    if (!astModule) {\r\n      const moduleSymbol: ts.Symbol = this._getSymbolForSourceFile(sourceFile, moduleReference);\r\n\r\n      // (If moduleReference === undefined, then this is the entry point of the local project being analyzed.)\r\n      let externalModulePath: string | undefined = undefined;\r\n      if (moduleReference !== undefined) {\r\n        // Match:       \"@microsoft/sp-lodash-subset\" or \"lodash/has\"\r\n        // but ignore:  \"../folder/LocalFile\"\r\n        if (!ts.isExternalModuleNameRelative(moduleReference.moduleSpecifier)) {\r\n          // This makes astModule.isExternal=true\r\n          externalModulePath = moduleReference.moduleSpecifier;\r\n        }\r\n      }\r\n\r\n      astModule = new AstModule(sourceFile, moduleSymbol, externalModulePath);\r\n      this._astModulesBySourceFile.set(sourceFile, astModule);\r\n\r\n      if (astModule.isExternal) {\r\n        // It's an external package, so do the special simplified analysis that doesn't crawl into referenced modules\r\n        for (const exportedSymbol of this._typeChecker.getExportsOfModule(moduleSymbol)) {\r\n\r\n          if (externalModulePath === undefined) {\r\n            throw new InternalError('Failed assertion: externalModulePath=undefined but astModule.isExternal=true');\r\n          }\r\n\r\n          const astImportOptions: IAstImportOptions = {\r\n            exportName: exportedSymbol.name,\r\n            modulePath: externalModulePath\r\n          };\r\n\r\n          const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(exportedSymbol, this._typeChecker);\r\n\r\n          // Ignore virtual symbols that don't have any declarations\r\n          if (TypeScriptHelpers.hasAnyDeclarations(followedSymbol)) {\r\n            const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol(\r\n              followedSymbol, true, astImportOptions);\r\n\r\n            if (!astSymbol) {\r\n              throw new Error(`Unsupported export ${JSON.stringify(exportedSymbol.name)} in `\r\n                + TypeScriptMessageFormatter.formatFileAndLineNumber(followedSymbol.declarations[0]));\r\n            }\r\n\r\n            astModule.cachedExportedSymbols.set(exportedSymbol.name, astSymbol);\r\n          }\r\n        }\r\n      } else {\r\n        // The module is part of the local project, so do the full analysis\r\n\r\n        if (moduleSymbol.exports) {\r\n          // The \"export * from 'module-name';\" declarations are all attached to a single virtual symbol\r\n          // whose name is InternalSymbolName.ExportStar\r\n          const exportStarSymbol: ts.Symbol | undefined = moduleSymbol.exports.get(ts.InternalSymbolName.ExportStar);\r\n          if (exportStarSymbol) {\r\n            for (const exportStarDeclaration of exportStarSymbol.getDeclarations() || []) {\r\n              if (ts.isExportDeclaration(exportStarDeclaration)) {\r\n\r\n                const starExportedModule: AstModule | undefined = this._fetchSpecifierAstModule(exportStarDeclaration,\r\n                  exportStarSymbol);\r\n\r\n                if (starExportedModule !== undefined) {\r\n                  astModule.starExportedModules.add(starExportedModule);\r\n                }\r\n              } else {\r\n                // Ignore ExportDeclaration nodes that don't match the expected pattern\r\n                // TODO: Should we report a warning?\r\n              }\r\n            }\r\n          }\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n    return astModule;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the symbol for the module corresponding to the ts.SourceFile that is being imported/exported.\r\n   */\r\n  private _getSymbolForSourceFile(sourceFile: ts.SourceFile,\r\n    moduleReference: IAstModuleReference | undefined): ts.Symbol {\r\n\r\n    const moduleSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(sourceFile);\r\n    if (moduleSymbol !== undefined) {\r\n      // This is the normal case.  The SourceFile acts is a module and has a symbol.\r\n      return moduleSymbol;\r\n    }\r\n\r\n    if (moduleReference !== undefined) {\r\n      // But there is also an elaborate case where the source file contains one or more \"module\" declarations,\r\n      // and our moduleReference took us to one of those.\r\n\r\n      // tslint:disable-next-line:no-bitwise\r\n      if ((moduleReference.moduleSpecifierSymbol.flags & ts.SymbolFlags.Alias) !== 0) {\r\n        // Follow the import/export declaration to one hop the exported item inside the target module\r\n        let followedSymbol: ts.Symbol | undefined = TypeScriptInternals.getImmediateAliasedSymbol(\r\n          moduleReference.moduleSpecifierSymbol, this._typeChecker);\r\n\r\n        if (followedSymbol === undefined) {\r\n          // This is a workaround for a compiler bug where getImmediateAliasedSymbol() sometimes returns undefined\r\n          followedSymbol = this._typeChecker.getAliasedSymbol(moduleReference.moduleSpecifierSymbol);\r\n        }\r\n\r\n        if (followedSymbol !== undefined && followedSymbol !== moduleReference.moduleSpecifierSymbol) {\r\n          // The parent of the exported symbol will be the module that we're importing from\r\n          const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(followedSymbol);\r\n          if (parent !== undefined) {\r\n            // Make sure the thing we found is a module\r\n            // tslint:disable-next-line:no-bitwise\r\n            if ((parent.flags & ts.SymbolFlags.ValueModule) !== 0) {\r\n              // Record that that this is an ambient module that can also be imported from\r\n              this._importableAmbientSourceFiles.add(sourceFile);\r\n              return parent;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    throw new InternalError('Unable to determine module for: ' + sourceFile.fileName);\r\n  }\r\n\r\n  /**\r\n   * This crawls the specified entry point and collects the full set of exported AstSymbols.\r\n   */\r\n  public fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo {\r\n    if (astModule.astModuleExportInfo === undefined) {\r\n      const astModuleExportInfo: AstModuleExportInfo = new AstModuleExportInfo();\r\n\r\n      this._collectAllExportsRecursive(astModuleExportInfo, astModule, new Set<AstModule>());\r\n\r\n      astModule.astModuleExportInfo = astModuleExportInfo;\r\n    }\r\n    return astModule.astModuleExportInfo;\r\n  }\r\n\r\n  /**\r\n   * Returns true if when we analyzed sourceFile, we found that it contains an \"export=\" statement that allows\r\n   * it to behave /either/ as an ambient module /or/ as a regular importable module.  In this case,\r\n   * `AstSymbolTable._fetchAstSymbol()` will analyze its symbols even though `TypeScriptHelpers.isAmbient()`\r\n   * returns true.\r\n   */\r\n  public isImportableAmbientSourceFile(sourceFile: ts.SourceFile): boolean {\r\n    return this._importableAmbientSourceFiles.has(sourceFile);\r\n  }\r\n\r\n  private _collectAllExportsRecursive(astModuleExportInfo: AstModuleExportInfo, astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>): void {\r\n\r\n    if (visitedAstModules.has(astModule)) {\r\n      return;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    if (astModule.isExternal) {\r\n      astModuleExportInfo.starExportedExternalModules.add(astModule);\r\n    } else {\r\n      // Fetch each of the explicit exports for this module\r\n      if (astModule.moduleSymbol.exports) {\r\n        astModule.moduleSymbol.exports.forEach((exportSymbol, exportName) => {\r\n          switch (exportName) {\r\n            case ts.InternalSymbolName.ExportStar:\r\n            case ts.InternalSymbolName.ExportEquals:\r\n              break;\r\n            default:\r\n              // Don't collect the \"export default\" symbol unless this is the entry point module\r\n              if (exportName !== ts.InternalSymbolName.Default || visitedAstModules.size === 1) {\r\n                if (!astModuleExportInfo.exportedLocalSymbols.has(exportSymbol.name)) {\r\n                  const astSymbol: AstSymbol = this._getExportOfAstModule(exportSymbol.name, astModule);\r\n                  this._astSymbolTable.analyze(astSymbol);\r\n                  astModuleExportInfo.exportedLocalSymbols.set(exportSymbol.name, astSymbol);\r\n                }\r\n              }\r\n              break;\r\n          }\r\n        });\r\n      }\r\n\r\n      for (const starExportedModule of astModule.starExportedModules) {\r\n        this._collectAllExportsRecursive(astModuleExportInfo, starExportedModule, visitedAstModules);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For a given symbol (which was encountered in the specified sourceFile), this fetches the AstSymbol that it\r\n   * refers to.  For example, if a particular interface describes the return value of a function, this API can help\r\n   * us determine a TSDoc declaration reference for that symbol (if the symbol is exported).\r\n   */\r\n  public fetchReferencedAstSymbol(symbol: ts.Symbol, sourceFile: ts.SourceFile): AstSymbol | undefined {\r\n    const astModule: AstModule | undefined = this._astModulesBySourceFile.get(sourceFile);\r\n    if (astModule === undefined) {\r\n      throw new InternalError('fetchReferencedAstSymbol() called for a source file that was not analyzed');\r\n    }\r\n\r\n    return this._fetchAstSymbolFromModule(astModule, symbol);\r\n  }\r\n\r\n  private _fetchAstSymbolFromModule(astModule: AstModule, symbol: ts.Symbol): AstSymbol | undefined {\r\n    let current: ts.Symbol = symbol;\r\n\r\n    while (true) { // tslint:disable-line:no-constant-condition\r\n\r\n      // Is this symbol an import/export that we need to follow to find the real declaration?\r\n      for (const declaration of current.declarations || []) {\r\n        let matchedAstSymbol: AstSymbol | undefined;\r\n        matchedAstSymbol = this._tryMatchExportDeclaration(declaration, current);\r\n        if (matchedAstSymbol !== undefined) {\r\n          return matchedAstSymbol;\r\n        }\r\n        matchedAstSymbol = this._tryMatchImportDeclaration(declaration, current);\r\n        if (matchedAstSymbol !== undefined) {\r\n          return matchedAstSymbol;\r\n        }\r\n      }\r\n\r\n      if (!(current.flags & ts.SymbolFlags.Alias)) { // tslint:disable-line:no-bitwise\r\n        break;\r\n      }\r\n\r\n      const currentAlias: ts.Symbol = TypeScriptInternals.getImmediateAliasedSymbol(current, this._typeChecker);\r\n      // Stop if we reach the end of the chain\r\n      if (!currentAlias || currentAlias === current) {\r\n        break;\r\n      }\r\n\r\n      current = currentAlias;\r\n    }\r\n\r\n    // Otherwise, assume it is a normal declaration\r\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol(current, true, undefined);\r\n    return astSymbol;\r\n  }\r\n\r\n  private _tryMatchExportDeclaration(declaration: ts.Declaration, declarationSymbol: ts.Symbol): AstSymbol | undefined {\r\n\r\n    const exportDeclaration: ts.ExportDeclaration | undefined\r\n      = TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\r\n\r\n    if (exportDeclaration) {\r\n      let exportName: string | undefined = undefined;\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"export { A } from './file-a';\"\r\n        //\r\n        // ExportDeclaration:\r\n        //   ExportKeyword:  pre=[export] sep=[ ]\r\n        //   NamedExports:\r\n        //     FirstPunctuation:  pre=[{] sep=[ ]\r\n        //     SyntaxList:\r\n        //       ExportSpecifier:  <------------- declaration\r\n        //         Identifier:  pre=[A] sep=[ ]\r\n        //     CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./file-a']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\r\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\r\n      } else {\r\n        throw new InternalError('Unimplemented export declaration kind: ' + declaration.getText());\r\n      }\r\n\r\n      // Ignore \"export { A }\" without a module specifier\r\n      if (exportDeclaration.moduleSpecifier) {\r\n        const specifierAstModule: AstModule = this._fetchSpecifierAstModule(exportDeclaration, declarationSymbol);\r\n        const astSymbol: AstSymbol = this._getExportOfAstModule(exportName, specifierAstModule);\r\n        return astSymbol;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _tryMatchImportDeclaration(declaration: ts.Declaration, declarationSymbol: ts.Symbol): AstSymbol | undefined {\r\n\r\n    const importDeclaration: ts.ImportDeclaration | undefined\r\n      = TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\r\n\r\n    if (importDeclaration) {\r\n      const specifierAstModule: AstModule = this._fetchSpecifierAstModule(importDeclaration, declarationSymbol);\r\n\r\n      if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\r\n        // EXAMPLE:\r\n        // \"import * as theLib from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamespaceImport:  <------------- declaration\r\n        //       AsteriskToken:  pre=[*] sep=[ ]\r\n        //       AsKeyword:  pre=[as] sep=[ ]\r\n        //       Identifier:  pre=[theLib] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        if (specifierAstModule.externalModulePath === undefined) {\r\n          // The implementation here only works when importing from an external module.\r\n          // The full solution is tracked by: https://github.com/Microsoft/web-build-tools/issues/1029\r\n          throw new Error('\"import * as ___ from ___;\" is not supported yet for local files.'\r\n            + '\\nFailure in: ' + importDeclaration.getSourceFile().fileName);\r\n        }\r\n\r\n        const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(declarationSymbol, this._typeChecker);\r\n\r\n        const astImportOptions: IAstImportOptions = {\r\n          exportName: '*',\r\n          modulePath: specifierAstModule.externalModulePath\r\n        };\r\n\r\n        const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol(followedSymbol, true,\r\n          astImportOptions, declarationSymbol.name);\r\n        return astSymbol;\r\n      }\r\n\r\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\r\n        // EXAMPLE:\r\n        // \"import { A, B } from 'the-lib';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:  <------------- declaration\r\n        //           Identifier:  pre=[A]\r\n        //         CommaToken:  pre=[,] sep=[ ]\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['the-lib']\r\n        //   SemicolonToken:  pre=[;]\r\n\r\n        // Example: \" ExportName as RenamedName\"\r\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\r\n        const exportName: string = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\r\n        const astSymbol: AstSymbol = this._getExportOfAstModule(exportName, specifierAstModule);\r\n        return astSymbol;\r\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\r\n        // EXAMPLE:\r\n        // \"import A, { B } from './A';\"\r\n        //\r\n        // ImportDeclaration:\r\n        //   ImportKeyword:  pre=[import] sep=[ ]\r\n        //   ImportClause:  <------------- declaration (referring to A)\r\n        //     Identifier:  pre=[A]\r\n        //     CommaToken:  pre=[,] sep=[ ]\r\n        //     NamedImports:\r\n        //       FirstPunctuation:  pre=[{] sep=[ ]\r\n        //       SyntaxList:\r\n        //         ImportSpecifier:\r\n        //           Identifier:  pre=[B] sep=[ ]\r\n        //       CloseBraceToken:  pre=[}] sep=[ ]\r\n        //   FromKeyword:  pre=[from] sep=[ ]\r\n        //   StringLiteral:  pre=['./A']\r\n        //   SemicolonToken:  pre=[;]\r\n        const astSymbol: AstSymbol = this._getExportOfAstModule(ts.InternalSymbolName.Default, specifierAstModule);\r\n        return astSymbol;\r\n      } else {\r\n        throw new InternalError('Unimplemented import declaration kind: ' + declaration.getText());\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  private _getExportOfAstModule(exportName: string, astModule: AstModule): AstSymbol {\r\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\r\n    const astSymbol: AstSymbol | undefined = this._tryGetExportOfAstModule(exportName, astModule, visitedAstModules);\r\n    if (astSymbol === undefined) {\r\n      throw new InternalError(`Unable to analyze the export ${JSON.stringify(exportName)} in\\n`\r\n        + astModule.sourceFile.fileName);\r\n    }\r\n    return astSymbol;\r\n  }\r\n\r\n  private _tryGetExportOfAstModule(exportName: string, astModule: AstModule,\r\n    visitedAstModules: Set<AstModule>): AstSymbol | undefined {\r\n\r\n    if (visitedAstModules.has(astModule)) {\r\n      return undefined;\r\n    }\r\n    visitedAstModules.add(astModule);\r\n\r\n    let astSymbol: AstSymbol | undefined = astModule.cachedExportedSymbols.get(exportName);\r\n    if (astSymbol !== undefined) {\r\n      return astSymbol;\r\n    }\r\n\r\n    // Try the explicit exports\r\n    const escapedExportName: ts.__String = ts.escapeLeadingUnderscores(exportName);\r\n    if (astModule.moduleSymbol.exports) {\r\n      const exportSymbol: ts.Symbol | undefined = astModule.moduleSymbol.exports.get(escapedExportName);\r\n      if (exportSymbol) {\r\n        astSymbol = this._fetchAstSymbolFromModule(astModule, exportSymbol);\r\n        if (astSymbol !== undefined) {\r\n          astModule.cachedExportedSymbols.set(exportName, astSymbol); // cache for next time\r\n          return astSymbol;\r\n        }\r\n      }\r\n    }\r\n\r\n    // Try each of the star imports\r\n    for (const starExportedModule of astModule.starExportedModules) {\r\n      astSymbol = this._tryGetExportOfAstModule(exportName, starExportedModule, visitedAstModules);\r\n      if (astSymbol !== undefined) {\r\n        return astSymbol;\r\n      }\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Given an ImportDeclaration of the form `export * from \"___\";`, this interprets the module specifier (`\"___\"`)\r\n   * and fetches the corresponding AstModule object.\r\n   */\r\n  private _fetchSpecifierAstModule(importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\r\n    exportStarSymbol: ts.Symbol): AstModule {\r\n\r\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\r\n    const moduleSpecifier: string | undefined = TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\r\n    if (!moduleSpecifier) {\r\n      throw new InternalError('Unable to parse module specifier');\r\n    }\r\n\r\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\r\n      importOrExportDeclaration.getSourceFile(), moduleSpecifier);\r\n\r\n    if (resolvedModule === undefined) {\r\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\r\n      // found in export declarations for this source file\r\n      throw new InternalError('getResolvedModule() could not resolve module name ' + JSON.stringify(moduleSpecifier));\r\n    }\r\n\r\n    // Map the filename back to the corresponding SourceFile. This circuitous approach is needed because\r\n    // we have no way to access the compiler's internal resolveExternalModuleName() function\r\n    const moduleSourceFile: ts.SourceFile | undefined = this._program.getSourceFile(resolvedModule.resolvedFileName);\r\n    if (!moduleSourceFile) {\r\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\r\n      // found in export declarations for this source file\r\n      throw new InternalError('getSourceFile() failed to locate ' + JSON.stringify(resolvedModule.resolvedFileName));\r\n    }\r\n\r\n    const specifierAstModule: AstModule = this.fetchAstModuleBySourceFile(moduleSourceFile, {\r\n      moduleSpecifier: moduleSpecifier,\r\n      moduleSpecifierSymbol: exportStarSymbol\r\n    });\r\n\r\n    return specifierAstModule;\r\n  }\r\n}\r\n"]}