{"version":3,"file":"AstSymbolTable.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbolTable.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { PackageJsonLookup, InternalError } from '@microsoft/node-core-library';\r\n\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\r\nimport { AstSymbol } from './AstSymbol';\r\nimport { AstImport, IAstImportOptions } from './AstImport';\r\nimport { AstModule, AstModuleExportInfo } from './AstModule';\r\nimport { PackageMetadataManager } from './PackageMetadataManager';\r\nimport { ILogger } from '../api/ILogger';\r\nimport { ExportAnalyzer } from './ExportAnalyzer';\r\n\r\n/**\r\n * AstSymbolTable is the workhorse that builds AstSymbol and AstDeclaration objects.\r\n * It maintains a cache of already constructed objects.  AstSymbolTable constructs\r\n * AstModule objects, but otherwise the state that it maintains  is agnostic of\r\n * any particular entry point.  (For example, it does not track whether a given AstSymbol\r\n * is \"exported\" or not.)\r\n *\r\n * Internally, AstSymbolTable relies on ExportAnalyzer to crawl import statements and determine where symbols\r\n * are declared (i.e. the AstImport information needed to import them).\r\n */\r\nexport class AstSymbolTable {\r\n  private readonly _program: ts.Program;\r\n  private readonly _typeChecker: ts.TypeChecker;\r\n  private readonly _packageMetadataManager: PackageMetadataManager;\r\n  private readonly _exportAnalyzer: ExportAnalyzer;\r\n\r\n  /**\r\n   * A mapping from ts.Symbol --> AstSymbol\r\n   * NOTE: The AstSymbol.followedSymbol will always be a lookup key, but additional keys\r\n   * are possible.\r\n   *\r\n   * After following type aliases, we use this map to look up the corresponding AstSymbol.\r\n   */\r\n  private readonly _astSymbolsBySymbol: Map<ts.Symbol, AstSymbol> = new Map<ts.Symbol, AstSymbol>();\r\n\r\n  /**\r\n   * A mapping from ts.Declaration --> AstDeclaration\r\n   */\r\n  private readonly _astDeclarationsByDeclaration: Map<ts.Node, AstDeclaration>\r\n    = new Map<ts.Node, AstDeclaration>();\r\n\r\n  /**\r\n   * A mapping from AstImport.key --> AstSymbol.\r\n   *\r\n   * If AstSymbol.astImport is undefined, then it is not included in the map.\r\n   */\r\n  private readonly _astSymbolsByImportKey: Map<string, AstSymbol> = new Map<string, AstSymbol>();\r\n\r\n  public constructor(program: ts.Program, typeChecker: ts.TypeChecker, packageJsonLookup: PackageJsonLookup,\r\n    logger: ILogger) {\r\n\r\n    this._program = program;\r\n    this._typeChecker = typeChecker;\r\n    this._packageMetadataManager = new PackageMetadataManager(packageJsonLookup, logger);\r\n\r\n    this._exportAnalyzer = new ExportAnalyzer(\r\n      this._program,\r\n      this._typeChecker,\r\n      {\r\n        analyze: this.analyze.bind(this),\r\n        fetchAstSymbol: this._fetchAstSymbol.bind(this)\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * For a given source file, this analyzes all of its exports and produces an AstModule\r\n   * object.\r\n   */\r\n  public fetchEntryPointModule(sourceFile: ts.SourceFile): AstModule {\r\n    return this._exportAnalyzer.fetchAstModuleBySourceFile(sourceFile, undefined);\r\n  }\r\n\r\n  public fetchAstModuleExportInfo(astModule: AstModule): AstModuleExportInfo {\r\n    return this._exportAnalyzer.fetchAstModuleExportInfo(astModule);\r\n  }\r\n\r\n  public fetchReferencedAstSymbol(symbol: ts.Symbol, sourceFile: ts.SourceFile): AstSymbol | undefined {\r\n    return this._exportAnalyzer.fetchReferencedAstSymbol(symbol, sourceFile);\r\n  }\r\n\r\n  /**\r\n   * Ensures that AstSymbol.analyzed is true for the provided symbol.  The operation\r\n   * starts from the root symbol and then fills out all children of all declarations, and\r\n   * also calculates AstDeclaration.referencedAstSymbols for all declarations.\r\n   * If the symbol is not imported, any non-imported references are also analyzed.\r\n   *\r\n   * @remarks\r\n   * This is an expensive operation, so we only perform it for top-level exports of an\r\n   * the AstModule.  For example, if some code references a nested class inside\r\n   * a namespace from another library, we do not analyze any of that class's siblings\r\n   * or members.  (We do always construct its parents however, since AstDefinition.parent\r\n   * is immutable, and needed e.g. to calculate release tag inheritance.)\r\n   */\r\n  public analyze(astSymbol: AstSymbol): void {\r\n    if (astSymbol.analyzed) {\r\n      return;\r\n    }\r\n\r\n    if (astSymbol.nominalAnalysis) {\r\n      // We don't analyze nominal symbols\r\n      astSymbol._notifyAnalyzed();\r\n      return;\r\n    }\r\n\r\n    // Start at the root of the tree\r\n    const rootAstSymbol: AstSymbol = astSymbol.rootAstSymbol;\r\n\r\n    // Calculate the full child tree for each definition\r\n    for (const astDeclaration of rootAstSymbol.astDeclarations) {\r\n      this._analyzeChildTree(astDeclaration.declaration, astDeclaration);\r\n    }\r\n\r\n    rootAstSymbol._notifyAnalyzed();\r\n\r\n    if (!astSymbol.astImport) {\r\n      // If this symbol is not imported, then we also analyze any referencedAstSymbols\r\n      // that are not imported.  For example, this ensures that forgotten exports get\r\n      // analyzed.\r\n      rootAstSymbol.forEachDeclarationRecursive((astDeclaration: AstDeclaration) => {\r\n        for (const referencedAstSymbol of astDeclaration.referencedAstSymbols) {\r\n          // Walk up to the root of the tree, looking for any imports along the way\r\n          if (!referencedAstSymbol.imported) {\r\n            this.analyze(referencedAstSymbol);\r\n          }\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Looks up the AstSymbol corresponding to the given ts.Symbol.\r\n   * This will not analyze or construct any new AstSymbol objects.\r\n   */\r\n  public tryGetAstSymbol(symbol: ts.Symbol): AstSymbol | undefined {\r\n    return this._fetchAstSymbol(symbol, false, undefined);\r\n  }\r\n\r\n  /**\r\n   * For a given astDeclaration, this efficiently finds the child corresponding to the\r\n   * specified ts.Node.  It is assumed that isAstDeclaration() would return true for\r\n   * that node type, and that the node is an immediate child of the provided AstDeclaration.\r\n   */\r\n  // NOTE: This could be a method of AstSymbol if it had a backpointer to its AstSymbolTable.\r\n  public getChildAstDeclarationByNode(node: ts.Node, parentAstDeclaration: AstDeclaration): AstDeclaration {\r\n    if (!parentAstDeclaration.astSymbol.analyzed) {\r\n      throw new Error('getChildDeclarationByNode() cannot be used for an AstSymbol that was not analyzed');\r\n    }\r\n\r\n    const childAstDeclaration: AstDeclaration | undefined = this._astDeclarationsByDeclaration.get(node);\r\n    if (!childAstDeclaration) {\r\n      throw new Error('Child declaration not found for the specified node');\r\n    }\r\n    if (childAstDeclaration.parent !== parentAstDeclaration) {\r\n      throw new InternalError('The found child is not attached to the parent AstDeclaration');\r\n    }\r\n\r\n    return childAstDeclaration;\r\n  }\r\n\r\n  /**\r\n   * Used by analyze to recursively analyze the entire child tree.\r\n   */\r\n  private _analyzeChildTree(node: ts.Node, governingAstDeclaration: AstDeclaration): void {\r\n    switch (node.kind) {\r\n      case ts.SyntaxKind.JSDocComment: // Skip JSDoc comments - TS considers @param tags TypeReference nodes\r\n        return;\r\n\r\n      // is this a reference to another AstSymbol?\r\n      case ts.SyntaxKind.TypeReference: // general type references\r\n      case ts.SyntaxKind.ExpressionWithTypeArguments: // special case for e.g. the \"extends\" keyword\r\n      case ts.SyntaxKind.ComputedPropertyName:  // used for EcmaScript \"symbols\", e.g. \"[toPrimitive]\".\r\n        {\r\n          // Sometimes the type reference will involve multiple identifiers, e.g. \"a.b.C\".\r\n          // In this case, we only need to worry about importing the first identifier,\r\n          // so do a depth-first search for it:\r\n          const symbolNode: ts.Node | undefined = TypeScriptHelpers.findFirstChildNode(\r\n            node, ts.SyntaxKind.Identifier);\r\n\r\n          if (!symbolNode) {\r\n            break;\r\n          }\r\n\r\n          const symbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(symbolNode);\r\n          if (!symbol) {\r\n            throw new Error('Symbol not found for identifier: ' + symbolNode.getText());\r\n          }\r\n\r\n          const referencedAstSymbol: AstSymbol | undefined\r\n            = this.fetchReferencedAstSymbol(symbol, symbolNode.getSourceFile());\r\n          if (referencedAstSymbol) {\r\n            governingAstDeclaration._notifyReferencedAstSymbol(referencedAstSymbol);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n\r\n    // Is this node declaring a new AstSymbol?\r\n    const newGoverningAstDeclaration: AstDeclaration | undefined = this._fetchAstDeclaration(node);\r\n\r\n    for (const childNode of node.getChildren()) {\r\n      this._analyzeChildTree(childNode, newGoverningAstDeclaration || governingAstDeclaration);\r\n    }\r\n  }\r\n\r\n  // tslint:disable-next-line:no-unused-variable\r\n  private _fetchAstDeclaration(node: ts.Node): AstDeclaration | undefined {\r\n    const astSymbol: AstSymbol | undefined = this._fetchAstSymbolForNode(node);\r\n    if (!astSymbol) {\r\n      return undefined;\r\n    }\r\n\r\n    const astDeclaration: AstDeclaration | undefined\r\n      = this._astDeclarationsByDeclaration.get(node);\r\n    if (!astDeclaration) {\r\n      throw new InternalError('Unable to find constructed AstDeclaration');\r\n    }\r\n\r\n    return astDeclaration;\r\n  }\r\n\r\n  private _fetchAstSymbolForNode(node: ts.Node): AstSymbol | undefined {\r\n    if (!AstDeclaration.isSupportedSyntaxKind(node.kind)) {\r\n      return undefined;\r\n    }\r\n\r\n    const symbol: ts.Symbol | undefined = TypeScriptHelpers.getSymbolForDeclaration(node as ts.Declaration);\r\n    if (!symbol) {\r\n      throw new InternalError('Unable to find symbol for node');\r\n    }\r\n\r\n    return this._fetchAstSymbol(symbol, true, undefined);\r\n  }\r\n\r\n  private _fetchAstSymbol(followedSymbol: ts.Symbol, addIfMissing: boolean,\r\n    astImportOptions: IAstImportOptions | undefined, localName?: string): AstSymbol | undefined {\r\n\r\n    // Filter out symbols representing constructs that we don't care about\r\n    // tslint:disable-next-line:no-bitwise\r\n    if (followedSymbol.flags & (ts.SymbolFlags.TypeParameter | ts.SymbolFlags.TypeLiteral | ts.SymbolFlags.Transient)) {\r\n      return undefined;\r\n    }\r\n\r\n    // API Extractor doesn't analyze ambient declarations at all\r\n    if (TypeScriptHelpers.isAmbient(followedSymbol, this._typeChecker)) {\r\n      if (TypeScriptHelpers.hasAnyDeclarations(followedSymbol)\r\n        && this._exportAnalyzer.isImportableAmbientSourceFile(followedSymbol.declarations[0].getSourceFile())) {\r\n        // We make a special exemption for ambient declarations that appear in a source file containing\r\n        // an \"export=\" declaration that allows them to be imported as non-ambient.\r\n      } else {\r\n        // Ignore ambient declarations\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    let astSymbol: AstSymbol | undefined = this._astSymbolsBySymbol.get(followedSymbol);\r\n\r\n    if (!astSymbol) {\r\n      if (!followedSymbol.declarations || followedSymbol.declarations.length < 1) {\r\n        throw new InternalError('Followed a symbol with no declarations');\r\n      }\r\n\r\n      const astImport: AstImport | undefined = astImportOptions ? new AstImport(astImportOptions) : undefined;\r\n\r\n      if (astImport) {\r\n        if (!astSymbol) {\r\n          astSymbol = this._astSymbolsByImportKey.get(astImport.key);\r\n          if (astSymbol) {\r\n            // We didn't find the entry using followedSymbol, but we did using importPackageKey,\r\n            // so add a mapping for followedSymbol; we'll need it later when renaming identifiers\r\n            this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (!astSymbol) {\r\n        // None of the above lookups worked, so create a new entry...\r\n        let nominalAnalysis: boolean = false;\r\n\r\n        // NOTE: In certain circumstances we need an AstSymbol for a source file that is acting\r\n        // as a TypeScript module.  For example, one of the unit tests has this line:\r\n        //\r\n        //   import * as semver1 from 'semver';\r\n        //\r\n        // To handle the expression \"semver1.SemVer\", we need \"semver1\" to map to an AstSymbol\r\n        // that causes us to emit the above import.  However we do NOT want it to act as the root\r\n        // of a declaration tree, because in general the *.d.ts generator is trying to roll up\r\n        // definitions and eliminate source files.  So, even though isAstDeclaration() would return\r\n        // false, we do create an AstDeclaration for a ts.SyntaxKind.SourceFile in this special edge case.\r\n        if (followedSymbol.declarations.length === 1\r\n          && followedSymbol.declarations[0].kind === ts.SyntaxKind.SourceFile) {\r\n          nominalAnalysis = true;\r\n        }\r\n\r\n        // If the file is from a package that does not support AEDoc, then we process the\r\n        // symbol itself, but we don't attempt to process any parent/children of it.\r\n        const followedSymbolSourceFile: ts.SourceFile = followedSymbol.declarations[0].getSourceFile();\r\n        if (astImport !== undefined) {\r\n          if (!this._packageMetadataManager.isAedocSupportedFor(followedSymbolSourceFile.fileName)) {\r\n            nominalAnalysis = true;\r\n          }\r\n        }\r\n\r\n        let parentAstSymbol: AstSymbol | undefined = undefined;\r\n\r\n        if (!nominalAnalysis) {\r\n          for (const declaration of followedSymbol.declarations || []) {\r\n            if (!AstDeclaration.isSupportedSyntaxKind(declaration.kind)) {\r\n              throw new InternalError(`The \"${followedSymbol.name}\" symbol uses the construct`\r\n                + ` \"${ts.SyntaxKind[declaration.kind]}\" which may be an unimplemented language feature`);\r\n            }\r\n          }\r\n\r\n          // We always fetch the entire chain of parents for each declaration.\r\n          // (Children/siblings are only analyzed on demand.)\r\n\r\n          // Key assumptions behind this squirrely logic:\r\n          //\r\n          // IF a given symbol has two declarations D1 and D2; AND\r\n          // If D1 has a parent P1, then\r\n          // - D2 will also have a parent P2; AND\r\n          // - P1 and P2's symbol will be the same\r\n          // - but P1 and P2 may be different (e.g. merged namespaces containing merged interfaces)\r\n\r\n          // Is there a parent AstSymbol?  First we check to see if there is a parent declaration:\r\n          const arbitaryParentDeclaration: ts.Node | undefined\r\n            = this._tryFindFirstAstDeclarationParent(followedSymbol.declarations[0]);\r\n\r\n          if (arbitaryParentDeclaration) {\r\n            const parentSymbol: ts.Symbol = TypeScriptHelpers.getSymbolForDeclaration(\r\n              arbitaryParentDeclaration as ts.Declaration);\r\n\r\n            parentAstSymbol = this._fetchAstSymbol(parentSymbol, addIfMissing, undefined);\r\n            if (!parentAstSymbol) {\r\n              throw new InternalError('Unable to construct a parent AstSymbol for '\r\n                + followedSymbol.name);\r\n            }\r\n          }\r\n        }\r\n\r\n        if (localName === undefined) {\r\n          // We will try to obtain the name from a declaration; otherwise we'll fall back to the symbol name\r\n          // This handles cases such as \"export default class X { }\" where the symbol name is \"default\"\r\n          // but the declaration name is \"X\".\r\n          localName = followedSymbol.name;\r\n          for (const declaration of followedSymbol.declarations || []) {\r\n            const declarationNameIdentifier: ts.DeclarationName | undefined = ts.getNameOfDeclaration(declaration);\r\n            if (declarationNameIdentifier && ts.isIdentifier(declarationNameIdentifier)) {\r\n              localName = declarationNameIdentifier.getText().trim();\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        astSymbol = new AstSymbol({\r\n          localName: localName,\r\n          followedSymbol: followedSymbol,\r\n          astImport: astImport,\r\n          parentAstSymbol: parentAstSymbol,\r\n          rootAstSymbol: parentAstSymbol ? parentAstSymbol.rootAstSymbol : undefined,\r\n          nominalAnalysis: nominalAnalysis\r\n        });\r\n\r\n        this._astSymbolsBySymbol.set(followedSymbol, astSymbol);\r\n\r\n        if (astImport) {\r\n          // If it's an import, add it to the lookup\r\n          this._astSymbolsByImportKey.set(astImport.key, astSymbol);\r\n        }\r\n\r\n        // Okay, now while creating the declarations we will wire them up to the\r\n        // their corresponding parent declarations\r\n        for (const declaration of followedSymbol.declarations || []) {\r\n\r\n          let parentAstDeclaration: AstDeclaration | undefined = undefined;\r\n          if (parentAstSymbol) {\r\n            const parentDeclaration: ts.Node | undefined = this._tryFindFirstAstDeclarationParent(declaration);\r\n\r\n            if (!parentDeclaration) {\r\n              throw new InternalError('Missing parent declaration');\r\n            }\r\n\r\n            parentAstDeclaration = this._astDeclarationsByDeclaration.get(parentDeclaration);\r\n            if (!parentAstDeclaration) {\r\n              throw new InternalError('Missing parent AstDeclaration');\r\n            }\r\n          }\r\n\r\n          const astDeclaration: AstDeclaration = new AstDeclaration({\r\n            declaration, astSymbol, parent: parentAstDeclaration});\r\n\r\n          this._astDeclarationsByDeclaration.set(declaration, astDeclaration);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (astImportOptions && !astSymbol.imported) {\r\n      // Our strategy for recognizing external declarations is to look for an import statement\r\n      // during SymbolAnalyzer.followAliases().  Although it is sometimes possible to reach a symbol\r\n      // without traversing an import statement, we assume that that the first reference will always\r\n      // involve an import statement.\r\n      //\r\n      // This assumption might be violated if the caller did something unusual like feeding random\r\n      // symbols to AstSymbolTable.analyze() in the middle of the analysis.\r\n      throw new InternalError('The symbol ' + astSymbol.localName + ' is being imported'\r\n        + ' after it was already registered as non-imported');\r\n    }\r\n\r\n    return astSymbol;\r\n  }\r\n\r\n  /**\r\n   * Returns the first parent satisfying isAstDeclaration(), or undefined if none is found.\r\n   */\r\n  private _tryFindFirstAstDeclarationParent(node: ts.Node): ts.Node | undefined {\r\n    let currentNode: ts.Node | undefined = node.parent;\r\n    while (currentNode) {\r\n      if (AstDeclaration.isSupportedSyntaxKind(currentNode.kind)) {\r\n        return currentNode;\r\n      }\r\n      currentNode = currentNode.parent;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n"]}