{"version":3,"file":"AstSymbol.js","sourceRoot":"","sources":["../../src/analyzer/AstSymbol.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAK3D,oEAA6D;AAc7D;;;;;;;;;;;GAWG;AACH,MAAa,SAAS;IA0DpB,YAAmB,OAA0B;QAJ7C,sDAAsD;QACtD,qDAAqD;QAC7C,cAAS,GAAY,KAAK,CAAC;QAGjC,IAAI,CAAC,cAAc,GAAG,OAAO,CAAC,cAAc,CAAC;QAC7C,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;QACnC,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,eAAe,GAAG,OAAO,CAAC,eAAe,CAAC;QAC/C,IAAI,CAAC,aAAa,GAAG,OAAO,CAAC,aAAa,IAAI,IAAI,CAAC;QACnD,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;IAC7B,CAAC;IAED;;;;;OAKG;IACH,IAAW,eAAe;QACxB,OAAO,IAAI,CAAC,gBAAgB,CAAC;IAC/B,CAAC;IAED;;;;;;OAMG;IACH,IAAW,QAAQ;QACjB,OAAO,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACtC,CAAC;IAED;;OAEG;IACH,IAAW,QAAQ;QACjB,OAAO,CAAC,CAAC,IAAI,CAAC,aAAa,CAAC,SAAS,CAAC;IACxC,CAAC;IAED;;;;OAIG;IACI,wBAAwB,CAAC,cAA8B;QAC5D,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,MAAM,IAAI,iCAAa,CAAC,sEAAsE,CAAC,CAAC;SACjG;QACD,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;IAC7C,CAAC;IAED;;;;OAIG;IACI,eAAe;QACpB,IAAI,IAAI,CAAC,eAAe,EAAE;YACxB,MAAM,IAAI,iCAAa,CAAC,iEAAiE,CAAC,CAAC;SAC5F;QACD,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC;IACxB,CAAC;IAED;;OAEG;IACI,2BAA2B,CAAC,MAAgD;QACjF,KAAK,MAAM,cAAc,IAAI,IAAI,CAAC,eAAe,EAAE;YACjD,cAAc,CAAC,2BAA2B,CAAC,MAAM,CAAC,CAAC;SACpD;IACH,CAAC;CACF;AAhID,8BAgIC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as ts from 'typescript';\r\nimport { AstImport } from './AstImport';\r\nimport { AstDeclaration } from './AstDeclaration';\r\nimport { InternalError } from '@microsoft/node-core-library';\r\n\r\n/**\r\n * Constructor options for AstSymbol\r\n */\r\nexport interface IAstSymbolOptions {\r\n  readonly followedSymbol: ts.Symbol;\r\n  readonly localName: string;\r\n  readonly astImport: AstImport | undefined;\r\n  readonly nominalAnalysis: boolean;\r\n  readonly parentAstSymbol: AstSymbol | undefined;\r\n  readonly rootAstSymbol: AstSymbol | undefined;\r\n}\r\n\r\n/**\r\n * The AstDeclaration and AstSymbol classes are API Extractor's equivalent of the compiler's\r\n * ts.Declaration and ts.Symbol objects.  They are created by the SymbolTable class.\r\n *\r\n * @remarks\r\n * The AstSymbol represents the ts.Symbol information for an AstDeclaration.  For example,\r\n * if a method has 3 overloads, each overloaded signature will have its own AstDeclaration,\r\n * but they will all share a common AstSymbol.\r\n *\r\n * For nested definitions, the AstSymbol has a unique parent (i.e. AstSymbol.rootAstSymbol),\r\n * but the parent/children for each AstDeclaration may be different.\r\n */\r\nexport class AstSymbol {\r\n  /**\r\n   * The original name of the symbol, as exported from the module (i.e. source file)\r\n   * containing the original TypeScript definition.\r\n   */\r\n  public readonly localName: string;\r\n\r\n  /**\r\n   * The compiler symbol where this type was defined, after following any aliases.\r\n   */\r\n  public readonly followedSymbol: ts.Symbol;\r\n\r\n  /**\r\n   * If this symbol was imported from another package, that information is tracked here.\r\n   * Otherwise, the value is undefined.  For example, if this symbol was defined in the referencing source file,\r\n   * or if it was imported from a local file in the current project, or if it is an ambient definition,\r\n   * then astImport will be undefined.\r\n   */\r\n  public readonly astImport: AstImport | undefined;\r\n\r\n  /**\r\n   * If true, then this AstSymbol represents a foreign object whose structure will be\r\n   * ignored.  The AstDeclaration will not have any parent or children, and its references\r\n   * will not be analyzed.\r\n   *\r\n   * Nominal symbols are tracked because we still need to emit exports for them.\r\n   */\r\n  public readonly nominalAnalysis: boolean;\r\n\r\n  /**\r\n   * Returns the symbol of the parent of this AstSymbol, or undefined if there is no parent.\r\n   * @remarks\r\n   * If a symbol has multiple declarations, we assume (as an axiom) that their parent\r\n   * declarations will belong to the same symbol.  This means that the \"parent\" of a\r\n   * symbol is a well-defined concept.  However, the \"children\" of a symbol are not very\r\n   * meaningful, because different declarations may have different nested members,\r\n   * so we usually need to traverse declarations to find children.\r\n   */\r\n  public readonly parentAstSymbol: AstSymbol | undefined;\r\n\r\n  /**\r\n   * Returns the symbol of the root of the AstDeclaration hierarchy.\r\n   * @remarks\r\n   * NOTE: If this AstSymbol is the root, then rootAstSymbol will point to itself.\r\n   */\r\n  public readonly rootAstSymbol: AstSymbol;\r\n\r\n  /**\r\n   * Additional information applied later by the Collector.\r\n   */\r\n  public metadata: unknown;\r\n\r\n  private readonly _astDeclarations: AstDeclaration[];\r\n\r\n  // This flag is unused if this is not the root symbol.\r\n  // Being \"analyzed\" is a property of the root symbol.\r\n  private _analyzed: boolean = false;\r\n\r\n  public constructor(options: IAstSymbolOptions) {\r\n    this.followedSymbol = options.followedSymbol;\r\n    this.localName = options.localName;\r\n    this.astImport = options.astImport;\r\n    this.nominalAnalysis = options.nominalAnalysis;\r\n    this.parentAstSymbol = options.parentAstSymbol;\r\n    this.rootAstSymbol = options.rootAstSymbol || this;\r\n    this._astDeclarations = [];\r\n  }\r\n\r\n  /**\r\n   * The one or more declarations for this symbol.\r\n   * For example, if this symbol is a method, then the declarations could be\r\n   * various method overloads.  If this symbol is a namespace, then the declarations\r\n   * might be separate namespace blocks (with the same name).\r\n   */\r\n  public get astDeclarations(): ReadonlyArray<AstDeclaration> {\r\n    return this._astDeclarations;\r\n  }\r\n\r\n  /**\r\n   * Returns true if the AstSymbolTable.analyze() was called for this object.\r\n   * See that function for details.\r\n   * @remarks\r\n   * AstSymbolTable.analyze() is always performed on the root AstSymbol.  This function\r\n   * returns true if-and-only-if the root symbol was analyzed.\r\n   */\r\n  public get analyzed(): boolean {\r\n    return this.rootAstSymbol._analyzed;\r\n  }\r\n\r\n  /**\r\n   * Returns true if this symbol was imported from another package.\r\n   */\r\n  public get imported(): boolean {\r\n    return !!this.rootAstSymbol.astImport;\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the SymbolTable attaches a new\r\n   * AstDeclaration to this object.\r\n   * @internal\r\n   */\r\n  public _notifyDeclarationAttach(astDeclaration: AstDeclaration): void {\r\n    if (this.analyzed) {\r\n      throw new InternalError('_notifyDeclarationAttach() called after analysis is already complete');\r\n    }\r\n    this._astDeclarations.push(astDeclaration);\r\n  }\r\n\r\n  /**\r\n   * This is an internal callback used when the SymbolTable.analyze()\r\n   * has processed this object.\r\n   * @internal\r\n   */\r\n  public _notifyAnalyzed(): void {\r\n    if (this.parentAstSymbol) {\r\n      throw new InternalError('_notifyAnalyzed() called for an AstSymbol which is not the root');\r\n    }\r\n    this._analyzed = true;\r\n  }\r\n\r\n  /**\r\n   * Helper that calls AstDeclaration.forEachDeclarationRecursive() for each AstDeclaration.\r\n   */\r\n  public forEachDeclarationRecursive(action: (astDeclaration: AstDeclaration) => void): void {\r\n    for (const astDeclaration of this.astDeclarations) {\r\n      astDeclaration.forEachDeclarationRecursive(action);\r\n    }\r\n  }\r\n}\r\n"]}