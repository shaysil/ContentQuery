/**
 * The SharePoint Framework loader
 *
 * @remarks
 * Built on familiar standards such as SystemJS and WebPack,
 * the loader is the first part of the SharePoint Framework to load on a page.
 * It manages versioning and loading of client-side components, web parts,
 * and other assets.  It also implements the developer dashboard.
 *
 * @packagedocumentation
 */

import { IBrowserCompatibility } from '@microsoft/sp-core-library';
import { IClientSideComponentManifest } from '@microsoft/sp-module-interfaces';
import { IODataBasePermission } from '@microsoft/sp-odata-types';
import { IODataContextWebInformation } from '@microsoft/sp-odata-types';
import { IODataList } from '@microsoft/sp-odata-types';
import { IODataListItem } from '@microsoft/sp-odata-types';
import { IODataNavigationNodeCollection } from '@microsoft/sp-odata-types';
import { _IODataPageContextInfo } from '@microsoft/sp-odata-types';
import { IODataUser } from '@microsoft/sp-odata-types';
import { IODataWeb } from '@microsoft/sp-odata-types';
import * as React from 'react';
import { ServiceScope } from '@microsoft/sp-core-library';

/**
 * Developer tools.
 * Allows to register tabs in the developer tools.
 *
 * @alpha
 */
export declare class DeveloperTools {
    private static _instance;
    /**
     * Initializes the developer tools with an implementation.
     * Must be called once before it can be used.
     */
    static initialize(developerToolsLoader: IDeveloperTools): void;
    /**
     * {@inheritDoc  IDeveloperTools.registerDeveloperToolsTab}
     */
    static registerDeveloperToolsTab(developerToolsTab: IDeveloperToolsTab): void;
}

declare interface IComponentInitializer {
    (resolve: (component: React.ComponentClass<IDeveloperToolsCompPropBase>) => void, reject: (error: Error) => void): void;
}

/**
 * Data required to start SPFx in debug mode. It includes the debug loader object and the debug manifests, when
 * applicable.
 *
 * @internal
 */
export declare interface _IDebugData {
    /**
     * The debug loader object. When a debug loader is loaded, this is its SPStarter
     */
    debugLoader: typeof _SPStarter | undefined;
    /**
     * The debug manifests.
     */
    debugManifests: IClientSideComponentManifest[] | undefined;
    /**
     * If debug manifests should be registered as non-debug manifests.
     */
    registerAsNonDebug: boolean;
}

/**
 * Developer Tools interface.
 * It allows to register tabs in the developer tools.
 *
 * @alpha
 */
export declare interface IDeveloperTools {
    /**
     * Registers a tab in the developer tools.
     *
     * @param developerToolsTab - The tab definition.
     */
    registerDeveloperToolsTab(developerToolsTab: IDeveloperToolsTab): void;
    /**
     * Initializes the developer tools.
     */
    initialize(): void;
}

declare interface IDeveloperToolsCompPropBase {
}

/**
 * Initializer for a developer tools tab.
 *
 * @internal
 */
export declare type IDeveloperToolsTab = IDeveloperToolsTabPromiseParameters | IDeveloperToolsTabComponentParameters;

declare interface IDeveloperToolsTabComponentParameters extends IDeveloperToolsTabParametersBase {
    /**
     * A react component to be shown in the developer tools panel.
     */
    component: React.ComponentClass<IDeveloperToolsCompPropBase>;
}

declare interface IDeveloperToolsTabParametersBase {
    /**
     * The title of the developer tools tab. Shown along the top of the developer tools panel.
     */
    title: string;
}

declare interface IDeveloperToolsTabPromiseParameters extends IDeveloperToolsTabParametersBase {
    /**
     * A function that resolves to a React component to be shown in the developer tools panel or rejects with an error.
     */
    componentInitializer: IComponentInitializer;
}

/**
 * Provides information about a loader error.
 * Used with handleError() in order to present UI friendly error information.
 * @internal
 */
export declare interface _IErrorInformation {
    /**
     * User friendly message for the error.
     * It should not include technical details, but a way for the user to work around the problem.
     * An example of that: "Please refresh the page" or "Please update your browser to the last version"
     */
    message: string;
    /**
     * Original error.
     */
    error?: Error;
    /**
     * Correlation id
     */
    correlationId?: string;
    /**
     * Operation that failed. This is used by our diagnostics.
     */
    operationName?: string;
}

/**
 * Options for the loadScript() method in ISPComponentLoader
 *
 * @public
 */
export declare interface ILoadScriptOptions {
    /**
     * If set, the loaded script will be stored in a global variable under this name.
     */
    globalExportsName?: string;
}

/**
 * @internal
 */
export declare interface _IManifestStoreEntry {
    /**
     * The component id.
     */
    id: string;
    /**
     * The component version.
     */
    version: string;
    /**
     * The manifest V2 payload.
     */
    manifest?: IClientSideComponentManifest;
    /**
     * A debug manifest V2 payload, if one has been provided.
     */
    debugManifest?: IClientSideComponentManifest;
}

/**
 * Represents the preloaded custom action object.
 *
 * @remarks
 *
 * For more details, see:
 *
 * {@link https://msdn.microsoft.com/en-us/library/office/ms460194.aspx}
 *
 * {@link https://msdn.microsoft.com/en-us/library/office/dn531432.aspx#bk_UserCustomAction}
 *
 * @internal
 */
export declare interface _IPreloadedCustomAction {
    /**
     * Title of the custom action.
     *
     * @remarks
     *
     * Example: `"Custom Header"`
     */
    title?: string;
    /**
     * Location of the custom action.
     *
     * @remarks
     *
     * The location provides information about where the custom action is applied. All client-side custom actions
     * start with the prefix `ClientSideExtension`.
     *
     * Application customizers, like headers and footers have the location `"ClientSideExtension.ApplicationCustomizer"`.
     * ListView context menu custom actions have the location `"ClientSideExtension.ListViewCommandSet.ContextMenu"`.
     * ListView command bar custom actions have the location `"ClientSideExtension.ListViewCommandSet.CommandBar"`.
     * ListView custom actions that apply to all locations in the `ListViewCommandSet` use
     * `"ClientSideExtension.ListViewCommandSet"`. It is up to the application whether to apply that custom action
     * in all the locations, e.g., an application may not have context menu or equivalent.
     *
     * Example: `"ClientSideExtension.ApplicationCustomizer"`
     */
    location: string;
    /**
     * Identifies the client-side component to be loaded for this custom action.
     *
     * @remarks
     *
     * Type: GUID string
     *
     * Example: `"dbef608d-3ad5-4f8f-b139-d916f2f0a294"`
     */
    clientSideComponentId: string;
    /**
     * JSON string representing the properties of the custom action.
     *
     * @remarks
     *
     * Example: `{ "backgroundColor": "blue", "text": "All documents in this library are readonly" }"`
     */
    clientSideComponentProperties?: string;
    /**
     * Specifies the registration attachment for a per-item action.
     *
     * @remarks
     *
     * Possible values include: None, List, ContentType, ProgId, FileType
     *
     * Example: `"List"`
     */
    registrationType?: string;
    /**
     * Specifies the identifier of the list or item content type that this action
     * is associated with, or the file type or programmatic identifier (ProgID).
     *
     * @remarks
     * Example: `"101"`
     */
    registrationId?: string;
    /**
     * Definition: specifies the ordering priority for actions.
     *
     * Example: `"1"`
     */
    sequence?: number;
    /**
     * True to specify that the item be displayed only if the user is a site administrator.
     * otherwise, false. Using the `RequireSiteAdministrator` attribute for the drop-down menu of SharePoint
     * Foundation commands that are associated with list items is not supported.
     *
     * Example: `"true"`
     */
    requireSiteAdministrator?: boolean;
    /**
     * Specifies a set of rights that the user must have for the link to be visible, for example,
     * "ViewListItems,ManageAlerts". If it is not specified, the action always appears in the list of actions.
     *
     * @remarks
     * To specify multiple rights, separate the values by using commas. The set of rights are grouped logically
     * according to AND logic, which means that a user must have all the specified rights to see an action. For
     * a list of possible values, see `Microsoft.SharePoint.SPBasePermissions`.
     *
     * Example: `"{Low: 0x01, High: 0x02}"`
     */
    rights?: IODataBasePermission;
}

/**
 * Application preloaded data
 *
 * @internal
 */
export declare interface _IPreloadedData {
    /**
     * Id of the application
     */
    clientSideApplicationId?: string;
    /**
     * Preloaded manifests
     */
    manifests: IClientSideComponentManifest[];
    /**
     * Page context information
     */
    spPageContextInfo?: _IODataPageContextInfo;
    /**
     * The context information for a site.
     */
    contextWebInfo?: IODataContextWebInformation;
    /**
     * Represents a user in Microsoft SharePoint Foundation.
     */
    user?: IODataUser;
    /**
     * Represents a SharePoint site.
     */
    web?: IODataWeb;
    /**
     * Represents a list on a SharePoint Web site.
     */
    list?: IODataList;
    /**
     * Represents an item or row in a list.
     */
    item?: IODataListItem;
    /**
     * Represents an assorted set of information relating to the current user
     * and application. Information includes SitePageContent and if the user
     * can edit the current page.
     */
    page?: any;
    /**
     * Represents a collection of SP.NavigationNode objects.
     */
    quickLaunch?: IODataNavigationNodeCollection;
    /**
     * Client-side custom actions
     */
    customActions?: _IPreloadedCustomAction[];
}

/**
 * Interface for the module loader.
 * It allows to load modules and scripts (through SystemJS) and CSS on the page.
 * Also allows access to the manifests that exist in the page.
 *
 * @internal
 */
export declare interface ISPComponentLoader {
    /**
     * All registered manifests.
     *
     * @readonly
     * @internal
     */
    readonly _manifestReferences: IClientSideComponentManifest[];
    /**
     * Starts the application.
     * This is called by the page scripts to start loading the framework. Do not call it from your own code.
     *
     * @param preloadedData - Preloaded data for the application.
     *
     * @internal
     */
    _startApplication<TApplication>(preloadedData: _IPreloadedData): Promise<TApplication>;
    /**
     * Initializes the component loader.
     * Registers all manifests (including debug manifests, if it applies)
     * and sets up internal logic before allowing to load components.
     *
     * @param preloadedData -     Preloaded data for the application.
     * @param bundledComponents - Map with all the components that are bundled in the same file as the loader.
     *
     * @internal
     */
    _initialize(preloadedData: _IPreloadedData, bundledComponents: {
        [id: string]: Object;
    }, debugData: _IDebugData): void;
    /**
     * Inserts a `<link ... />` tag for a stylesheet.
     *
     * @param url - The CSS file URL.
     */
    loadCss(url: string): void;
    /**
     * Given a URL, load a script.
     *
     * @remarks
     *
     * If a script with a global variable is being loaded, the global variable already exists, and the script
     * fails to load (because of a syntax error, for example), the original global variable may be returned and an
     * error may not be propagated.
     *
     * @param url     - The script URL.
     * @param options - globalExportsName: If the script isn't an AMD module and loads a global member on the page,
     *                    specify the global member's name.
     * @returns         A promise containing the loaded module.
     */
    loadScript<TModule>(url: string, options?: ILoadScriptOptions): Promise<TModule>;
    /**
     * Loads a component from a manifest.
     *
     * @param manifest - Manifest of the module to load.
     * @returns          A promise containing the loaded module.
     */
    loadComponent<TComponent>(manifest: IClientSideComponentManifest): Promise<TComponent>;
    /**
     * Unloads all components from SPFx.
     * This includes removing their references from SystemJS, RequireJS, and the ComponentLoader.
     *
     * @internal
     */
    _unloadComponents(): void;
    /**
     * Resolve a component id and version, and load it.
     *
     * @param id      - The id of the component to load.
     * @param version - The version of the component to load. If version is not defined, the method
     *                    will load any version of the component.
     * @returns         A promise containing the loaded module.
     *
     * @alpha
     */
    loadComponentById<TComponent>(id: string, version?: string): Promise<TComponent>;
    /**
     * Loads manifests from the specified manifests file URL as non-debug manifests without prompting the user.
     *
     * @param manifestsFileUrl - The URL of the manifests file.
     *
     * @returns A promise that is fulfilled when the manifests are loaded.
     *
     * @internal
     */
    _loadDebugManifestsForWorkbench(manifestsFileUrl: string): Promise<void>;
    /**
     * Try and get a reference to a loaded component module by id and version.
     *
     * @param manifest - Manifest of the module to load.
     * @returns A reference to a component module by id and version or, if it does not exist, undefined.
     *
     * @alpha
     */
    tryGetLoadedComponent<TComponent>(manifest: IClientSideComponentManifest): TComponent | undefined;
    /**
     * Get a component manifest from the component id and version.
     *
     * @param id      - GUID id of the component.
     * @param version - Version of the component. If version is not defined, the method
     *                    will return the manifest for any version of the component.
     * @returns         Manifest for the component.
     *
     * @alpha
     */
    tryGetManifestById(id: string, version?: string): IClientSideComponentManifest | undefined;
    /**
     * {@inheritdoc ManifestStore.requestManfiest}
     *
     * @alpha
     */
    requestManifest(id: string, version?: string): Promise<IClientSideComponentManifest>;
    /**
     * Registers manifests in the manifest store.
     *
     * @param manifests - The manifests to register in the store.
     *
     * @alpha
     */
    registerManifests(manifests: IClientSideComponentManifest[]): void;
}

/**
 * @internal
 */
export declare class _ManifestProvider {
    private static _restApiUrl;
    private _logSource;
    private _webAbsoluteUrl;
    private _pageContext;
    private _httpClient;
    constructor(serviceScope: ServiceScope, webAbsoluteUrl: string);
    /**
     * Given a component id and version, requests its manifest (and all its dependencies) to SharePoint
     * through a REST API.
     * Returns a promise with all the manifests.
     * @param componentId - Id of the requested component
     * @param version - Optional. Version of the requested component
     */
    tryGetManifest(componentId: string, version?: string): Promise<IClientSideComponentManifest[]>;
    /**
     * Given an array of ids and versions, requests their manifest (and all their dependencies) to SharePoint
     * through a REST API.
     * Returns a promise with all the manifests.
     * @param ids - Array with all the id and version pairs
     */
    tryGetManifests(ids: {
        id: string;
        version?: string;
    }[]): Promise<IClientSideComponentManifest[]>;
    private _extractManifests;
}

/**
 * This class maintains a cache of the manifests on the current page.
 *
 * @internal
 */
export declare class _ManifestStore {
    private static _instance;
    private _manifestProvider;
    static readonly instance: _ManifestStore;
    /**
     * Map from component id to array of manifest store indexes.
     * This allows to store manifests for different versions of the same component.
     *
     * @remarks
     * Example: `'d1d91016-032f-456d-98a4-721247c305e8' -->[ Version(1.0.0), Version(2.0.0) ]`
     */
    private _manifestVersions;
    /**
     * Map from manifest store index string to manifest store entry.
     * Manifest store index is generated through logic in utilities/normalizeComponentId (`<id>_<version>`)
     * e.g. `'d1d91016-032f-456d-98a4-721247c305e8_1.0.0' --> { ManifestStoreEntry }`
     */
    private _manifests;
    /**
     * Set of all the component ids that have their manifest pinned.
     * If a component id has its manifest pinned, no other manifest can be added for that component id,
     * regardless of version or debug manifest.
     *
     * @remarks
     *
     * Example: `{ '1c6c9123-7aac-41f3-a376-3caea41ed83f', '7263c7d0-1d6a-45ec-8d85-d4d1d234171b' }`
     */
    private _pinnedManifests;
    /**
     * Register the preloaded manifests on the manifest store.
     *
     * @param preloadedData - The preloaded data
     */
    registerPreloadedManifests(preloadedData: _IPreloadedData): void;
    /**
     * Register debug manifests on the manifest store.
     *
     * @param manifests - A dictionary of debug manifests.
     */
    registerDebugManifests(manifests: IClientSideComponentManifest[]): void;
    /**
     * Return a manifest by its component id and version.
     *
     * @remarks
     * If version is not provided, it will return the only available version. If more than
     * one version is available and version is not provided, returns undefined.
     *
     * Only return a debug manifest is debug is allowed. If a manifest isn't found by
     * the provided id, return undefined.
     *
     * @param id        - The component id of the manifest to retrieve.
     * @param version   - The version of the component of the manifest to retrieve.
     * @param shouldLog - True if failures should be logged. Defaults to true.
     * @returns           The retrieved manifest, or undefined if one could not be found.
     */
    tryGetManifest(id: string, version?: string, shouldLog?: boolean): IClientSideComponentManifest | undefined;
    /**
     * Return a manifest by its component id and version.
     *
     * @remarks
     * If version is not provided, it will return the only available version. If more than
     * one version is available and version is not provided, the function throws.
     *
     * Only return a debug manifest is debug is allowed. If a manifest isn't found by
     * the provided id, the function throws.
     *
     * @param id      - The component id of the manifest to retrieve.
     * @param version - The version of the component of the manifest to retrieve.
     * @returns         The retrieved manifest, or undefined if one could not be found.
     */
    getManifest(id: string, version?: string): IClientSideComponentManifest;
    /**
     * Get all registered manifests.
     *
     * @returns The registered manifests.
     */
    getRegisteredManifests(): IClientSideComponentManifest[];
    /**
     * Removes all manifests that are not considered essential, and registers all the manifests passed as input.
     * Essential manifests are assembly-related manifest, and debug manifests.
     *
     * @param manifests - Manifests to add.
     */
    replaceManifests(manifests: IClientSideComponentManifest[]): void;
    /**
     * Returns a map of manifest IDs to manifests.
     *
     * @returns A map of manifest IDs to manifests.
     */
    _getManifestMap(): Map<string, _IManifestStoreEntry>;
    /**
     * Loads additional manifests into the manifest store, updating existing manifests.
     *
     * @param manifests - The manifests to load into the store.
     */
    registerManifests(manifests: IClientSideComponentManifest[], overwriteExisting: boolean): void;
    /**
     * Pins the manifest for a specific component id.
     * That means that no other manifest can be added for the specified component id.
     *
     * @remarks
     * This is used by assemblies to ensure that debug manifests are not replacing components already in use.
     *
     * @param componentId - Component id with only one manifest, which will be pinned.
     */
    _pinManifest(componentId: string): void;
    /**
     * Given a component id and version, requests its manifest (and all its dependencies) to SharePoint
     * through a REST API.
     * @param id - Id of the requested component
     * @param version - Optional. Version of the requested component
     * @returns Promise with the requested manifest. Rejects the promise if the manifest was not found.
     */
    requestManifest(id: string, version?: string): Promise<IClientSideComponentManifest>;
    /**
     * Given a component id and version, requests its manifest (and all its dependencies) to SharePoint
     * through a REST API.
     * @param ids - List of ids and (optionally) versions of the manifests to request.
     * @returns Promise with the requested manifests. Rejects the promise if the manifest was not found.
     */
    requestManifests(ids: {
        id: string;
        version?: string;
    }[]): Promise<IClientSideComponentManifest[]>;
    /**
     * Sets the manifest provider.
     * This is used to request manifests in the server if they are not found in the manifest store.
     *
     * @remarks
     * This must be set once by SPApplicationLoader. If it is called more than once it does nothing.
     */
    _setManifestProvider(manifestProvider: _ManifestProvider): void;
    private _isManifestPinned;
    private _removeAllManifests;
    /**
     * Removes a manifest from the manifest store based on its id.
     * If it's a pinned manifest or a debug manifest it will skip it.
     *
     * @param id - Id of the manifest to remove.
     * @param version - Version of the manifest to remove.
     * @returns true if the manifest was removed.
     */
    private _removeManifest;
    /**
     * Internal implementation of `getManifest` that toggles whether failures should be logged or not.
     */
    private _getManifest;
    private _getManifestNotFoundErrorMessage;
    private _getManifestFromStoreEntry;
    private _addManifest;
    private _addDebugManifest;
    private _internalAddManifest;
    /**
     * Adds the manifest to the versions map.
     *
     * If the component id is not present in the map, adds a new entry in the map.
     * If the id and version are already present, it does nothing.
     */
    private _addManifestToVersionsMap;
    /**
     * Returns the index for a component id and version.
     * The index might not be for the same version, but a compatible one.
     *
     * If an index is not found, returns undefined.
     * If an index is request without a version, and there are multiple versions,
     * returns an error.
     * If more than one compatible version is found, an error is logged and
     * returns the highest compatible version.
     */
    private _getExistingIndex;
    /**
     * Gets the manifest store index for a component id without version.
     *
     * If no version is found for the id, returns undefined.
     * If there are too many manifests for the component id, logs an error and returns undefined.
     */
    private _getUniqueManifestStoreIndex;
    private _createIndexFromManifest;
    private _createIndex;
    private _findDebugIndex;
}

/**
 * Component loader.
 * Needs to be initialized with an implemented `ISPComponentLoader`.
 *
 * @public
 */
export declare class SPComponentLoader {
    private static _instance;
    /**
     * Initializes the component loader with an implementation.
     * Must be called once before it can be used.
     *
     * @internal
     */
    static _initialize(componentLoader: ISPComponentLoader): void;
    /**
     * {@inheritDoc  ISPComponentLoader._startApplication}
     *
     * @internal
     */
    static _startApplication<TApplication>(preloadedData: _IPreloadedData): Promise<TApplication>;
    /**
     * {@inheritDoc  ISPComponentLoader.loadCss}
     */
    static loadCss(url: string): void;
    /**
     * {@inheritDoc  ISPComponentLoader.loadScript}
     */
    static loadScript<TModule>(url: string, options?: ILoadScriptOptions): Promise<TModule>;
    /**
     * {@inheritDoc  ISPComponentLoader.loadComponent}
     */
    static loadComponent<TComponent>(manifest: IClientSideComponentManifest): Promise<TComponent>;
    /**
     * {@inheritDoc  ISPComponentLoader.loadComponentById}
     *
     * @public
     */
    static loadComponentById<TComponent>(id: string, version?: string): Promise<TComponent>;
    /**
     * {@inheritDoc  ISPComponentLoader.registerManifests}
     *
     * @alpha
     */
    static registerManifests(manifests: IClientSideComponentManifest[]): void;
    /**
     * {@inheritDoc  ISPComponentLoader.manifestReferences}
     *
     * @internal
     */
    static _getManifestReferences(): IClientSideComponentManifest[];
    /**
     * Returns static copies of all the manifests.
     *
     * @public
     */
    static getManifests(): IClientSideComponentManifest[];
    /**
     * {@inheritDoc  ISPComponentLoader.tryGetLoadedComponent}
     *
     * @alpha
     */
    static tryGetLoadedComponent<TComponent>(manifest: IClientSideComponentManifest): TComponent | undefined;
    /**
     * {@inheritDoc  ISPComponentLoader.tryGetManifestById}
     *
     * @alpha
     */
    static tryGetManifestById(id: string, version?: string): IClientSideComponentManifest | undefined;
    /**
     * {@inheritdoc ManifestStore.requestManifest}
     *
     * @alpha
     */
    static requestManifest(id: string, version?: string): Promise<IClientSideComponentManifest>;
    /**
     * {@inheritDoc  ISPComponentLoader._loadDebugManifestsForWorkbench}
     *
     * @internal
     */
    static _loadDebugManifestsForWorkbench(manifestsFileUrl: string): Promise<void>;
}

/**
 * Class to expose flight checks on sp-loader
 *
 * @internal
 */
export declare class _SPLoaderFlights {
    /**
     * Returns true if the SPFx should use the new boot sequence, which will support cross-app navigation.
     *
     * @internal
     */
    static _useNewBootSequence(): boolean;
}

/**
 * Bootstrapper for the application
 * @internal
 */
export declare class _SPStarter {
    private static _bundledComponents;
    private static _isTelemetryLoggingInRealTime;
    private static _realTimeProcessingWaitTime;
    /**
     * Sets a map with the bundled components. These components will be added to the component loader
     * during initialization, so they won't need to be loaded afterwards.
     * The map is of the form `componentId: string -> component: Object`
     *
     * @internal
     */
    static _setBundledComponents(bundledComponents: {
        [id: string]: Object;
    }): void;
    /**
     * This is called by the page scripts to start loading the framework. Do not call it from your own code.
     *
     * @param handleFailure - Error handler function provided by the server to execute if there is SPFx can't be loaded.
     *  It may redirect to an error page or log error data in the console.
     * @param debugData - This parameter is used when the loader initializes a debug loader and
     *  should never be provided by any external callers.
     */
    static start<TApplication>(preloadedData: _IPreloadedData, handleFailure: (errorInformation: _IErrorInformation) => void, debugData?: _IDebugData): Promise<TApplication>;
    /**
     * Returns the support level for the browser.
     *
     * There are some specific browsers that we know don't work with SPFx, and some
     * features that the browser needs to support for SPFx. In those cases the page
     * shouldn't even try to load.
     *
     * This is intended to be called by the page scripts before start.
     * There is no need, and no use, to call it from your own code.
     */
    static getBrowserCompatibility(): IBrowserCompatibility;
    private static _logDataInRealTime;
    /**
     * Returns the bundled components variable, after checking it exists.
     * If it doesn't exist, it throws an error as SPFx cannot be initialized without it.
     */
    private static _getBundledComponents;
    private static _initializeEnvironment;
    private static _initializeTelemetry;
    private static _initializeFlightsAndKillswitches;
    private static _isQueryParameterTrue;
    private static _isConsoleLogEnabled;
    private static _isTelemetryDisabled;
    private static _useRequireJs;
    private static handleError;
    private static _isRedirectDisabled;
    private static _consoleErrorHandleFailure;
    private static _errorAspxHandleFailure;
    private static _extractCompletenessCallbackEndpoint;
}

export { }
