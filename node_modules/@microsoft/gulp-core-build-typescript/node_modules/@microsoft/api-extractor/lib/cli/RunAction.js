"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const colors = require("colors");
const os = require("os");
const path = require("path");
const node_core_library_1 = require("@microsoft/node-core-library");
const ts_command_line_1 = require("@microsoft/ts-command-line");
const Extractor_1 = require("../api/Extractor");
const AE_CONFIG_FILENAME = 'api-extractor.json';
class RunAction extends ts_command_line_1.CommandLineAction {
    constructor(parser) {
        super({
            actionName: 'run',
            summary: 'Invoke API Extractor on a project',
            documentation: 'Invoke API Extractor on a project'
        });
    }
    onDefineParameters() {
        this._configFileParameter = this.defineStringParameter({
            parameterLongName: '--config',
            parameterShortName: '-c',
            argumentName: 'FILE',
            description: `Use the specified ${AE_CONFIG_FILENAME} file path, rather than guessing its location`
        });
        this._localParameter = this.defineFlagParameter({
            parameterLongName: '--local',
            parameterShortName: '-l',
            description: 'Indicates that API Extractor is running as part of a local build,'
                + ' e.g. on a developer\'s machine. This disables certain validation that would'
                + ' normally be performed for a ship/production build. For example, the *.api.ts'
                + ' review file is automatically copied in a local build.'
        });
        this._typescriptCompilerFolder = this.defineStringParameter({
            parameterLongName: '--typescript-compiler-folder',
            argumentName: 'PATH',
            description: 'By default API Extractor uses its own TypeScript compiler version to analyze your project.'
                + ' This can often cause compiler errors due to incompatibilities between different TS versions.'
                + ' Use "--typescript-compiler-folder" to specify the folder path for your compiler version.'
        });
    }
    onExecute() {
        const lookup = new node_core_library_1.PackageJsonLookup();
        let configFilename;
        let typescriptCompilerFolder = this._typescriptCompilerFolder.value;
        if (typescriptCompilerFolder) {
            typescriptCompilerFolder = path.normalize(typescriptCompilerFolder);
            if (node_core_library_1.FileSystem.exists(typescriptCompilerFolder)) {
                typescriptCompilerFolder = lookup.tryGetPackageFolderFor(typescriptCompilerFolder);
                const typescriptCompilerPackageJson = typescriptCompilerFolder
                    ? lookup.tryLoadPackageJsonFor(typescriptCompilerFolder)
                    : undefined;
                if (!typescriptCompilerPackageJson) {
                    throw new Error(`The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a package.`);
                }
                else if (typescriptCompilerPackageJson.name !== 'typescript') {
                    throw new Error(`The path specified in the ${this._typescriptCompilerFolder.longName} parameter is not a TypeScript`
                        + ' compiler package.');
                }
            }
            else {
                throw new Error(`The path specified in the ${this._typescriptCompilerFolder.longName} parameter does not exist.`);
            }
        }
        if (this._configFileParameter.value) {
            configFilename = path.normalize(this._configFileParameter.value);
            if (!node_core_library_1.FileSystem.exists(configFilename)) {
                throw new Error('Config file not found: ' + this._configFileParameter.value);
            }
        }
        else {
            // Otherwise, figure out which project we're in and look for the config file
            // at the project root
            const packageFolder = lookup.tryGetPackageFolderFor('.');
            // If there is no package, then try the current directory
            const baseFolder = packageFolder ? packageFolder : process.cwd();
            // First try the standard "config" subfolder:
            configFilename = path.join(baseFolder, 'config', AE_CONFIG_FILENAME);
            if (node_core_library_1.FileSystem.exists(configFilename)) {
                if (node_core_library_1.FileSystem.exists(path.join(baseFolder, AE_CONFIG_FILENAME))) {
                    throw new Error(`Found conflicting ${AE_CONFIG_FILENAME} files in "." and "./config" folders`);
                }
            }
            else {
                // Otherwise try the top-level folder
                configFilename = path.join(baseFolder, AE_CONFIG_FILENAME);
                if (!node_core_library_1.FileSystem.exists(configFilename)) {
                    throw new Error(`Unable to find an ${AE_CONFIG_FILENAME} file`);
                }
            }
            console.log(`Using configuration from ${configFilename}` + os.EOL + os.EOL);
        }
        const config = Extractor_1.Extractor.loadConfigObject(configFilename);
        const extractor = new Extractor_1.Extractor(config, {
            localBuild: this._localParameter.value,
            typescriptCompilerFolder: typescriptCompilerFolder
        });
        if (!extractor.processProject()) {
            console.log(os.EOL + colors.yellow('API Extractor completed with errors or warnings'));
            process.exitCode = 1;
        }
        return Promise.resolve();
    }
}
exports.RunAction = RunAction;
//# sourceMappingURL=RunAction.js.map