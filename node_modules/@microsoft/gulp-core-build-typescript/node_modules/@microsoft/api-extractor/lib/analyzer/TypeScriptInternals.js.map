{"version":3,"file":"TypeScriptInternals.js","sourceRoot":"","sources":["../../src/analyzer/TypeScriptInternals.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;AAE3D,wBAAwB;AAExB,iCAAiC;AAEjC,MAAa,mBAAmB;IAEvB,MAAM,CAAC,yBAAyB,CAAC,MAAiB,EAAE,WAA2B;QACpF,qBAAqB;QACrB,8EAA8E;QAC9E,OAAQ,WAAmB,CAAC,yBAAyB,CAAC,MAAM,CAAC,CAAC,CAAC,6BAA6B;IAC9F,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,0BAA0B,CAAC,WAA2B;QAClE,MAAM,MAAM,GAAe,WAAmB,CAAC,MAAM,CAAC;QACtD,OAAO,MAAM,CAAC;IAChB,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,qBAAqB,CAAC,IAAa,EAAE,IAAY;QAC7D,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,qBAAqB,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;IAClE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,4BAA4B,CAAC,IAA8D;QACvG,qBAAqB;QACrB,sFAAsF;QAEtF,OAAQ,EAAU,CAAC,4BAA4B,CAAC,IAAI,CAAC,CAAC;IACxD,CAAC;IAED;;;OAGG;IACI,MAAM,CAAC,iBAAiB,CAAC,UAAyB,EAAE,cAAsB;QAG/E,qBAAqB;QACrB,qFAAqF;QAErF,OAAQ,EAAU,CAAC,iBAAiB,CAAC,UAAU,EAAE,cAAc,CAAC,CAAC;IACnE,CAAC;IAED;;OAEG;IACI,MAAM,CAAC,eAAe,CAAC,MAAiB;QAC7C,OAAQ,MAAc,CAAC,MAAM,CAAC;IAChC,CAAC;CACF;AA5DD,kDA4DC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\n// tslint:disable:no-any\r\n\r\nimport * as ts from 'typescript';\r\n\r\nexport class TypeScriptInternals {\r\n\r\n  public static getImmediateAliasedSymbol(symbol: ts.Symbol, typeChecker: ts.TypeChecker): ts.Symbol {\r\n    // Compiler internal:\r\n    // https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/checker.ts\r\n    return (typeChecker as any).getImmediateAliasedSymbol(symbol); // tslint:disable-line:no-any\r\n  }\r\n\r\n  /**\r\n   * Returns the Symbol for the provided Declaration.  This is a workaround for a missing\r\n   * feature of the TypeScript Compiler API.   It is the only apparent way to reach\r\n   * certain data structures, and seems to always work, but is not officially documented.\r\n   *\r\n   * @returns The associated Symbol.  If there is no semantic information (e.g. if the\r\n   * declaration is an extra semicolon somewhere), then \"undefined\" is returned.\r\n   */\r\n  public static tryGetSymbolForDeclaration(declaration: ts.Declaration): ts.Symbol | undefined {\r\n    const symbol: ts.Symbol = (declaration as any).symbol;\r\n    return symbol;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the comment ranges associated with the specified node.\r\n   */\r\n  public static getJSDocCommentRanges(node: ts.Node, text: string): ts.CommentRange[] | undefined {\r\n    // Compiler internal:\r\n    // https://github.com/Microsoft/TypeScript/blob/v2.4.2/src/compiler/utilities.ts#L616\r\n\r\n    return (ts as any).getJSDocCommentRanges.apply(this, arguments);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (unescaped) value of an string literal, numeric literal, or identifier.\r\n   */\r\n  public static getTextOfIdentifierOrLiteral(node: ts.Identifier | ts.StringLiteralLike | ts.NumericLiteral): string {\r\n    // Compiler internal:\r\n    // https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L2721\r\n\r\n    return (ts as any).getTextOfIdentifierOrLiteral(node);\r\n  }\r\n\r\n  /**\r\n   * Retrieves the (cached) module resolution information for a module name that was exported from a SourceFile.\r\n   * The compiler populates this cache as part of analyzing the source file.\r\n   */\r\n  public static getResolvedModule(sourceFile: ts.SourceFile, moduleNameText: string): ts.ResolvedModuleFull\r\n    | undefined {\r\n\r\n    // Compiler internal:\r\n    // https://github.com/Microsoft/TypeScript/blob/v3.2.2/src/compiler/utilities.ts#L218\r\n\r\n    return (ts as any).getResolvedModule(sourceFile, moduleNameText);\r\n  }\r\n\r\n  /**\r\n   * Returns ts.Symbol.parent if it exists.\r\n   */\r\n  public static getSymbolParent(symbol: ts.Symbol): ts.Symbol | undefined {\r\n    return (symbol as any).parent;\r\n  }\r\n}\r\n"]}