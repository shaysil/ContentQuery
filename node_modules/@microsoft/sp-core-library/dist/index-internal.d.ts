/**
 * SharePoint Framework core libraries.
 *
 * @remarks
 * This package provides a foundation of core classes that ensure a consistent character
 * across all the other SharePoint Framework APIs.  Because this package is a dependency
 * of every other package, its design prioritizes small code size and broad applicability,
 * versus flexibility or richness of features.
 *
 * @packagedocumentation
 */


/**
 * Enum to identify browser.
 * @internal
 */
export declare const enum _Browser {
    Other = 0,
    Chrome = 1,
    Edge = 2,
    Firefox = 3,
    IE = 4,
    Safari = 5
}

/**
 * Provides with information from the browser.
 * @internal
 */
export declare class _BrowserDetection {
    /**
     * Returns information from the browser, calculated from the user agent.
     *
     * @param userAgent - Optional. If provided, it will calculate the data from the input parameter,
     *                      instead of the user agent from the browser.
     * @returns Browser information, with browser and OS data.
     */
    static getBrowserInformation(userAgent?: string): _IBrowserInformation;
    private static getUserAgent;
    private static buildBrowserInformation;
    private static fillBrowser;
    private static fillOS;
}

/**
 * Browser support level for a component.
 *
 * @remarks
 * Allow to establish different levels, including blocked, where the component won't load, to
 * full functionality, where it should work and a failure is considered a high severity problem.
 *
 * @alpha
 */
export declare const enum BrowserSupportLevel {
    /**
     * None: Support level is not available. No assumptions can be made.
     *
     * @remarks
     * This value is meant to be used when there is no code to check the browser support.
     * If any check is performed, this value should not be returned.
     */
    None = 0,
    /**
     * Full functionality: Known browser, component should work properly in all scenarios.
     *
     * @privateRemarks
     * A failure with this support level on a Microsoft-provided component should trigger a high-severity ticket.
     */
    FullFunctionality = 1,
    /**
     * Readable: Component should be usable, potentially with limited functionality.
     */
    Readable = 2,
    /**
     * Blocked: The component does not work with this browser.
     * The SharePoint Framework will prevent the page from rendering, instead displaying the supplied warning message.
     * This a very poor experience for the end user. Only use this level for situations where it is absolutely certain
     * that the page will fail to render, and it is not feasible to implement a workaround.
     */
    Blocked = 3
}

/**
 * BrowserUtilities contains common utilities for browser related operations.
 * @internal
 */
export declare class _BrowserUtilities {
    private static _isWebViewHosted;
    private static _isMobileBrowser;
    private static _isMobileWebView;
    private static _isSharePointiOSApp;
    private static _isTeamsWebView;
    private static _isSharePointDesktopApp;
    private static _isEmbedded;
    private static readonly _sharePointDesktopAppString;
    private static readonly _serviceWorkerProperty;
    static isWebViewHosted(): boolean;
    static isTeamsWebView(): boolean;
    static isSharePointiOSApp(): boolean;
    static isMobileWebView(): boolean;
    static isMobileBrowser(): boolean;
    static isSharePointDesktopApp(): boolean;
    static isEmbedded(): boolean;
    static supportsServiceWorker(): boolean;
    private static _isTestMobileWebView;
    private static _isMobileIntuneBrowser;
}

/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * @file Abstract class for deferred class code.
 */
/**
 * `DeferredClass` is a generic class to define the pattern of code loaded after the initial code download.
 *
 * @remarks
 * Example:
 * ```
 * class DeferredFoo extends DeferredClass<typeof Foo, Foo> {
 *
 *   // Static members do not inherit the generic types so we do this to correctly enforce the right typing.
 *   public static instance() DeferredFoo {
 *     return this._instance;
 *   }
 *
 *   public create(arg1: string, arg2: number): Foo {
 *     return new this._classType(arg1, arg2);
 *   }
 *
 *   protected _internalLoad(): Promise<Type> {
 *     // code to lazy load e.g. require.ensure(...)
 *     // or import(...)
 *     // or SPComponentLoader.loadComponentById(...).then(
 *     // (module: typeof DeferredFooModuleType) => { return module.DeferredFoo; });
 *   }
 * }
 * ```
 *
 * @param Type - The type of the Instance object. This type should define how you create an instance
 *   of the deferred class.
 * @param Instance - The interface of the deferred class.
 *
 * @internal
 */
export declare abstract class _DeferredClass<Type, Instance> {
    /**
     * The singleton instance.
     */
    private static _internalInstance;
    /**
     * Resolves after _loadPromise resolves.
     */
    protected readonly _onAfterLoadPromise: Promise<void>;
    /**
     * The type of the Instance object.
     */
    protected _classType: Type;
    /**
     * The promise used for loading the code.
     */
    protected _loadPromise: Promise<Type>;
    /**
     * Resolve callback from _onAfterLoadPromise. Invoked in DeferredClass.load after the code has loaded.
     */
    protected _resolveOnAfterLoadCallbacks: () => void;
    /**
     * Initialize, if needed, the _internalInstance singleton.
     *
     * @returns - The singleton instance.
     */
    protected static _getInstance(): any;
    /**
     * Instantiate an instance of Type.
     *
     * @param args - A generic argument list; should match the signature of the constructor for Type.
     *
     * @returns - An instance of Type.
     */
    abstract create(...args: any[]): Instance;
    /**
     * @returns Whether or not the code has been loaded.
     */
    readonly isLoaded: boolean;
    /**
     * @returns Whether or not the code should load. Value should not change during the lifecycle of an instance.
     */
    readonly shouldLoad: boolean;
    /**
     * Loads the deferred chunk. After the returned promise is resolved, DeferredClass.create can be used
     * to create an instance of the deferred class.
     *
     * @returns - The Promise used for loading the code. If DeferredClass.shouldLoad has been overriden
     *   and returns false, then a rejected Promise is returned.
     */
    load(): Promise<Type>;
    /**
     * Returns a thenable Promise to be resolved after the code has finished loading. Use this for cases where
     * you do not want to invoke code loading but want to be notified when the code has loaded.
     *
     * @returns - A promise resolved after the code loads.
     */
    onAfterLoad(): Promise<void>;
    /**
     * Singleton instance.
     */
    protected constructor();
    /**
     * Defines how the deferred class is to be loaded asynchronous.
     *
     * @returns - The promise used for loading the code.
     */
    protected abstract _internalLoad(): Promise<Type>;
}

/**
 * Indicates whether a visual control should display itself for reading or for editing.
 *
 * @public
 */
export declare enum DisplayMode {
    /**
     * The page, control, or editing surface is in a mode intended for reading.  It may have some interactive
     * features, but the authoring controls are not enabled.
     */
    Read = 1,
    /**
     * The page, control, or editing surface is in a mode intended for authoring new content.  It may display
     * editing panels or other controls that are not part of the normal reading experience.
     */
    Edit = 2
}

/**
 * Information about the system environment where the SharePoint Framework is running.
 * @public
 */
export declare class Environment {
    private static _type;
    /**
     * This is called once by the system during startup to initialize the Environment object.
     * @internal
     */
    static _initialize(data: _IEnvironmentData): void;
    /**
     * Indicates the general type of environment where the SharePoint Framework is running.
     */
    static readonly type: EnvironmentType;
}

/**
 * Indicates the general type of environment where the SharePoint Framework is running.
 *
 * @remarks
 * This enum is used by the {@link Environment."type"} property.  It provides a way to distinguish
 * environments where certain functionality may be limited or disabled.
 *
 * @public
 */
export declare enum EnvironmentType {
    /**
     * Indicates that the SharePoint Framework is running inside a test harness, e.g. a unit test.
     * There may be no user interaction at all, and network access in general may be disabled.
     */
    Test = 0,
    /**
     * Indicates that the SharePoint Framework is running on a page from a "localhost" web server,
     * for example the SharePoint Workbench when hosted via "gulp serve".  SharePoint REST API calls
     * will not be available, and in general network access may not authenticate properly.
     * Certain page context information may be using mock values for testing.
     */
    Local = 1,
    /**
     * Indicates that the SharePoint Framework is running on a modern SharePoint web page,
     * with full framework functionality.  This is the normal usage scenario.
     */
    SharePoint = 2,
    /**
     * Indicates that the framework was hosted by a classic server-rendered SharePoint page.
     * Some functionality may be limited, e.g. various extensibility APIs may not be supported.
     */
    ClassicSharePoint = 3
}

/**
 * DO NOT USE THIS DEFINITION.
 * @remarks
 * This is a backwards compatibility shim for legacy third-party bundles that imported the
 * old "Event" class.  It was renamed to solve a naming conflict with the brower DOM "Event".
 * @internal @preapproved
 * @deprecated Use the SPEvent class instead.
 */
export declare class Event<T> extends SPEvent<T> {
}

/**
 * DO NOT USE THIS DEFINITION.
 * @remarks
 * This is a backwards compatibility shim for legacy third-party bundles that imported the
 * old "EventArgs" class.  It was renamed to solve a naming conflict with the brower DOM "Event".
 * @internal @preapproved
 * @deprecated Use the SPEvent class instead.
 */
export declare class EventArgs extends SPEventArgs {
}

/**
 * This class represents a globally unique identifier, as described by
 * IETF RFC 4122.
 *
 * @remarks
 * The input string is normalized and validated, which provides
 * important guarantees that simplify other code that works with the GUID.
 * This class also provides basic support for generating a pseudo-random GUID;
 * however, be aware that the uniqueness depends on the browser's `Math.random()`
 * function and may be not be suitable for some applications.
 *
 * See {@link https://www.ietf.org/rfc/rfc4122.txt | RFC4122} for more information.
 *
 * @public
 */
export declare class Guid {
    /**
     * Returns a new empty Guid instance.
     *
     * @returns A new empty Guid object.
     */
    static readonly empty: Guid;
    private static readonly _guidRegEx;
    /**
     * @member _guid - Internal guid value
     */
    private _guid;
    /**
     * Returns a new Guid instance with a pseudo-randomly generated GUID, according
     * to the version 4 UUID algorithm from RFC 4122.
     *
     * @returns A new unique Guid object
     */
    static newGuid(randomNumberGenerator?: IRandomNumberGenerator): Guid;
    /**
     * Parses the input string to construct a new Guid object.
     * If the string cannot be parsed, then an error is thrown.
     *
     * @remarks
     * Example syntaxes accepted by this function:
     *
     * - `"d5369f3b-bd7a-412a-9c0f-7f0650bb5489"`
     *
     * - `"{d5369f3b-bd7a-412a-9c0f-7f0650bb5489}"`
     *
     * - `"/Guid(d5369f3b-bd7a-412a-9c0f-7f0650bb5489)/"`
     *
     * @param guid - The input string.
     * @returns A valid Guid object
     */
    static parse(guidString: string | undefined | null): Guid;
    /**
     * Attempts to parse the input string to construct a new Guid object.
     * If the string cannot be parsed, then undefined is returned.
     *
     * @remarks
     * Example syntaxes accepted by this function:
     *
     * - `"d5369f3b-bd7a-412a-9c0f-7f0650bb5489"`
     *
     * - `"{d5369f3b-bd7a-412a-9c0f-7f0650bb5489}"`
     *
     * - `"/Guid(d5369f3b-bd7a-412a-9c0f-7f0650bb5489)/"`
     *
     * @param guid - The input string.
     * @returns The Guid object, or undefined if the string could not be parsed.
     */
    static tryParse(guid: string | undefined | null): Guid | undefined;
    /**
     * Indicates whether a GUID is valid, i.e. whether it would be successfully
     * parsed by `Guid.tryParse()`.  This function is cheaper than `Guid.tryParse()`
     * because it does not construct a Guid object.
     *
     * @param guid - The input string.
     * @returns true, if the Guid is valid.
     */
    static isValid(guid: string | undefined | null): boolean;
    /**
     * SharePoint can have guids in the form:
     *   - Guid(...)
     *   - {...}
     * _normalize transforms guids in this format to the standard
     * guid format.
     *
     * Example: '/Guid(d5369f3b-bd7a-412a-9c0f-7f0650bb5489)/'
     *          -> 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489'
     * Example: '{d5369f3b-bd7a-412a-9c0f-7f0650bb5489}'
     *          -> 'd5369f3b-bd7a-412a-9c0f-7f0650bb5489'
     *
     * @param guid - Guid to be normalized, could already be normalized.
     * @returns Normalized guid.
     */
    private static _normalize;
    /**
     * Creates a new guid.
     *
     * @returns A valid guid (according to RFC4122)
     */
    private static _generateGuid;
    /**
     * Compare this instance to another Guid instance
     *
     * @returns True if this instance and the specified Guid object
     * represent the same value.
     */
    equals(guid: Guid): boolean;
    /**
     * Returns a string representation of the GUID
     *
     * @returns The GUID value in lowercase hexadecimal without braces.
     *
     * Example: `'d5369f3b-bd7a-412a-9c0f-7f0650bb5489'`
     */
    toString(): string;
    /**
     * Use `Guid.parse()` or `Guid.tryParse()` instead of the constructor.
     * @param guid - a normalized, already valid Guid string
     */
    private constructor();
}

/**
 * Used to report the level of support for the web browser, along with a warning message.
 *
 * @alpha
 */
export declare interface IBrowserCompatibility {
    /** Support level: Enum defining the level of support. */
    supportLevel: BrowserSupportLevel;
    /**
     * Warning: Optional. Localized message to show explaining the cause of the support level.
     *
     * Examples:
     * (Support level: Blocked) "Component blocked because the browser does not support feature X"
     * (Support level: Readable) "Limited functionality: Feature X is disabled"
     *
     * @remarks
     * Warning is unused when support level is "None".
     */
    warning: string | undefined;
}

/**
 * Information from the browser.
 * Includes browser name and version, and OS name and version.
 *
 * If the browser or the OS are not recognized, uses value "Other"
 * If the version is not recognized, the value will be undefined.
 *
 * @internal
 */
export declare interface _IBrowserInformation {
    /**
     * Browser name, as an enum. Other if it's not recognized.
     */
    browser: _Browser;
    /**
     * Browser version. undefined if it's not recognized.
     */
    browserVersion?: Version;
    /**
     * OS name, as an enum. Other if it's not recognized.
     */
    os: _OS;
    /**
     * OS version. undefined if it's not recognized.
     */
    osVersion?: string;
    /**
     * Original User Agent that was used to recognize all data.
     */
    userAgent?: string;
}

/**
 * Implemented by an object that supports a disposal lifecycle.
 *
 * @remarks
 * The dispose event allows an object to free any resources that it allocated
 * before its lifecycle ends.
 *
 * @public
 */
export declare interface IDisposable {
    /**
     * Returns true if the dispose() method has been called.  Once an object is disposed,
     * it remains in this state permanently.
     *
     * @remarks
     * After the object has been disposed, do not call its methods or access its properties.
     */
    isDisposed: boolean;
    /**
     * This method is called to permanently dispose the object.
     *
     * @remarks
     * After the object has been disposed, do not call its methods or access its properties.
     */
    dispose(): void;
}

/**
 * Interface for properties necessary for building a Environment object.
 * @internal
 */
export declare interface _IEnvironmentData {
    /** {@inheritDoc Environment."type"} */
    type: EnvironmentType;
}

/**
 * The redirectable implementation for the Log class.
 *
 * @alpha
 */
export declare interface ILogHandler {
    verbose(source: string, message: string, scope: ServiceScope | undefined): void;
    info(source: string, message: string, scope: ServiceScope | undefined): void;
    warn(source: string, message: string, scope: ServiceScope | undefined): void;
    error(source: string, error: Error, scope: ServiceScope | undefined): void;
}

/**
 * This is a {@link ServiceScope} contract for generating pseudorandom random numbers.
 *
 * @remarks
 * This interface abstracts the functionality of the system Math.random() API
 * for usage with a {@link ServiceScope}.  For example, a unit test might replace
 * the default {@link RandomNumberGenerator} service with a mock implementation
 * that always returns the same sequence of random numbers, in order to ensure that
 * test failures are always repeatable.
 *
 * @public
 */
export declare interface IRandomNumberGenerator {
    /**
     * Returns a pseudorandom number between 0 (inclusive) and 1 (exclusive),
     * following the contract of Math.random().
     */
    generate(): number;
}

/**
 * A shorthand pattern for extracting well-known services from a ServiceScope.
 *
 * @public
 *
 * @deprecated This pattern has been superceded by the BaseComponentContext pattern.
 * This interface will be removed in a future release.
 */
export declare interface IServiceCollection {
    /**
     * Returns the underlying ServiceScope that the members belong to.
     */
    readonly serviceScope: ServiceScope;
}

/**
 * Interface for properties neccesary for building a Session object.
 * @internal
 */
export declare interface _ISessionData {
    /** {@inheritDoc Session.applicationId} */
    applicationId: string;
    /** {@inheritDoc Session.pageId} */
    pageId?: string;
}

/**
 * Used with the {@link SPEvent} system, this interface is implemented by components that
 * can subscribe to events.
 *
 * @remarks
 * ISPEventObserver is an abstraction of the key features that a component must have in order
 * to subscribe to a SharePoint Framework event:  It must have instanceId and componentId
 * information for diagnostics reporting, and it must have a way to notify the event system
 * when the component is disposed, so that its handlers can be automatically removed.
 * Other objects may implement this contract, as long as they meet these requirements.
 *
 * @public
 */
export declare interface ISPEventObserver extends IDisposable {
    /**
     * The instance identifier for the component.
     *
     * @remarks
     * This will be used for diagnostic reporting, e.g. if the callback function has
     * an uncaught exception
     */
    readonly instanceId: string;
    /**
     * The component identifier, from the component's manifest.
     *
     * @remarks
     * This will be used for diagnostic reporting, e.g. if the callback function has
     * an uncaught exception
     */
    readonly componentId: string;
}

/**
 * This is a {@link ServiceScope} contract for reading the system clock.
 *
 * @remarks
 * This interface abstracts the functionality of the system time APIs
 * for usage with a {@link ServiceScope}.  For example, a unit test might replace
 * the default {@link TimeProvider} service with a mock implementation
 * that follows a manually incremented timeline, in order to ensure that
 * test failures are always repeatable.
 *
 * @public
 */
export declare interface ITimeProvider {
    /**
     * Returns the current date/time, similar to the Date class constructor.
     */
    getDate(): Date;
    /**
     * Returns a DOMHighResTimeStamp timing measurement, as defined by the
     * standard performance.now() API.
     */
    getTimestamp(): number;
}

/**
 * Utililty code to help manipulate JSON objects/strings.
 * See {@link http://www.json.org} for more information.
 *
 * @alpha
 */
export declare class JsonUtilities {
    /**
     * The list of characters that need to be escaped and their substitute characters
     */
    private static _escapableChars;
    private static _substibuteChars;
    /**
     * Encode a json string such that it can be safely transported over a network and be processed
     * in the server side code. And also safely transported back to the client and consumed by
     * JSON.parse().
     *
     * @param json - the json string to encode.
     */
    static encode(json: string): string | undefined;
}

/**
 * A basic redirectable logging system.
 *
 * @remarks
 * The Log class provides static methods for logging messages at different levels (verbose,
 * info, warning, error) and with context information. Context information helps identify
 * which component generated the messages and allows for filtering of log events.  In a
 * SharePoint Framework application, these messages will appear on the developer dashboard.
 *
 * @public
 */
export declare class Log {
    private static _logHandler;
    /**
     * Configures the logger with a different target.
     *
     * @internal
     */
    static _initialize(logHandler: ILogHandler): void;
    /**
     * Logs a message which contains detailed information that is generally only needed for
     * troubleshooting.
     * @param   source - the source from where the message is logged, e.g., the class name.
     *          The source provides context information for the logged message.
     *          If the source's length is more than 20, only the first 20 characters are kept.
     * @param   message - the message to be logged
     *          If the message's length is more than 100, only the first 100 characters are kept.
     * @param   scope - the service scope that the source uses. A service scope can provide
      *         more context information (e.g., web part information) to the logged message.
     */
    static verbose(source: string, message: string, scope?: ServiceScope): void;
    /**
     * Logs a general informational message.
     * @param   source - the source from where the message is logged, e.g., the class name.
     *          The source provides context information for the logged message.
     *          If the source's length is more than 20, only the first 20 characters are kept.
     * @param   message - the message to be logged
     *          If the message's length is more than 100, only the first 100 characters are kept.
     * @param   scope - the service scope that the source uses. A service scope can provide
      *         more context information (e.g., web part information) to the logged message.
     */
    static info(source: string, message: string, scope?: ServiceScope): void;
    /**
     * Logs a warning.
     * @param   source - the source from where the message is logged, e.g., the class name.
     *          The source provides context information for the logged message.
     *          If the source's length is more than 20, only the first 20 characters are kept.
     * @param   message - the message to be logged
     *          If the message's length is more than 100, only the first 100 characters are kept.
     * @param   scope - the service scope that the source uses. A service scope can provide
      *         more context information (e.g., web part information) to the logged message.
     */
    static warn(source: string, message: string, scope?: ServiceScope): void;
    /**
     * Logs an error.
     * @param   source - the source from where the error is logged, e.g., the class name.
     *          The source provides context information for the logged error.
     *          If the source's length is more than 20, only the first 20 characters are kept.
     * @param   error - the error to be logged
     * @param   scope - the service scope that the source uses. A service scope can provide
      *         more context information (e.g., web part information) to the logged error.
     */
    static error(source: string, error: Error, scope?: ServiceScope): void;
}

/**
 * Enum to identify OS.
 * @internal
 */
export declare const enum _OS {
    Other = 0,
    Android = 1,
    IOS = 2,
    Linux = 3,
    Mac = 4,
    Windows = 5,
    WindowsPhone = 6
}

/**
 * This is the default implementation of {@link IRandomNumberGenerator} that simply
 * calls Math.random().
 *
 * @public
 */
export declare class RandomNumberGenerator implements IRandomNumberGenerator {
    /**
     * The service key for IRandomNumberGenerator.
     */
    static readonly serviceKey: ServiceKey<IRandomNumberGenerator>;
    constructor(serviceScope: ServiceScope);
    /** {@inheritDoc IRandomNumberGenerator.generate} */
    generate(): number;
}

/**
 * This is a callback that is used by ServiceKey.createCustom().
 * @public
 */
export declare type ServiceCreator<T> = (serviceScope: ServiceScope) => T;

/**
 * The ServiceKey is a lookup key that is used when calling {@link ServiceScope.consume}
 * to fetch a dependency.
 *
 * @remarks
 * Every service key also provides a default implementation of the dependency, which will
 * be automatically created in the root scope if the dependency is not found.  Providing a default
 * implementation ensures that new dependencies can be safely introduced without inadvertently
 * breaking components that are loaded by an older host that does not provide the new dependency.
 *
 * @public
 */
export declare class ServiceKey<T> {
    /**
     * A unique identifier for this service key.
     *
     * @remarks
     * This identifier is an automatically generated string that will be unique for the lifetime
     * of the page.  Callers should not make assumptions about the formatting of this string.  It is
     * currently based on a global counter, but this may change in the future.
     *
     * The ServiceScope uses this identifier internally as a dictionary key for finding services.
     * The ServiceKey is meant to be unique, even if multiple instances of the same library are
     * loaded on the same page, even if the same name was passed to ServiceKey.create().
     * This is because each call to ServiceKey.create() could potentially provide a different
     * defaultCreator implementation, whereas one of the design goals of ServiceScope is that
     * the order in which libraries are loaded should never affect the resulting tree of scopes.
     */
    readonly id: string;
    /**
     * The name of the service.
     *
     * @remarks
     * This name is used for logging and diagnostic purposes only.  To make it unique, the
     * recommended convention is the package name, followed by a period, followed by the
     * class or interface name.
     *
     * The system does not assume that this string is unique.  Instead, the {@link ServiceKey.id}
     * is used wherever a lookup key is needed.
     */
    readonly name: string;
    /**
     * A callback function that constructs the default instance of this service.
     */
    readonly defaultCreator: ServiceCreator<T>;
    /**
     * Constructs a new ServiceKey whose default implementation will be a new instance of
     * a TypeScript class that accepts the standard constructor parameter.
     *
     * @remarks
     * If you want to specify custom constructor parameters, use {@link ServiceKey.createCustom}
     * instead.
     *
     * @param name - A name such as "my-package.IMyService" which should be unique across packages.
     * @param serviceClass - the TypeScript class that implements the service.
     * @returns the newly created ServiceKey
     */
    static create<TKey>(name: string, serviceClass: {
        new (serviceScope: ServiceScope): TKey;
    }): ServiceKey<TKey>;
    /**
     * Constructs a new ServiceKey whose default implementation will be obtained
     * by invoking the specified callback.
     *
     * @param name - A name such as "my-package.IMyService" which should be unique across packages.
     * @param defaultCreator - a callback that returns an object that implements the T interface
     * @returns the newly created service key
     */
    static createCustom<TKey>(name: string, defaultCreator: ServiceCreator<TKey>): ServiceKey<TKey>;
    private constructor();
}

/**
 * The service locator pattern used by the SharePoint Framework.
 *
 * @remarks
 * ServiceScope provides a formalized way for components to register and consume dependencies
 * ("services"), and to enable different implementations to be registered in different scopes.
 * This improves modularity by decoupling components from their dependencies in an extensible way.
 *
 * For example, suppose that various components need access to an IPageManager instance.  We could
 * simply make the PageManager a singleton (i.e. global variable), but this will not work e.g. if
 * we need to create a pop-up dialog that requires a second PageManager instance.  A better solution
 * would be to add the PageManager as a constructor parameter for each component that requires it,
 * however then we immediately face the problem that any code that calls these constructors
 * also needs a PageManager parameter.  In an application with many such dependencies, business
 * logic that ties together many subsystems would eventually pick up a constructor parameter
 * for every possible dependency, which is awkward.  A natural solution would be to move all the
 * dependencies into a class with name like "ApplicationContext", and then pass this around as our
 * constructor parameter.  This enables the PageManager to be passed to classes that need it
 * without cluttering the intermediary classes that don't.  However, it still has a design problem
 * that "ApplicationContext" has hard-coded dependencies on many unrelated things.  A more flexible
 * approach is to make it a dictionary that can look up items for consumers/providers who know the
 * right lookup key (i.e. ServiceKey).  This is the popular "service locator" design pattern,
 * familiar from the SPContext API in classic SharePoint.
 *
 * ServiceScope takes this idea a step further in two important ways:  First, it provides a scoping
 * mechanism so that e.g. if we have two different pages, they can each provide a unique PageManager
 * instance while still sharing other common dependencies.  Secondly, it allows for a ServiceKey
 * to provide a default implementation of the dependency.  This is important for API stability in
 * our modular client-side environment:  For example, suppose that version 2.0 of our application
 * introduced a new IDiagnosticTracing interface that a version 2.0 component will expect to consume.
 * If the version 2.0 component gets loaded by an older 1.0 application, it would fail.  We could
 * fix this by requiring each consumer to check for any missing dependencies and handle that case,
 * but it would require a lot of checks.  A better solution is to ensure that a default implementation
 * always exists, perhaps just a trivial behavior, so that components can assume that consume() will
 * always return some object that implements the contract.
 *
 * Usage: ServiceScope instances are created by calling either ServiceScope.startNewRoot() or
 * ServiceScope.startNewChild().  They are initially in an "unfinished" state, during which provide()
 * can be called to register service keys, but consume() is disallowed.  After ServiceScope.finish()
 * is called, consume() is allowed and provide() is now disallowed.  These semantics ensure that
 * ServiceScope.consume() always returns the same result for the same key, and does not depend on
 * order of initialization.  It also allows us to support circular dependencies without worrying
 * about infinite loops.  (Circular dependencies are best avoided, however this is difficult to
 * guarantee when working with components that were contributed by various third parties without
 * any coordination.)  To avoid mistakes, it's best to always call consume() inside a callback from
 * serviceScope.whenFinished().
 *
 * @public
 */
export declare class ServiceScope {
    private _registrations;
    private _parent;
    private _pendingCallbacks;
    private _finished;
    private _autocreating;
    /**
     * Create a new root-level ServiceScope.  Only root-level scopes have the ability to autocreate
     * default implementations of ServiceKeys.
     *
     * @returns the newly created root ServiceScope
     */
    static startNewRoot(): ServiceScope;
    /**
     * This is a shorthand function that is equivalent to constructing a new instance of the
     * simpleServiceClass, then registering it by calling ServiceScope.provide().
     *
     * @param serviceKey - the key that can be used later to consume the service
     * @param simpleServiceClass - the TypeScript class to be constructed
     * @returns a newly constructed instance of simpleServiceClass
     */
    createAndProvide<T>(serviceKey: ServiceKey<T>, simpleServiceClass: {
        new (serviceScope: ServiceScope): T;
    }): T;
    /**
     * This is a shorthand function that constructs the default implementation of the specified
     * serviceKey, and then registers it by calling ServiceScope.provide().
     *
     * @param serviceKey - the key that can be used later to consume the service
     * @returns a service instance that was constructed using ServiceKey.defaultCreator
     */
    createDefaultAndProvide<T>(serviceKey: ServiceKey<T>): T;
    /**
     * Consumes a service from the service scope.
     *
     * @remarks
     * Components should call this function to "consume" a dependency, i.e. look up the serviceKey
     * and return the registered service instance.  If the instance cannot be found, then a default
     * instance will be automatically created and registered with the root ServiceScope.
     *
     * @param serviceKey - the key that was used when provide() was called to register the service
     * @returns the service instance
     */
    consume<T>(serviceKey: ServiceKey<T>): T;
    /**
     * Completes the initialization sequence for a service scope.
     *
     * @remarks
     * When a ServiceScope is first started, it is in an "unfinished" state where provide() is
     * allowed but consume() is disallowed.  After calling finish(), then consume() is allowed
     * but provide() is disallowed.
     *
     * This formalism prevents a number of complex situations that could lead to bugs.  For example,
     * supposed that Scope2 is a child of Scope1, and Scope1 provides instance A1 of interface A.
     * If someone consumes A1 from Scope2 (via inheritance) before Scope2.provide() is called
     * with A2, then a subsequent call to Scope2.consume() might return a different result than
     * the previous call.  This nondeterminism could cause unpredictable results that are
     * difficult to diagnose.
     */
    finish(): void;
    /**
     * Returns the parent of the current ServiceScope, or undefined if this is a root scope.
     *
     * @returns the parent service scope
     */
    getParent(): ServiceScope | undefined;
    /**
     * Defer an operation until after {@link ServiceScope.finish} has completed.
     *
     * @remarks
     * It is an error to call ServiceScope.consume() before finish() has been called.
     * The most reliable way to protect your component against this error is to perform the
     * consume() calls inside a whenFinished() callback.  If the service scope is already
     * finished, then the callback will be executed immediately; otherwise, it will be executed
     * later when the scope is finished.
     *
     * NOTE: This is not an asynchronous callback.  ServiceScope initialization is typically
     * inexpensive and short lived. However, the control flow often threads through numerous
     * constructors and base classes, which can be simplified using whenFinished().
     *
     * @param callback - A block of code that needs to call ServiceScope.consume()
     */
    whenFinished(callback: () => void): void;
    /**
     * Add a new service to a service scope.
     *
     * @remarks
     * ServiceScope.provide() is used to register an implementation of the given serviceKey
     * for the current scope.  It may only be used when the ServiceScope is in an "unfinished"
     * state, i.e. before finish() has been called.
     *
     * @param serviceKey - the key that will later be used to consume the service
     * @param service - the service instance that is being registered
     * @returns the same object that was passed as the "service" parameter
     */
    provide<T>(serviceKey: ServiceKey<T>, service: T): T;
    /**
     * Constructs a new ServiceScope that is a child of the current scope.
     *
     * @remarks
     * The service scopes form a tree structure, such that when consuming a service,
     * if the key is not explicitly provided by a child scope, the parent hierarchy
     * will be consulted.
     *
     * @returns the newly created root ServiceScope
     */
    startNewChild(): ServiceScope;
    protected constructor(parent: ServiceScope | undefined);
    /**
     * Registers a service to the ServiceScope.
     * @internal
     */
    protected _registerService<T>(serviceKey: ServiceKey<T>, service: T): void;
    private _processPendingCallbacks;
}

/**
 * Provides access to the application's browser session and active page.
 *
 * @public
 */
export declare class Session {
    private static _applicationId;
    private static _pageId;
    /**
     * This is called once by the system during startup to initialize the Session object.
     * @internal
     */
    static _initialize(data: _ISessionData): void;
    /**
     * This is called by the framework to indicate that the current page has changed.
     * @internal
     */
    static _changePage(): void;
    /**
     * A unique identifier for the current instance of the client-side application.
     *
     * @remarks
     * A unique identifier used to correlate logging and other diagnostic information. Its lifetime
     * persists for the duration of the client-side application instance, i.e. it begins with the
     * server request that renders the page, and ends e.g. when the browser tab is closed or F5 is
     * pressed to reload the page.  Note that if the application's router supports in-place navigation
     * (via the history.pushState() API), the application session persists across these transitions.
     */
    static readonly applicationId: Guid;
    /**
     * A unique identifier for the current page within the client-side application.
     *
     * @remarks
     * A unique identifier used to correlate logging and other diagnostic information.  Whereas the
     * {@link Session.applicationId} tracks the entire lifetime of the client-side application instance,
     * the pageId tracks an individual "page" that is rendered.
     *
     * For example, suppose that the application initially loads PageA, then the user does in-place
     * navigation (via the history.pushState() API) to PageB, then navigates back to PageA, and finally
     * they close the browser tab. During this sequence, the applicationId will remain the same, however
     * the pageId will change on each navigation.  The 3 different pageId values are used by the diagnostics
     * e.g. to track success/failure statistics for PageA independently of PageB.
     *
     * The concept of a page is subjective and defined by the router for a particular application.
     */
    static readonly pageId: Guid;
}

/**
 * The purpose of this class is to help make the SharePoint framework errors more robust.
 * On top of the base Error class functionality, this class adds the concept of error codes.
 * The error code could be a non-localized immutable string or an error number. All the
 * SharePoint framework code is expected to use this class for raising errors.
 *
 * References:
 *
 * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error}
 *
 * {@link http://stackoverflow.com/questions/1382107/whats-a-good-way-to-extend-error-in-javascript}
 *
 * @alpha
 */
export declare class SPError extends Error {
    /**
     * Inner error.
     */
    innerError: Error | undefined;
    /**
     * Error id.
     * e.g. Value of the enum.
     */
    readonly id: number;
    /**
     * Error category.
     */
    readonly category: string;
    private _errorCode;
    private _errorString;
    private _logProperties;
    private static _generateErrorStackForIE;
    /**
     * Constructor for the SPError class.
     *
     * @param errorCode - a numeric or string error code.
     * @param message - detailed error message.
     * @param logData - (optional) additional data that can be used to troubleshoot rare to repro bugs.
     *
     */
    constructor(errorCode: string, message: string, logProperties?: {
        [key: string]: any;
    });
    /**
     * Return a string equivalent of the error for display purposes.
     *
     * @returns string representation of the error.
     */
    toStringForUI(): string;
    /**
     * Return a string equivalent of the error for logging purposes.
     *
     * @returns string representation of the error.
     */
    toString(): string;
    /**
     * Return a string equivalent of the error for logging or display purposes.
     *
     * @returns string representation of the error.
     */
    _toString(logDebug?: boolean): string;
}

/**
 * Represents a framework event that components can subscribe to.
 *
 * @remarks
 * Examples of events in a web application might include: the user clicking a button, the system navigating to
 * another page, or an item being added/removed from an abstract collection.  The SharePoint Framework
 * represents events using instances of the SPEvent object, one for each kind of event.  The SPEvent object
 * is typically exposed as a property of an associated class (e.g. the button that can be clicked).
 * When a component is interested in an event, it calls add() to register an event handler callback that
 * will be invoked each time the event occurs.  The handler receives an SPEventArgs parameter that may
 * provide additional details about what happened.  This is analogous to the browser's Document Object Model
 * (DOM) events.  The main difference is the ISPEventObserver feature, which tracks which component subscribed
 * to each event, and automatically unsubscribes the handler when the component is disposed.
 *
 * When an event is raised, all handlers are invoked synchronously.  The order in which event handlers
 * are called is unspecified.  The event handler callback must catch any exceptions that occur during
 * processing; an uncaught exception will not prevent other handlers from executing, but it will be
 * reported as a problem with the associated component.
 *
 * @public
 */
export declare class SPEvent<TEventArgs extends SPEventArgs> {
    private _name;
    /**
     * @internal
     */
    constructor(name: string);
    /**
     * Registers a callback that will be invoked whenever the event occurs.
     *
     * @remarks
     * The same object can add multiple event handlers to the same event. Since BaseComponent implements
     * the ISPEventObserver interface, a web part or extension can pass itself as the observer. This will cause
     * the event handler to be automatically unsubscribed when the web part or extension is disposed.
     *
     * @param observer - Indicates the object that is subscribing to the event: When the object is disposed,
     *   the event handler will be automatically removed.  This object is also used for diagnostic purposes,
     *   e.g. detecting if the event handler failed to catch an exception.
     * @param eventHandler - A callback function that will be invoked whenever the event occurs
     */
    add(observer: ISPEventObserver, eventHandler: (eventArgs: TEventArgs) => void): void;
    /**
     * Unregisters a callback that was registered using add().
     *
     * @remarks
     * If the event handler has already been removed, or if it was never added, then this
     * method has no effect.
     *
     * @param observer - This must be the same observer that was passed to the add() function.
     * @param eventHandler - The event handler to remove; this must be the same object instance
     *   that was passed to the add() function.
     */
    remove(observer: ISPEventObserver, eventHandler: (eventArgs: TEventArgs) => void): void;
    /**
     * Returns the number of listeners to the event
     * @internal
     */
    _listenerCount(): number;
}

/**
 * The base class for event arguments used with the {@link SPEvent} class.
 *
 * @remarks
 * If certain event types need to provide additional details, they will define a
 * subclass of SPEventArgs.
 *
 * @public
 */
export declare class SPEventArgs {
}

/**
 * Manager for the eventing system.
 *
 * Allows to register/unregister event handlers to events, and raises those events.
 * The events are identified by its name as a string, and it doesn't provide type safety for the event arguments.
 *
 * There are two types of events: regular and sticky.
 * Sticky events are events that once raised, every listener that subscribed to the event will be automatically
 * executed as if the event was raised.
 * Sticky events are useful for framework-level notification, like when a system is initialized (every listener will
 * know the system is initialized).
 *
 * This is an internal architecture underlying the SPEvent class, which provides a handy way to register and unregister
 * events, and provides the type safety. This class should not be exposed to third-parties directly.
 *
 * @internal
 */
export declare class _SPEventManager {
    private static _logSource;
    private static _instance;
    private _listeners;
    private _raisedEvents;
    /**
     * Instance of the SPEventManager.
     */
    static readonly instance: _SPEventManager;
    constructor();
    /**
     * Raises an event.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     * @alpha
     */
    raiseEvent<TEventArgs>(eventName: string, eventArgs: TEventArgs): void;
    /**
     * Raises a sticky event.
     * Sticky events are stored, so when new listeners are added to the event, they will be immediately notified.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     * @alpha
     */
    raiseStickyEvent<TEventArgs>(eventName: string, eventArgs: TEventArgs): void;
    /**
     * Registers an event handler for an event.
     * @param eventName - Name of the event to register to.
     * @param observer - Component that is registering the event.
     * @param eventHandler - Function to handle the event.
     */
    registerEvent<TEventArgs>(eventName: string, observer: ISPEventObserver, eventHandler: (eventArgs: TEventArgs) => void): void;
    /**
     * Removes an event handler from the event listeners list.
     * The event handler passed as input must be the first one that was used to register to the event.
     *
     * @remarks
     * If this is requested without adding an event handler first, it logs an error.
     *
     * @param eventName - Name of the event to remove the event handler from.
     * @param observer - Component that is deregistering from the event.
     * @param eventHandler - Function to handle the event. Used to remove it from the list of listeners.
     */
    unregisterEvent<TEventArgs>(eventName: string, observer: ISPEventObserver, eventHandler: (eventArgs: TEventArgs) => void): void;
    /**
     * Removes all information from an event from the Event Manager, including all listeners.
     *
     * @param eventName - Name of the event to remove.
     */
    removeEvent(eventName: string): void;
    /**
     * Removes all information for all events whose id starts with the provided prefix from the Event Manager.
     * This removes all listeners for all events that match.
     *
     * @param eventNamePrefix - Prefix for the event names.
     */
    removeEventsByPrefix(eventNamePrefix: string): void;
    /**
     * Returns the number of listeners for a particular event
     *
     * @internal
     */
    _listenerCount(eventName: string): number;
    /**
     * Private function to raise an event.
     * This include the shared functionality between raising sticky and regular events.
     *
     * After this is called, all components registered under the event will execute their callback.
     * @param eventName - Name of the event
     * @param eventArgs - Arguments of the event
     */
    private _raiseEventInternal;
}

/**
 * @copyright Microsoft Corporation. All rights reserved.
 */
/**
 * NOT FOR USE BY THIRD PARTY DEVELOPERS
 *
 * This class supports Microsoft's internal deployment workflow.
 * For more information, see https://microsoft.sharepoint.com/teams/odsp/_layouts/OneNote.aspx
 * ?id=/teams/odsp/Shared%20Documents/MI-6%20Team/MI-6%20Team/Global/SPO%20Flighting
 *
 * @privateRemarks
 * SPFlight is currently being reexported by sp-client-base.  For GA, this will be sorted out by
 * VSO 278235 which will move this class back into sp-client-base (sp-core-library).
 *
 * @internal
 */
export declare class _SPFlight {
    private static _isInitialized;
    /**
     * List of SharePoint flight feature IDs that are forced to be enabled
     * through the debugFlights query string parameter.
     */
    private static _forceEnabledFlights;
    /**
     * List of SharePoint flight feature IDs that are forced to be disabled
     * through the debugFlights query string parameter.
     */
    private static _forceDisabledFlights;
    /**
     * Array of bits (indexed by flight number, where 1 means that flight is enabled).
     */
    private static _enabledFlightsMap;
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    static initialize(flights: number[]): void;
    /**
     * Return true if the debug flight is enabled.
     */
    static readonly isDebugFlightEnabled: boolean;
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    static setDebugFlights(debugFlights?: string): void;
    /**
     * NOT FOR USE BY THIRD PARTY DEVELOPERS
     *
     * This function will determine if a flight is enabled in the global list.
     */
    static isEnabled(flight: number): boolean;
    private static _validateDebugFlights;
}

/**
 * This class supports Microsoft's internal deployment workflow.
 *
 * @internal
 */
export declare class _SPKillSwitch {
    private static _isInitialized;
    private static _activatedKillSwitches;
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    static initialize(killSwitchGuids: {
        [key: string]: boolean;
    }): void;
    /**
     * RESERVED FOR INTERNAL USAGE.  This method is invoked automatically by the system shell.
     * The application code should not call it directly.
     */
    static setDebugKillswitches(debugKillswitches?: string): void;
    /**
     * Returns true if the switch is activated.
     * @param killSwitchGuid - identifier for the kill switch
     * @param date - This parameter does not impact return value of the function.  It
     *        documents the date when the kill switch was introduced, to facilitate bulk cleanup.
     *        The date should be updated if additional fixes are made inside the block.
     * @param featureName - This parameter does not impact return value of the function.
     *        It is an informational tag to facilitate bulk cleanup, e.g. by allowing teams
     *        to search for switches related to their feature.
     * @returns true if the switch is activated, i.e. we should revert to the old behavior
     */
    static isActivated(killSwitchGuid: Guid, date: string, featureName: string): boolean;
}

/**
 * Operations for working with strings that contain text.
 *
 * @remarks
 * The utilities provided by this class are intended to be simple, small, and very
 * broadly applicable.
 *
 * @public
 */
export declare class Text {
    private static FORMAT_REGEX;
    private static FORMAT_ARGS_REGEX;
    /**
     * Format a string by substituting parameters.
     *
     * @remarks
     * This function replaces template parameters such as `"{0}"` or `"{1}"` with the
     * corresponding argument.  If the value is null or undefined, it will be replaced
     * by the word `"null"` or `"undefined"`.  The format string s must not be null or
     * undefined.
     *
     * Usage example:
     *
     * `Text.format("hello {0}!", "world")` will return `"hello world!"`
     */
    static format(s: string, ...values: any[]): string;
    /**
     * Returns the input string, with all instances of `searchValue` replaced by `replaceValue`.
     *
     * @remarks
     * Note that JavaScript's `string.replace()` only replaces the first match, unless a
     * global RegExp is provided.
     *
     * @param input         - The string to be modified
     * @param searchValue   - The value to search for
     * @param replaceValue  - The replacement text
     */
    static replaceAll(input: string, searchValue: string, replaceValue: string): string;
}

/**
 * This is the default implementation of {@link ITimeProvider} that simply
 * calls the real browser APIs.
 *
 * @public
 */
export declare class TimeProvider implements ITimeProvider {
    /**
     * The service key for ITimeProvider.
     */
    static readonly serviceKey: ServiceKey<ITimeProvider>;
    constructor(serviceScope: ServiceScope);
    /** {@inheritDoc ITimeProvider.getDate} */
    getDate(): Date;
    /** {@inheritDoc ITimeProvider.getTimestamp} */
    getTimestamp(): number;
}

/**
 * @Copyright (c) Microsoft Corporation.  All rights reserved.
 */
/**
 * Provides features for storing and retrieving URL query parameters.
 *
 * @remarks
 * The URL can be server-relative, and it can also be an empty or null string.
 * The query parameters must start with "?" to indicate the first query parameter and
 * use "&" for all subsequent parameters. The class also supports fragments.
 *
 * Edge case behavior:
 *
 * Empty value (www.example.com/?test=) stores key and empty value
 * No equals in queryParam (www.example.com/?test) stores key and undefined value
 * Empty queryParam (www.example.com/?&debug=on) stores undefined key and value
 * Query param with only equals (www.example.com/?=&debug=on stores empty string key and value
 *
 * @privateRemarks
 * The design of this class was that it could split the URL out into a data structure, and the user
 * could add items to the data structure (TBD), and then another (TBD) function would rebuild the URL.
 * This weird design would ensure that e.g. if no change was made to the data structure, then the
 * round trip wouldn't change the characters in the URL at all, which might be useful e.g. if we're
 * comparing URLs.
 *
 * @deprecated Use the URLSearchParams browser API instead.  The SharePoint Framework includes a
 * polyfill for older browsers.
 * @public
 */
export declare class UrlQueryParameterCollection {
    private _queryParameterList;
    constructor(url: string);
    /**
     * Returns the value of the first matching query parameter or undefined if the key doesn't exist.
     *
     * @remarks
     * Examples:
     * ```
     * this._queryParameterList = [
     * {key: TEST, value: done},
     * {key: DEBUG, value: false},
     * {key: TEST, value: notdone}]
     *   getValue('TEST') ---> 'done'
     *   getValue('debug')  ---> 'false'
     *   getValue('lost')  ---> undefined
     * ```
     * @param param - the case insensitive key for the desired query parameter value.
     */
    getValue(param: string): string | undefined;
    /**
     * Returns the values of all of the matching query parameters or undefined if the key doesn't exist.
     *
     * @remarks
     * Examples:
     * ```
     * this._queryParameterList = [
     * {key: TEST, value: done},
     * {key: DEBUG, value: false},
     * {key: TEST, value: notdone}]
     *   getValues('TEST') ---> ['done', 'notdone']
     *   getValues('debug')  ---> ['false']
     *   getValues('lost')  ---> undefined
     * ```
     * @param param - the case insensitive key for the desired query parameter value.
     */
    getValues(param: string): (string | undefined)[] | undefined;
    private _getUrlQueryParameterArray;
}

/**
 * Common helper functions for working with URLs.  These utilities are intended to be simple,
 * small, and very broadly applicable.
 *
 * @alpha
 */
export declare class UrlUtilities {
    /**
     * If the provided URL is relative, resolve it under the provided base URL. If the provided URL is absolute,
     * return it.
     *
     * @remarks
     * Examples:
     * ```
     *   resolve('/foo/bar.js', 'http://cdn.com/path/')               ---> 'http://cdn.com/path/foo/bar.js'
     *   resolve('http://cdn.com/foo/bar.js', 'http://cdn.com/path/') ---> 'http://cdn.com/foo/bar.js'
     *   resolve('/foo/bar.js', 'path/')                              ---> 'path/foo/bar.js'
     * ```
     * @param url - the URL to be resolved
     * @param baseUrl - the base URL to use if the URL is relative
     */
    static resolve(url: string, baseUrl: string): string;
    /**
     * Removes any slash characters from the end of the URL.
     *
     * @remarks
     * This function assumes that the input is already a valid absolute or server-relative URL.
     *
     * Examples:
     * ```
     *   removeEndSlash('http://example.com/') ---> 'http://example.com'
     *   removeEndSlash('/example')            ---> '/example'
     *   removeEndSlash('/')                   ---> ''
     * ```
     * @param url - the URL to be normalized
     */
    static removeEndSlash(url: string): string;
    /**
     * Removes any slash characters from the beginning of the URL.
     *
     * @remarks
     * This function assumes that the input is already a valid absolute or server-relative URL.
     *
     * Examples:
     * ```
     *   removeLeadingSlash('/example/path.js') ---> 'example/path.js'
     *   removeLeadingSlash('example/')         ---> 'example/'
     *   removeLeadingSlash('/')                ---> ''
     * ```
     * @param url - the URL to be normalized
     */
    static removeLeadingSlash(url: string): string;
    /**
     * Converts a variable to an OData string literal suitable for usage in a REST URL.
     *
     * @remarks
     * The returned string will be enclosed in single quotes, and any single quotes
     * will be escaped.
     *
     * Example usage:
     *
     * ```
     * const url = "/_api/web/GetFolderByServerRelativeUrl("
     *       + UrlUtilities.convertToODataStringLiteral("/SitePages/Alice's%20Page")
     *       + ")/Files";
     *
     *  // Produces this URL:
     *  // "/_api/web/GetFolderByServerRelativeUrl('/SitePages/Alice''s%20Page')/Files"
     * ```
     *
     * @privateRemarks
     * Standard reference:
     * https://tools.oasis-open.org/version-control/
     *   browse/wsvn/odata/trunk/spec/ABNF/odata-abnf-construction-rules.txt
     * SQUOTE-in-string = SQUOTE SQUOTE ; two consecutive single quotes represent
     *   one within a string literal
     */
    static convertToODataStringLiteral(value: string): string;
    /**
     * Detects if a string represents a correctly formatted data URL.
     *
     * @remarks
     *
     * Examples:
     * ```
     *   isDataUrl('data:text/plain;base64,SGVsbG8sIFdvcmxkIQ%3D%3D') ---> true
     *   isDataUrl('data:,Hello%2C%20World!')                         ---> true
     *   isDataUrl('data:image/png;base64,iVBORw0KGgoAA')             ---> true
     *   isDataUrl('http://contoso.com')                              ---> false
     *   isDataUrl('/foo/bar')                                        ---> false
     * ```
     *
     * Information on data URLs can be found at https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs
     */
    static isDataUrl(url: string): boolean;
    /**
     * Detects if a url is relative
     *
     * @remarks
     * This function assumes that the input is already a valid absolute or server-relative URL.
     *
     * Examples:
     * ```
     *   isRelativeUrl('/example/path.aspx')  ---> true
     *   isRelativeUrl('http://contoso.com')  ---> false
     * ```
     */
    static isRelativeUrl(url: string): boolean;
}

/**
 * Performs common validation tests for properties and function parameters.
 *
 * @remarks
 *
 * This class implements provides a standard way to validate properties and function parameters.
 * Unlike debug assertions, Validate checks are always performed and will always throw an error,
 * even in a production release.  As such, be careful not to overuse these checks in a way
 * that might impact performance.
 *
 * @public
 */
export declare class Validate {
    /**
     * Throws an exception if the specified value is not true.
     * @param value - the value to check
     * @param variableName - the program variable name, which will be mentioned in the error message
     */
    static isTrue(value: boolean | undefined | null, variableName: string): void;
    /**
     * Throws an exception if the specified value is null or undefined.
     * @param value - the value to check
     * @param variableName - the program variable name, which will be mentioned in the error message
     */
    static isNotNullOrUndefined(value: any, variableName: string): void;
    /**
     * Throws an exception if the specified string is null, undefined, or an empty string.
     * @param value - the value to check
     * @param variableName - the program variable name, which will be mentioned in the error message
     */
    static isNonemptyString(value: string | undefined | null, variableName: string): void;
    /**
     * Throws an exception if the specified object has been disposed.
     * @param value - the value to check
     * @param className - the class name, which will be mentioned in the error message
     */
    static isNotDisposed(value: IDisposable, className: string): void;
}

/**
 * Represents a version number with two, three, or four parts.
 *
 * @remarks
 * This class represents versions that follow the string format of `MAJOR.MINOR[.PATCH[.REVISION]]`
 * where the MAJOR, MINOR, PATCH and REVISION parts are integers. PATCH and REVISION are optional.
 * Leading zero digits are allowed, but they are discarded.  Missing parts are treated
 * as zeroes for comparisons.
 *
 * Examples: `1.0`, `1.0.0`, `1.0.0.0`, `1.01`, `01.02.03`, `001.002.003.004`
 *
 * @public
 */
export declare class Version {
    private _major;
    private _minor;
    private _patch;
    private _revision;
    /**
     * Test whether a string is a valid version specifier.
     *
     * @param versionString - The version string
     * @returns true if the versionString is a valid version specifier
     */
    static isValid(versionString: string | undefined | null): boolean;
    /**
     * Constructs a new Version instance using the version string.  An exception is thrown
     * if the string cannot be parsed.
     *
     * @param versionString - A version string
     * @returns a new Version object
     */
    static parse(versionString: string | undefined | null): Version;
    /**
     * Attempts to parse the input string to construct a new Version object.
     * If the string cannot be parsed, then undefined is returned.
     *
     * @param versionString - A version string
     * @returns The Version object, or undefined if the string could not be parsed.
     */
    static tryParse(versionString: string | undefined | null): Version | undefined;
    /**
     * Compares two Version objects to determine which version is newer.
     *
     * @param v1 - The first version class for comparison
     * @param v2 - The second version class for comparison
     * @returns  -1 if the first input is less than the second input;
     *            0 if the first input is equal to the second input;
     *            1 if the first input is greater than the second input.
     */
    static compare(v1: Version, v2: Version): number;
    /**
     * Returns the first component of the version string.
     *
     * @remarks
     * Typically a change in the major version number indicates a compatibility
     * break with previous versions.
     */
    readonly major: number;
    /**
     * Returns the second component of the version string.
     *
     * @remarks
     * Typically a change in the minor version number indicates that new features
     * were added, while remaining backwards compatible with previous releases.
     */
    readonly minor: number;
    /**
     * The third number in the version string, or undefined if unspecified.
     *
     * @remarks
     * Typically a change in the patch version number indicates a small fix that
     * does not affect the compatibility contract for the library.  For a .NET
     * System.Version object, this is referred to as the "build" number.
     */
    readonly patch: number | undefined;
    /**
     * The fourth number in the version string, or undefined if unspecified.
     *
     * @remarks
     * This number is not part of the Semantic Versioning (SemVer) standard used
     * in JavaScript, but it is used by .NET version numbers.
     */
    readonly revision: number | undefined;
    /**
     * Tests whether this version is less than (i.e. older than) the input parameter.
     *
     * @remarks
     *
     * Examples:
     *
     * ```
     * 0.9.9 lessThan 1.0.0 -> true;
     * 2.0   lessThan 2.0.0 -> false;
     * 3.0   lessThan 3.0.1 -> true;
     * 04.01 lessThan 4.1   -> false
     * ```
     *
     * @param compareWith - The version to compare with
     * @returns A boolean indicating if this version is less than the input parameter
     */
    lessThan(compareWith: Version): boolean;
    /**
     * Tests whether this version is greater than (i.e. newer than) the input parameter.
     *
     * @remarks
     *
     * Examples:
     *
     * ```
     * 1.0.0 greaterThan 0.0.9 -> true;
     * 2.0   greaterThan 2.0.0 -> false;
     * 3.0.1 greaterThan 3.0   -> true
     * ```
     *
     * @param compareWith - The version to compare with
     * @returns A boolean indicating if this version is greater than the input parameter
     */
    greaterThan(compareWith: Version): boolean;
    /**
     * Tests whether this version is equal to the input parameter.
     *
     * @remarks
     *
     * Examples:
     *
     * ```
     * 1.0.0 equals 1.0.0 -> true;
     * 2.0.1 equals 2.0.0 -> false;
     * 3.0   equals 3.0.0 -> true;
     * 04.01 equals 4.1   -> true
     * ```
     *
     * @param compareWith - The version to compare with
     * @returns A boolean indicating if this version is equal to the input parameter
     */
    equals(compareWith: Version): boolean;
    /**
     * Tests whether this version satisfies the compatibility requirements of the input version,
     * i.e. is backwards compatible.
     *
     * @remarks
     * In order to satisfy the compatibility requirements, this object must have the same
     * major version number as the input parameter, and it must NOT be older than the
     * input parameter.
     *
     * Examples:
     *
     * ```
     * 1.0.0 satisfies 1.0.0 -> true;
     * 1.1.0 satisfies 1.0.0 -> true;
     * 2.0.0 satisfies 1.0.0 -> false;
     * 1.0.0 satisfies 1.1.0 -> false
     * ```
     *
     * @param compareWith - The version to compare with
     * @returns A boolean indicating if this version is compatible with the input parameter
     */
    satisfies(compareWith: Version): boolean;
    /**
     * Returns a string representation of the version.
     *
     * @remarks
     * The value is normalized and may be different from the original string (e.g. leading zeroes
     * may be removed).  However, the number of version parts will be unchanged.
     */
    toString(): string;
    /**
     * WARNING: Use Version.tryParse instead of the constructor. The constructor does not do any validation.
     *
     * @param major - the major version
     * @param minor - the minor version
     * @param patch - the patch number
     * @param revision - the revision number
     */
    private constructor();
}

export { }
