"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.
// See LICENSE in the project root for license information.
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const path = require("path");
const tsdoc = require("@microsoft/tsdoc");
const node_core_library_1 = require("@microsoft/node-core-library");
const TypeScriptMessageFormatter_1 = require("../analyzer/TypeScriptMessageFormatter");
const CollectorEntity_1 = require("./CollectorEntity");
const AstSymbolTable_1 = require("../analyzer/AstSymbolTable");
const AstSymbol_1 = require("../analyzer/AstSymbol");
const ReleaseTag_1 = require("../aedoc/ReleaseTag");
const TypeScriptHelpers_1 = require("../analyzer/TypeScriptHelpers");
const WorkingPackage_1 = require("./WorkingPackage");
const PackageDocComment_1 = require("../aedoc/PackageDocComment");
const DeclarationMetadata_1 = require("./DeclarationMetadata");
const SymbolMetadata_1 = require("./SymbolMetadata");
const TypeScriptInternals_1 = require("../analyzer/TypeScriptInternals");
/**
 * The `Collector` manages the overall data set that is used by `ApiModelGenerator`,
 * `DtsRollupGenerator`, and `ReviewFileGenerator`.  Starting from the working package's entry point,
 * the `Collector` collects all exported symbols, determines how to import any symbols they reference,
 * assigns unique names, and sorts everything into a normalized alphabetical ordering.
 */
class Collector {
    constructor(options) {
        this._entities = [];
        this._entitiesByAstEntity = new Map();
        this._starExportedExternalModulePaths = [];
        this._dtsTypeReferenceDirectives = new Set();
        this._dtsLibReferenceDirectives = new Set();
        this.packageJsonLookup = new node_core_library_1.PackageJsonLookup();
        this.policies = options.policies;
        this.validationRules = options.validationRules;
        this.logger = options.logger;
        this._program = options.program;
        const packageFolder = this.packageJsonLookup.tryGetPackageFolderFor(options.entryPointFile);
        if (!packageFolder) {
            throw new Error('Unable to find a package.json for entry point: ' + options.entryPointFile);
        }
        const packageJson = this.packageJsonLookup.tryLoadPackageJsonFor(packageFolder);
        const entryPointSourceFile = options.program.getSourceFile(options.entryPointFile);
        if (!entryPointSourceFile) {
            throw new Error('Unable to load file: ' + options.entryPointFile);
        }
        this.workingPackage = new WorkingPackage_1.WorkingPackage({
            packageFolder,
            packageJson,
            entryPointSourceFile
        });
        this.program = options.program;
        this.typeChecker = options.program.getTypeChecker();
        this._tsdocParser = new tsdoc.TSDocParser();
        this.astSymbolTable = new AstSymbolTable_1.AstSymbolTable(this.program, this.typeChecker, this.packageJsonLookup, this.logger);
    }
    /**
     * Returns a list of names (e.g. "example-library") that should appear in a reference like this:
     *
     * ```
     * /// <reference types="example-library" />
     * ```
     */
    get dtsTypeReferenceDirectives() {
        return this._dtsTypeReferenceDirectives;
    }
    /**
     * A list of names (e.g. "runtime-library") that should appear in a reference like this:
     *
     * ```
     * /// <reference lib="runtime-library" />
     * ```
     */
    get dtsLibReferenceDirectives() {
        return this._dtsLibReferenceDirectives;
    }
    get entities() {
        return this._entities;
    }
    /**
     * A list of module specifiers (e.g. `"@microsoft/node-core-library/lib/FileSystem"`) that should be emitted
     * as star exports (e.g. `export * from "@microsoft/node-core-library/lib/FileSystem"`).
     */
    get starExportedExternalModulePaths() {
        return this._starExportedExternalModulePaths;
    }
    /**
     * Perform the analysis.
     */
    analyze() {
        if (this._astEntryPoint) {
            throw new Error('DtsRollupGenerator.analyze() was already called');
        }
        // This runs a full type analysis, and then augments the Abstract Syntax Tree (i.e. declarations)
        // with semantic information (i.e. symbols).  The "diagnostics" are a subset of the everyday
        // compile errors that would result from a full compilation.
        for (const diagnostic of this._program.getSemanticDiagnostics()) {
            const errorText = TypeScriptMessageFormatter_1.TypeScriptMessageFormatter.format(diagnostic.messageText);
            this.reportError(`TypeScript: ${errorText}`, diagnostic.file, diagnostic.start);
        }
        // Build the entry point
        const astEntryPoint = this.astSymbolTable.fetchAstModuleFromWorkingPackage(this.workingPackage.entryPointSourceFile);
        this._astEntryPoint = astEntryPoint;
        const packageDocCommentTextRange = PackageDocComment_1.PackageDocComment.tryFindInSourceFile(this.workingPackage.entryPointSourceFile, this);
        if (packageDocCommentTextRange) {
            const range = tsdoc.TextRange.fromStringRange(this.workingPackage.entryPointSourceFile.text, packageDocCommentTextRange.pos, packageDocCommentTextRange.end);
            this.workingPackage.tsdocParserContext = this._tsdocParser.parseRange(range);
            this.workingPackage.tsdocComment = this.workingPackage.tsdocParserContext.docComment;
        }
        const exportedAstEntities = [];
        // Create a CollectorEntity for each top-level export
        const astModuleExportInfo = this.astSymbolTable.fetchAstModuleExportInfo(astEntryPoint);
        for (const [exportName, astEntity] of astModuleExportInfo.exportedLocalEntities) {
            this._createCollectorEntity(astEntity, exportName);
            exportedAstEntities.push(astEntity);
        }
        // Create a CollectorEntity for each indirectly referenced export.
        // Note that we do this *after* the above loop, so that references to exported AstSymbols
        // are encountered first as exports.
        const alreadySeenAstSymbols = new Set();
        for (const exportedAstEntity of exportedAstEntities) {
            this._createEntityForIndirectReferences(exportedAstEntity, alreadySeenAstSymbols);
            if (exportedAstEntity instanceof AstSymbol_1.AstSymbol) {
                this.fetchMetadata(exportedAstEntity);
            }
        }
        this._makeUniqueNames();
        for (const starExportedExternalModule of astModuleExportInfo.starExportedExternalModules) {
            if (starExportedExternalModule.externalModulePath !== undefined) {
                this._starExportedExternalModulePaths.push(starExportedExternalModule.externalModulePath);
            }
        }
        node_core_library_1.Sort.sortBy(this._entities, x => x.getSortKey());
        node_core_library_1.Sort.sortSet(this._dtsTypeReferenceDirectives);
        node_core_library_1.Sort.sortSet(this._dtsLibReferenceDirectives);
        this._starExportedExternalModulePaths.sort();
    }
    /**
     * For a given ts.Identifier that is part of an AstSymbol that we analyzed, return the CollectorEntity that
     * it refers to.  Returns undefined if it doesn't refer to anything interesting.
     * @remarks
     * Throws an Error if the ts.Identifier is not part of node tree that was analyzed.
     */
    tryGetEntityForIdentifierNode(identifier) {
        const astEntity = this.astSymbolTable.tryGetEntityForIdentifierNode(identifier);
        if (astEntity) {
            return this._entitiesByAstEntity.get(astEntity);
        }
        return undefined;
    }
    fetchMetadata(symbolOrDeclaration) {
        if (symbolOrDeclaration.metadata === undefined) {
            const astSymbol = symbolOrDeclaration instanceof AstSymbol_1.AstSymbol
                ? symbolOrDeclaration : symbolOrDeclaration.astSymbol;
            this._fetchSymbolMetadata(astSymbol);
        }
        return symbolOrDeclaration.metadata;
    }
    tryFetchMetadataForAstEntity(astEntity) {
        if (astEntity instanceof AstSymbol_1.AstSymbol) {
            return this.fetchMetadata(astEntity);
        }
        if (astEntity.astSymbol) { // astImport
            return this.fetchMetadata(astEntity.astSymbol);
        }
        return undefined;
    }
    /**
     * Removes the leading underscore, for example: "_Example" --> "example*Example*_"
     *
     * @remarks
     * This causes internal definitions to sort alphabetically case-insensitive, then case-sensitive, and
     * initially ignoring the underscore prefix, while still deterministically comparing it.
     * The star is used as a delimiter because it is not a legal  identifier character.
     */
    static getSortKeyIgnoringUnderscore(identifier) {
        let parts;
        if (identifier[0] === '_') {
            const withoutUnderscore = identifier.substr(1);
            parts = [withoutUnderscore.toLowerCase(), '*', withoutUnderscore, '*', '_'];
        }
        else {
            parts = [identifier.toLowerCase(), '*', identifier];
        }
        return parts.join('');
    }
    _createCollectorEntity(astEntity, exportedName) {
        let entity = this._entitiesByAstEntity.get(astEntity);
        if (!entity) {
            entity = new CollectorEntity_1.CollectorEntity(astEntity);
            this._entitiesByAstEntity.set(astEntity, entity);
            this._entities.push(entity);
            if (astEntity instanceof AstSymbol_1.AstSymbol) {
                this._collectReferenceDirectives(astEntity);
            }
        }
        if (exportedName) {
            entity.addExportName(exportedName);
        }
    }
    _createEntityForIndirectReferences(astEntity, alreadySeenAstEntities) {
        if (alreadySeenAstEntities.has(astEntity)) {
            return;
        }
        alreadySeenAstEntities.add(astEntity);
        if (astEntity instanceof AstSymbol_1.AstSymbol) {
            astEntity.forEachDeclarationRecursive((astDeclaration) => {
                for (const referencedAstEntity of astDeclaration.referencedAstEntities) {
                    if (referencedAstEntity instanceof AstSymbol_1.AstSymbol) {
                        // We only create collector entities for root-level symbols.
                        // For example, if a symbols is nested inside a namespace, only the root-level namespace
                        // get a collector entity
                        if (referencedAstEntity.parentAstSymbol === undefined) {
                            this._createCollectorEntity(referencedAstEntity, undefined);
                        }
                    }
                    else {
                        this._createCollectorEntity(referencedAstEntity, undefined);
                    }
                    this._createEntityForIndirectReferences(referencedAstEntity, alreadySeenAstEntities);
                }
            });
        }
    }
    /**
     * Ensures a unique name for each item in the package typings file.
     */
    _makeUniqueNames() {
        const usedNames = new Set();
        this._collectGlobalNames(usedNames);
        // First collect the explicit package exports (named)
        for (const entity of this._entities) {
            for (const exportName of entity.exportNames) {
                if (usedNames.has(exportName)) {
                    // This should be impossible
                    throw new node_core_library_1.InternalError(`A package cannot have two exports with the name "${exportName}"`);
                }
                usedNames.add(exportName);
            }
        }
        // Next generate unique names for the non-exports that will be emitted (and the default export)
        for (const entity of this._entities) {
            // If this entity is exported exactly once, then emit the exported name
            if (entity.singleExportName !== undefined && entity.singleExportName !== ts.InternalSymbolName.Default) {
                entity.nameForEmit = entity.singleExportName;
                continue;
            }
            // If the localName happens to be the same as one of the exports, then emit that name
            if (entity.exportNames.has(entity.astEntity.localName)) {
                entity.nameForEmit = entity.astEntity.localName;
                continue;
            }
            // In all other cases, generate a unique name based on the localName
            let suffix = 1;
            let nameForEmit = entity.astEntity.localName;
            while (usedNames.has(nameForEmit)) {
                nameForEmit = `${entity.astEntity.localName}_${++suffix}`;
            }
            entity.nameForEmit = nameForEmit;
            usedNames.add(nameForEmit);
        }
    }
    /**
     * Adds global names to the usedNames set, to prevent API Extractor from emitting names that conflict with
     * a global name.
     */
    _collectGlobalNames(usedNames) {
        // As a temporary workaround, this a short list of names that appear in typical projects.
        // The full solution is tracked by this issue:
        // https://github.com/Microsoft/web-build-tools/issues/1095
        const globalNames = [
            'Array',
            'ArrayConstructor',
            'Console',
            'Date',
            'DateConstructor',
            'Error',
            'ErrorConstructor',
            'Float32Array',
            'Float32ArrayConstructor',
            'Float64Array',
            'Float64ArrayConstructor',
            'IArguments',
            'Int16Array',
            'Int16ArrayConstructor',
            'Int32Array',
            'Int32ArrayConstructor',
            'Int8Array',
            'Int8ArrayConstructor',
            'Iterable',
            'IterableIterator',
            'Iterator',
            'IteratorResult',
            'Map',
            'MapConstructor',
            'Promise',
            'PromiseConstructor',
            'ReadonlyArray',
            'ReadonlyMap',
            'ReadonlySet',
            'Set',
            'SetConstructor',
            'String',
            'Symbol',
            'SymbolConstructor',
            'Uint16Array',
            'Uint16ArrayConstructor',
            'Uint32Array',
            'Uint32ArrayConstructor',
            'Uint8Array',
            'Uint8ArrayConstructor',
            'Uint8ClampedArray',
            'Uint8ClampedArrayConstructor',
            'WeakMap',
            'WeakMapConstructor',
            'WeakSet',
            'WeakSetConstructor',
            'clearInterval',
            'clearTimeout',
            'console',
            'setInterval',
            'setTimeout',
            'undefined'
        ];
        for (const globalName of globalNames) {
            usedNames.add(globalName);
        }
    }
    /**
     * Reports an error message to the registered ApiErrorHandler.
     */
    reportError(message, sourceFile, start) {
        if (sourceFile && start) {
            const lineAndCharacter = sourceFile.getLineAndCharacterOfPosition(start);
            // If the file is under the packageFolder, then show a relative path
            const relativePath = path.relative(this.workingPackage.packageFolder, sourceFile.fileName);
            const shownPath = relativePath.substr(0, 2) === '..' ? sourceFile.fileName : relativePath;
            // Format the error so that VS Code can follow it.  For example:
            // "src\MyClass.ts(15,1): The JSDoc tag "@blah" is not supported by AEDoc"
            this.logger.logError(`${shownPath}(${lineAndCharacter.line + 1},${lineAndCharacter.character + 1}): `
                + message);
        }
        else {
            this.logger.logError(message);
        }
    }
    _fetchSymbolMetadata(astSymbol) {
        if (astSymbol.metadata) {
            return;
        }
        // When we solve an astSymbol, then we always also solve all of its parents and all of its declarations
        if (astSymbol.parentAstSymbol && astSymbol.parentAstSymbol.metadata === undefined) {
            this._fetchSymbolMetadata(astSymbol.parentAstSymbol);
        }
        for (const astDeclaration of astSymbol.astDeclarations) {
            this._calculateMetadataForDeclaration(astDeclaration);
        }
        // We know we solved parentAstSymbol.metadata above
        const parentSymbolMetadata = astSymbol.parentAstSymbol
            ? astSymbol.parentAstSymbol.metadata : undefined;
        const symbolMetadata = new SymbolMetadata_1.SymbolMetadata();
        // Do any of the declarations have a release tag?
        let effectiveReleaseTag = ReleaseTag_1.ReleaseTag.None;
        for (const astDeclaration of astSymbol.astDeclarations) {
            // We know we solved this above
            const declarationMetadata = astDeclaration.metadata;
            const declaredReleaseTag = declarationMetadata.declaredReleaseTag;
            if (declaredReleaseTag !== ReleaseTag_1.ReleaseTag.None) {
                if (effectiveReleaseTag !== ReleaseTag_1.ReleaseTag.None && effectiveReleaseTag !== declaredReleaseTag) {
                    if (!astSymbol.isExternal) { // for now, don't report errors for external code
                        // TODO: Report error message
                        this.reportError('Inconsistent release tags between declarations', undefined, undefined);
                    }
                }
                else {
                    effectiveReleaseTag = declaredReleaseTag;
                }
            }
        }
        // If this declaration doesn't have a release tag, then inherit it from the parent
        if (effectiveReleaseTag === ReleaseTag_1.ReleaseTag.None && astSymbol.parentAstSymbol) {
            if (parentSymbolMetadata) {
                effectiveReleaseTag = parentSymbolMetadata.releaseTag;
            }
        }
        if (effectiveReleaseTag === ReleaseTag_1.ReleaseTag.None) {
            if (this.validationRules.missingReleaseTags !== "allow" /* allow */) {
                if (!astSymbol.isExternal) { // for now, don't report errors for external code
                    // For now, don't report errors for forgotten exports
                    const entity = this._entitiesByAstEntity.get(astSymbol.rootAstSymbol);
                    if (entity && entity.exported) {
                        // We also don't report errors for the default export of an entry point, since its doc comment
                        // isn't easy to obtain from the .d.ts file
                        if (astSymbol.rootAstSymbol.localName !== '_default') {
                            // TODO: Report error message
                            const loc = astSymbol.rootAstSymbol.localName + ' in '
                                + astSymbol.rootAstSymbol.astDeclarations[0].declaration.getSourceFile().fileName;
                            this.reportError('Missing release tag for ' + loc, undefined, undefined);
                        }
                    }
                }
            }
            effectiveReleaseTag = ReleaseTag_1.ReleaseTag.Public;
        }
        symbolMetadata.releaseTag = effectiveReleaseTag;
        symbolMetadata.releaseTagSameAsParent = false;
        if (parentSymbolMetadata) {
            symbolMetadata.releaseTagSameAsParent = symbolMetadata.releaseTag === parentSymbolMetadata.releaseTag;
        }
        // Update this last when we're sure no exceptions were thrown
        astSymbol.metadata = symbolMetadata;
    }
    _calculateMetadataForDeclaration(astDeclaration) {
        const declarationMetadata = new DeclarationMetadata_1.DeclarationMetadata();
        astDeclaration.metadata = declarationMetadata;
        const parserContext = this._parseTsdocForAstDeclaration(astDeclaration);
        if (parserContext) {
            const modifierTagSet = parserContext.docComment.modifierTagSet;
            let declaredReleaseTag = ReleaseTag_1.ReleaseTag.None;
            let inconsistentReleaseTags = false;
            if (modifierTagSet.isPublic()) {
                declaredReleaseTag = ReleaseTag_1.ReleaseTag.Public;
            }
            if (modifierTagSet.isBeta()) {
                if (declaredReleaseTag !== ReleaseTag_1.ReleaseTag.None) {
                    inconsistentReleaseTags = true;
                }
                else {
                    declaredReleaseTag = ReleaseTag_1.ReleaseTag.Beta;
                }
            }
            if (modifierTagSet.isAlpha()) {
                if (declaredReleaseTag !== ReleaseTag_1.ReleaseTag.None) {
                    inconsistentReleaseTags = true;
                }
                else {
                    declaredReleaseTag = ReleaseTag_1.ReleaseTag.Alpha;
                }
            }
            if (modifierTagSet.isInternal()) {
                if (declaredReleaseTag !== ReleaseTag_1.ReleaseTag.None) {
                    inconsistentReleaseTags = true;
                }
                else {
                    declaredReleaseTag = ReleaseTag_1.ReleaseTag.Internal;
                }
            }
            if (inconsistentReleaseTags) {
                if (!astDeclaration.astSymbol.isExternal) { // for now, don't report errors for external code
                    // TODO: Report error message
                    this.reportError('Inconsistent release tags in doc comment', undefined, undefined);
                }
            }
            declarationMetadata.tsdocParserContext = parserContext;
            declarationMetadata.tsdocComment = parserContext.docComment;
            declarationMetadata.declaredReleaseTag = declaredReleaseTag;
            declarationMetadata.isEventProperty = modifierTagSet.isEventProperty();
            declarationMetadata.isOverride = modifierTagSet.isOverride();
            declarationMetadata.isSealed = modifierTagSet.isSealed();
            declarationMetadata.isVirtual = modifierTagSet.isVirtual();
            // Require the summary to contain at least 10 non-spacing characters
            declarationMetadata.needsDocumentation = !tsdoc.PlainTextEmitter.hasAnyTextContent(parserContext.docComment.summarySection, 10);
        }
    }
    _parseTsdocForAstDeclaration(astDeclaration) {
        const declaration = astDeclaration.declaration;
        let nodeForComment = declaration;
        if (ts.isVariableDeclaration(declaration)) {
            // Variable declarations are special because they can be combined into a list.  For example:
            //
            // /** A */ export /** B */ const /** C */ x = 1, /** D **/ [ /** E */ y, z] = [3, 4];
            //
            // The compiler will only emit comments A and C in the .d.ts file, so in general there isn't a well-defined
            // way to document these parts.  API Extractor requires you to break them into separate exports like this:
            //
            // /** A */ export const x = 1;
            //
            // But _getReleaseTagForDeclaration() still receives a node corresponding to "x", so we need to walk upwards
            // and find the containing statement in order for getJSDocCommentRanges() to read the comment that we expect.
            const statement = TypeScriptHelpers_1.TypeScriptHelpers.findFirstParent(declaration, ts.SyntaxKind.VariableStatement);
            if (statement !== undefined) {
                // For a compound declaration, fall back to looking for C instead of A
                if (statement.declarationList.declarations.length === 1) {
                    nodeForComment = statement;
                }
            }
        }
        const sourceFileText = declaration.getSourceFile().text;
        const ranges = TypeScriptInternals_1.TypeScriptInternals.getJSDocCommentRanges(nodeForComment, sourceFileText) || [];
        if (ranges.length === 0) {
            return undefined;
        }
        // We use the JSDoc comment block that is closest to the definition, i.e.
        // the last one preceding it
        const range = ranges[ranges.length - 1];
        const tsdocTextRange = tsdoc.TextRange.fromStringRange(sourceFileText, range.pos, range.end);
        return this._tsdocParser.parseRange(tsdocTextRange);
    }
    _collectReferenceDirectives(astSymbol) {
        const seenFilenames = new Set();
        for (const astDeclaration of astSymbol.astDeclarations) {
            const sourceFile = astDeclaration.declaration.getSourceFile();
            if (sourceFile && sourceFile.fileName) {
                if (!seenFilenames.has(sourceFile.fileName)) {
                    seenFilenames.add(sourceFile.fileName);
                    for (const typeReferenceDirective of sourceFile.typeReferenceDirectives) {
                        const name = sourceFile.text.substring(typeReferenceDirective.pos, typeReferenceDirective.end);
                        this._dtsTypeReferenceDirectives.add(name);
                    }
                    for (const libReferenceDirective of sourceFile.libReferenceDirectives) {
                        const name = sourceFile.text.substring(libReferenceDirective.pos, libReferenceDirective.end);
                        this._dtsLibReferenceDirectives.add(name);
                    }
                }
            }
        }
    }
}
exports.Collector = Collector;
//# sourceMappingURL=Collector.js.map