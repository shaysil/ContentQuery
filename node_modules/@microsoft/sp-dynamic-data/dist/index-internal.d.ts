/**
 * SharePoint Framework support for dynamic data bindings.
 *
 * @remarks
 * This package provides the necessary infrastructure classes and public APIs necessary
 * to run dynamic data, and implement components that use it.
 *
 * @packagedocumentation
 */

import { ISPEventObserver } from '@microsoft/sp-core-library';
import { ServiceKey } from '@microsoft/sp-core-library';
import { ServiceScope } from '@microsoft/sp-core-library';
import { SPEvent } from '@microsoft/sp-core-library';
import { SPEventArgs } from '@microsoft/sp-core-library';

/**
 * Manager for Dynamic Data.
 * This holds a reference to all Dynamic Data Sources and uses the SPEventManager internally to handle
 * notifications for source updates.
 *
 * @remarks
 * Data sources can notify for changes within the data source or for a specific property.
 * Data consumers can register to both changes in a Dynamic Data source and a specific property within the source.
 * There are 3 events to handle this variety of situations:
 *
 * Notifying a change for a property triggers events for the specific propery and for "any" property
 * Notifying a change for the whole source triggers events for for "any" property and "all" properties.
 *
 * Registering for changes in a property register to events for the specific property and "all" properties.
 * Registering for changes in the whole source register to events for "any" properties.
 *
 * This ensures that regardless of how sources and consumers are configured, events will trigger once and only once for
 * each update within the data source.
 *
 * @internal
 */
export declare class _DynamicDataManager {
    /**
     * The service key for PageContext.
     */
    static readonly serviceKey: ServiceKey<_DynamicDataManager>;
    private _sources;
    private _sourcesChangedEvent;
    constructor(serviceScope: ServiceScope);
    /**
     * Event that gets raised when the list of Dynamic Data Sources gets updated.
     * @eventproperty
     */
    readonly sourcesChangedEvent: SPEvent<SPEventArgs>;
    /**
     * Raises an event to all listeners when a Dynamic Data Source has been updated.
     * @param sourceId - Id of the Dynamic Data Source that is being updated.
     */
    notifySourceChanged(sourceId: string): void;
    /**
     * Raises an event to all listeners when a property in a Dynamic Data Source has been updated.
     * @param sourceId - Id of the Dynamic Data Source whose property is being updated.
     * @param propertyId - Id of the property that is being updated.
     */
    notifyPropertyChanged(sourceId: string, propertyId: string): void;
    /**
     * Registers a listener for updates on a Dynamic Data Source.
     */
    registerSourceChanged(sourceId: string, observer: ISPEventObserver, callback: () => void): void;
    /**
     * Unregisters a listener for updates on a Dynamic Data Source.
     */
    unregisterSourceChanged(sourceId: string, observer: ISPEventObserver, callback: () => void): void;
    /**
     * Registers a listener for updates on a Dynamic Data Source.
     */
    registerPropertyChanged(sourceId: string, propertyId: string, observer: ISPEventObserver, callback: () => void): void;
    /**
     * Unregisters a listener for updates on a Dynamic Data Source.
     */
    unregisterPropertyChanged(sourceId: string, propertyId: string, observer: ISPEventObserver, callback: () => void): void;
    /**
     * Returns a read-only array with all the existing Dynamic Data Sources.
     */
    getSources(): ReadonlyArray<IDynamicDataSource>;
    /**
     * Returns a Dynamic Data Source based on its id.
     * Returns undefined if the source doesn't exist.
     * @param sourceId - Id of the Dynamic Data Source.
     */
    tryGetSource(sourceId: string): IDynamicDataSource | undefined;
    /**
     * Adds a new Dynamic Data Source to be managed.
     * Throws an error if the source can't be added.
     *
     * @param source - Dynamic Data Source to add.
     */
    addSource(source: IDynamicDataSource): void;
    /**
     * Removes an existing Dynamic Data Source from the manager.
     * @param id - Id of the Dynamic Data Source.
     */
    removeSource(sourceId: string): void;
    private _validateSource;
    /**
     * Raises an event when the Dynamic Data Sources gets updated.
     * @remarks
     * The event is sticky because sources can be updated before there is anyone listening. This way all clients
     * will get notified that sources have been updated. Further updates are notified in real-time.
     */
    private _raiseSourcesChangedEvent;
    /**
     * Returns the event name used when all properties in a Dynamic Data source have changed.
     * Example: DynamicData_AllPropertiesChanged_WebPart.<componentId>.<instanceId>
     * @param sourceId - Id of the Dynamic Data source.
     */
    private _getAllPropertiesChangedEventName;
    /**
     * Returns the event name used when any property in a Dynamic Data source has changed.
     * Example: DynamicData_AnyPropertyChanged_WebPart.<componentId>.<instanceId>
     * @param sourceId - Id of the Dynamic Data source.
     */
    private _getAnyPropertyChangedEventName;
    /**
     * Returns the event name prefix used when a property in a Dynamic Data source has changed.
     * This should not be used as a final name for an event, but to be used inside _getPropertyChangedEventName.
     * Example: DynamicData_PropertyChanged_WebPart.<componentId>.<instanceId>
     * @param sourceId - Id of the Dynamic Data source.
     */
    private _getPropertyChangedEventPrefix;
    /**
     * Returns the event name used when a properties in a Dynamic Data source has changed.
     * Example: DynamicData_PropertyChanged_WebPart.<componentId>.<instanceId>_myProperty
     * @param sourceId - Id of the Dynamic Data source.
     * @param propertyId - Id of the property that has changed.
     */
    private _getPropertyChangedEventName;
}

/**
 * Class that contains the Dynamic Data reference.
 * This includes the source, property, and property path (if applicable) of Dynamic Data
 *
 * @remarks
 * The reference string is of the form `<sourceId>:<property>` or `<sourceId>:<property>:<propertyPath>`
 *
 * Examples of references are:
 * `WebPart.<componentId>.<instanceId>:myComplexProperty:myArray[0].lastName`
 *
 * @public
 */
export declare class DynamicDataReference {
    private _reference;
    private _sourceId;
    private _property;
    private _propertyPath;
    constructor(reference: string);
    /**
     * Returns the full reference of the Dynamic Data object as a string.
     */
    readonly reference: string;
    /**
     * Returns the referred id of the Dynamic Data Source.
     */
    readonly sourceId: string;
    /**
     * Returns the referred property of the Dynamic Data.
     */
    readonly property: string;
    /**
     * Returns the referred property path of the Dynamic Data.
     * Returns undefined if there is no property path.
     */
    readonly propertyPath: string | undefined;
}

/**
 * This is used to pass "sub-properties" into the context data source.  It can be used
 * for example, to populate the PageContextInfo data, as well as the SPPage.CurrentItem
 *
 * @internal
 */
export declare interface _IContextPropertyInfo {
    id: string;
    dynamicDataFunctions: IDynamicDataCallables;
}

/**
 * Describes the value and the structure of a property value.
 * It contains sample value of the property and the metadata
 * describing the structure of that value.
 * @public
 */
export declare interface IDynamicDataAnnotatedPropertyValue {
    /**
     * Sample value of a property
     */
    sampleValue: any;
    /**
     * Metadata describing the sample value of the property.
     */
    metadata?: IDynamicDataPropertyValueMetadataCollection;
}

/**
 * Interface for components to implement in order to be dynamic data sources.
 * This can be implemented as an object with state, or a set of loose functions that
 * returns the data.
 *
 * @privateRemarks
 * Please note that, if you add any api here, if you want that to be surfaced to the
 * consumers then you have to add an equivalent api in the 'IDynamicDataSource'.
 *
 * @public
 */
export declare interface IDynamicDataCallables {
    /**
     * Returns all the property definitions that the DataSource will provide.
     */
    getPropertyDefinitions(): ReadonlyArray<IDynamicDataPropertyDefinition>;
    /**
     * Given a property id, returns the value of the property.
     *
     * @remarks
     * It is assumed that when this function returns an array, it is homogeneous.
     */
    getPropertyValue(propertyId: string): any;
    /**
     * Given a property id, returns its annotated value. If the source doesn't supply
     * the annotated value, then it falls back to whatever 'getPropertyValue' returns as
     * the sample value and metadata would be undefined.
     *
     * @param propertyId - One of the property ids exposed from the dynamic data source.
     */
    getAnnotatedPropertyValue?(propertyId: string): IDynamicDataAnnotatedPropertyValue | undefined;
    /**
     * Returns list of allowed events on the dynamic data source.
     *
     * When this function returns a non-empty result, then source must define 'sendEvent' api.
     *
     * If this api is not defined or returns an empty array, then no consumer will be able
     * to talk to this source.
     *
     * @beta
     */
    allowedEvents?(): ReadonlyArray<IDynamicDataEventDefinition>;
    /**
     * If defined, enables the consumer to send data to the associated
     * dynamic data source. Then source can act accordingly.
     *
     * Invoking this api throws an error when the passed in 'eventName' is not
     * one of the allowed events on the source.
     *
     * @param eventName - A case-sensitive string representing the name of the event.
     * @param data - Data to be sent to the dynamic data source.
     *
     * @beta
     */
    sendEvent?(eventName: string, data: any): void;
}

/**
  * Definition of an event which a dynamic data source accepts.
  *
  * It includes the name of the event and description to be seen and used by end users.
  *
  * @beta
  */
export declare interface IDynamicDataEventDefinition {
    /**
     * Event name
     */
    name: string;
    /**
     * User-friendly, localized description of the event.
     */
    description?: string;
}

/**
 * Definition of a property. It includes the id of the property to be used with the APIs, along with
 * a user-friendly, localized title and description to be seen and used by end users.
 *
 * @public
 */
export declare interface IDynamicDataPropertyDefinition extends IDynamicDataPropertyMetadata {
    /**
     * Id of the property. This can only contains letters, numbers, dashes and underscores.
     * Example: "myFiles" or "time_in_24-hour_clock"
     */
    id: string;
}

/**
 * Metadata of a property
 * @public
 */
export declare interface IDynamicDataPropertyMetadata {
    /**
     * User-friendly, localized title of the property.
     * Example: "My files" / "Mis archivos" (depending of current language)
     */
    title: string;
    /**
     * User-friendly, localized description of the property.
     * Example: "Contains a list of ids with the files of the current user"
     */
    description?: string;
}

/**
 * Metadata describing the sample value of the property.
 * @public
 */
export declare interface IDynamicDataPropertyValueMetadata extends IDynamicDataPropertyMetadata {
    /**
     * Metadata describing the sample value of the property.
     */
    metadata?: IDynamicDataPropertyValueMetadataCollection;
}

/**
 * A collection of key value pairs, where
 * 'key' is one of the keys from the property value object and
 * 'value' is the metadata describing the 'key' and its value.
 *
 * @remarks
 * Important note:
 *
 *  1. Key in the metadata should match the key in the sample value object.
 *
 *  2. For arrays, metadataCollection would be same as describing the element
 *     of the array, only once. See below example for more details.
 *
 * For example:
 *
 * ```
 * case 1: With simple values
 *  Sample Property Id value - {
 *    firstName: 'Bob',
 *    lastName: 'Smith',
 *    age: 30
 *  }
 *
 *  MetadataCollection for the above object would be -
 *  metadataCollection: {
 *    'firstName': { title: 'First Name' },
 *    'lastName': { title: 'Last Name' },
 *    'age': { title: 'Age' }
 *  }
 *
 * Case 2: With complex values
 *  Sample Property Id value - {
 *    person: {
 *      firstName: 'Bob',
 *      lastName: 'Smith',
 *      age: 30
 *    },
 *    visitedLocations: [
 *      {
 *        city: 'Redmond',
 *        state: 'WA'
 *      },
 *      {
 *        city: 'New York City',
 *        state: 'NY'
 *      }
 *    ]
 *  }
 *
 *  MetadataCollection for the above object would be -
 *  metadataCollection: {
 *    'person': {
 *      title: 'Person',
 *      metadataCollection: {
 *        'firstName': { title: 'First Name' },
 *        'lastName': { title: 'Last Name' },
 *        'age': { title: 'Age' }
 *      }
 *    },
 *    'vistedLocations': {
 *      title: 'Visted Locations',
 *      metadataCollection: {
 *        'city': { title: 'City' },
 *        'state': { title: 'State' }
 *      }
 *    }
 *  }
 * ```
 *
 * @public
 */
export declare interface IDynamicDataPropertyValueMetadataCollection {
    /**
     * Key-Value pair where
     * 'key' is one of the keys from the property value object and
     * 'value' is the metadata describing the 'key' and its value.
     */
    [key: string]: IDynamicDataPropertyValueMetadata;
}

/**
 * Dynamic Data Sources provide Dynamic Data to consumers.
 * They offer metadata to identify the data sources and API to get the data.
 *
 * @privateRemarks
 * We are not extending the IDynamicDataCallables interface here because
 * it would give us a flexibility of changing those api's signature to suit
 * the consumer needs.
 *
 * @public
 */
export declare interface IDynamicDataSource {
    /**
     * Id of the Dynamic Data Source.
     */
    id: string;
    /**
     * Metadata of the Dynamic Data Source.
     */
    metadata: IDynamicDataSourceMetadata;
    /**
     * Returns all the property definitions for dynamic data.
     * This needs to be overriden by the implementation of the component.
     */
    getPropertyDefinitions(): ReadonlyArray<IDynamicDataPropertyDefinition>;
    /**
     * Given a property id, returns the value of the property.
     * This needs to be overriden by the implementation of the component.
     */
    getPropertyValue(propertyId: string): any;
    /**
     * Given a property id, returns its annotated value.
     * If the source doesn't supply the annotated value, then it falls back to whatever
     * 'getPropertyValue' as the sample value and metadata would be undefined.
     *
     * @param propertyId - One of the property ids exposed from the dynamic data source.
     */
    getAnnotatedPropertyValue(propertyId: string): IDynamicDataAnnotatedPropertyValue;
    /**
     * Returns list of allowed events on the dynamic data source.
     * When this api returns a non-empty result, then source must define 'sendData' api.
     *
     * If this api is not defined or returns an empty map, then no consumer will be able
     * to talk to this source.
     *
     * @beta
     */
    allowedEvents?(): ReadonlyArray<IDynamicDataEventDefinition>;
    /**
     * If defined, enables the consumer to send data to the associated
     * dynamic data source. Then source can act accordingly.
     *
     * Invoking this api throws an error when the passed in 'eventName' is not
     * one of the allowed events on the source.
     *
     * @param eventName - A case-sensitive string representing the name of the event.
     * @param data - Data to be sent to the dynamic data source.
     *
     * @beta
     */
    sendEvent?(eventName: string, data: any): void;
}

/**
 * Metadata of the Dynamic Data Source. It allows consumers to easily distinguish Dynamic Data Sources.
 *
 * @public
 */
export declare interface IDynamicDataSourceMetadata {
    /**
     * User-friendly, localized title of the Dynamic Data Source.
     * This can be customized by the component it refers to. By default it's the alias of the component.
     */
    title: string;
    /**
     * User-friendly, localized description of the Dynamic Data Source.
     */
    description?: string;
    /**
     * Alias of the component that the Dynamic Data Source refers to.
     * It can be undefined when the sources doesn't come from a component, for example framework level data sources.
     */
    alias?: string;
    /**
     * Id of the component that the Dynamic Data Source refers to.
     * It can be undefined when the sources doesn't come from a component, for example framework level data sources.
     */
    componentId?: string;
    /**
     * Id of the instance of the component that the Dynamic Data Source refers to.
     * This allows to distinguish, for example, between two web parts with the same type.
     * It can be undefined when the sources doesn't come from a component, for example framework level data sources.
     */
    instanceId?: string;
}

/**
 * The page context data source.  It should contain all app-level contextual information
 *
 * @internal
 */
export declare class _PageContextDataSource {
    private static _pageContextDataSourceId;
    private static _pageContextDataSourceAlias;
    private _propertyDefinitions;
    private _eventDefinitions;
    private _serviceScope;
    private _dynamicDataManager;
    constructor(serviceScope: ServiceScope);
    /**
     *
     * @param propInfo - The "sub-datasource" property.
     */
    addPropertyHandler(propInfo: _IContextPropertyInfo): void;
    /**
     * Used by the downstream content providers to indicate that their properties have changed.
     * @param propertyId - the propertyId (not the context property info, but the property id) that has changed
     */
    notifyPropertyChanged(propertyId: string): void;
    /**
     * Remove all of the properties
     *
     * @param id - the id of the data provider that you want to remove.
     */
    removePropertyHandler(id: string): void;
    /**
     * Iterate over all of the properties we are aware of and return
     * the set
     */
    getPropertyDefinitions(): ReadonlyArray<IDynamicDataPropertyDefinition>;
    /**
     * Return the property value for the given property ID.  This will
     * iterate over all the different data providers exposed in the
     * context data source
     *
     * @param propertyId - the name of the property you want the value for
     *
     */
    getPropertyValue(propertyId: string): any;
    /**
     *
     * @param propertyId - The id of the property that contains the annotated value.
     */
    getAnnotatedPropertyValue(propertyId: string): IDynamicDataAnnotatedPropertyValue;
    /**
     * iterate over all the known event handlers and return the
     * complete set.
     */
    allowedEvents(): ReadonlyArray<IDynamicDataEventDefinition>;
    /**
     * This simply passes the sendEvent method to the appropriate
     * function end point.
     *
     * @param eventName - The event name that is being called
     * @param data - The data to be passed into the event
     */
    sendEvent(eventName: string, data: any): void;
}

export { }
