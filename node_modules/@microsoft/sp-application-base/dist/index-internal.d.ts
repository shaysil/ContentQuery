/**
 * SharePoint Framework support for building and extending client-side applications.
 *
 * @packagedocumentation
 */

import { BaseComponent } from '@microsoft/sp-component-base';
import { BaseComponentContext } from '@microsoft/sp-component-base';
import { BaseExtension } from '@microsoft/sp-extension-base';
import { ExtensionContext } from '@microsoft/sp-extension-base';
import { Guid } from '@microsoft/sp-core-library';
import { IBrowserCompatibility } from '@microsoft/sp-core-library';
import { IColorPalette } from '@ms/sp-suite-nav';
import { _IComponentContextParameters } from '@microsoft/sp-component-base';
import { IDisposable } from '@microsoft/sp-core-library';
import { _IExtensionContextParameters } from '@microsoft/sp-extension-base';
import { default as _IODSPThemeData } from '@ms/odsp-utilities/lib/theming/IThemeData';
import { _IPreloadedData } from '@microsoft/sp-loader';
import { ISuiteNavConfigurationData } from '@ms/sp-suite-nav';
import { ISuiteNavManager } from '@ms/sp-suite-nav';
import { ISuiteNavManagerConfiguration } from '@ms/sp-suite-nav';
import { default as _ODSPThemeProvider } from '@ms/odsp-utilities/lib/theming/ThemeProvider';
import { Promise as Promise_2 } from '@ms/odsp-utilities-bundle';
import { ServiceKey } from '@microsoft/sp-core-library';
import { ServiceScope } from '@microsoft/sp-core-library';
import { SPEvent } from '@microsoft/sp-core-library';
import { SPEventArgs } from '@microsoft/sp-core-library';

/**
 * Provides access to the client-side application that is currently running.
 *
 * @remarks
 * The client-side application determines the user experience for an entire web page.
 * (It is a client-side component with a manifest; however, the SharePoint Framework
 * does not enable third parties to create their own client-side applications at this time.)
 * Within a web page, at most one client-side application will be running at a time.
 * Certain in-place navigation transitions can cause the application to be unloaded
 * and replaced by a different application.
 *
 * The ApplicationAccessor class enables extensibility components such as extensions
 * and web parts to interact with the currently running application.  It acts as
 * a proxy for the real application object (the BaseApplication subclass), to ensure
 * that extensibility components only rely on interactions that would be portable
 * across all applications.
 *
 * @public
 */
export declare class ApplicationAccessor {
    private _navigatedEvent;
    private _privateLayoutChangedEvent;
    /**
     * Constructs a new instance of the {@link ApplicationAccessor} class.
     * @remarks
     * Third parties should not call this constructor.  Instead, use the ApplicationAccessor
     * instance from the component context, for example {@link BaseApplicationCustomizer.context}.
     */
    constructor(serviceScope: ServiceScope);
    /**
     * An event that is fired when the application's top-level page context navigates
     * to a new page.
     * @remarks
     * This event fires after the top-level {@link @microsoft/sp-page-context#PageContext} has navigated
     * to a new page.
     * @eventproperty
     */
    readonly navigatedEvent: SPEvent<SPEventArgs>;
    /**
     * Event that gets raised every time the layout changes in a page
     * @eventproperty
     * @internal
     */
    readonly _layoutChangedEvent: SPEvent<SPEventArgs>;
}

/**
 * The component context for {@link BaseApplicationCustomizer}.
 *
 * @public
 */
export declare class ApplicationCustomizerContext extends ExtensionContext {
    private _placeholderProvider;
    private _applicationAccessor;
    /**
     * @internal
     */
    constructor(extensionContextParameters: _IExtensionContextParameters, applicationCustomizerContextParameters: _IApplicationCustomizerContextParameters);
    /**
     * Exposes a collection of content placeholders for use by third parties.
     */
    readonly placeholderProvider: PlaceholderProvider;
    /**
     * Provides access to the client-side application that is currently running.
     */
    readonly application: ApplicationAccessor;
    /**
     * @override
     */
    dispose(): void;
}

/**
 * Determines the type of the application load.
 * This is used by SPFx applications to understand whether they were initiated as part of a
 * full page load or an in-place navigation.
 *
 * @internal
 */
export declare enum _ApplicationLoadType {
    /**
     * This informs the application that it was loaded as part of a full-page load.
     */
    FullPageLoad = 0,
    /**
     * This informs the application that it was loaded as part of an in-place navigation from
     * a different application.
     */
    InPlaceNavigation = 1
}

/**
 * Application manager. Includes logic to load SPFX client-side applications.
 * @internal
 */
export declare class _ApplicationManager {
    private static _logSource;
    private _serviceScope;
    private _navigator;
    private _currentApplication;
    private _previousApplication;
    /**
     * Returns true if the current application is a chromeless application.
     *
     * @privateRemarks
     * PageChrome, SuiteNav and application render do not apply to chromeless applications, like
     * Classic pages and ListView application, and should not be called.
     * This is a temporary fix to prevent page chrome DOM and styles from getting inserted into
     * the list view host application.
     *
     * @internal
     */
    static _isChromelessApplication(componentId: string): boolean;
    /**
     * Creates an application manager.
     * @param serviceScope - Root service scope.
     */
    constructor(serviceScope: ServiceScope, navigator?: _Navigator);
    /**
     * Returns the currently loaded application.
     * Returns Guid.empty if no application is currently loaded.
     */
    readonly currentApplicationId: Guid;
    /**
     * Returns the currently loaded application.
     * Returns Guid.empty if no application is currently loaded.
     */
    readonly currentApplication: BaseApplication;
    /**
     * Loads an application and starts its execution.
     *
     * @param preloadedData - Application preloaded data. Must include the application id.
     * @param pageChrome - Page Chrome in which the application will be rendered.
     */
    startApplication<TApplication extends BaseApplication>(preloadedData: _IPreloadedData, pageChrome?: _ISPPageChrome): Promise<TApplication>;
    private readonly _applicationLoadType;
    private _shouldCreateNewAppInstance;
    private _initializeApplicationWithTelemetry;
    /**
     * Loads the application, defined by the application id passed as input.
     * Rejects the promise if the application can't be loaded.
     */
    private _loadApplicationComponent;
    private _isChromelessApplication;
    /**
     * Initializes the application.
     * It sets up the PageChrome and SuiteNav if necessary, initializes the application context
     * and renders the application if necessary.
     *
     * @param application - Application to initialize.
     * @param applicationId - Application component Id.
     * @param pageChrome - Application Page Chrome
     *
     * @returns A promise
     */
    private _initializeApplication;
}

/**
 * This is the system base class for client-side applications.  It manages the overall
 * life cycle of your application, and is the first entry point for your code to start
 * executing when the page loads.  The two main events are onLoad() which occurs first,
 * and onRender() which occurs after the application manager has initialized the environment
 * and completed rendering the page chrome.
 *
 * @alpha
 */
export declare class BaseApplication extends BaseComponent {
    /**
     * SPEvent name for page navigation.
     * @internal
     */
    static _navigatedEventName: string;
    /**
     * SPEvent name for layout changes.
     * @internal
     */
    static _layoutChangedEventName: string;
    /**
     * SPEvent name for prefetched data availability.
     * @internal
     */
    static _prefetchedDataEventName: string;
    /**
     * Overrides the IClientSideComponentManifest.alias value provided in the manifest.
     */
    readonly alias: string;
    /**
     * {@inheritDoc @microsoft/sp-component-base#BaseComponent.context}
     */
    protected readonly context: BaseApplicationContext;
    constructor();
    /**
     * Returns the DOM element where the application is expected to render its content.
     * The domElement will be undefined until the onRender() event occurs.
     *
     * @remarks
     * IMPORTANT: The application should not access DOM elements outside of this subtree,
     * as they are system-defined and may change over time.
     *
     * Throws an error if the domElement is undefined.
     */
    protected domElement: HTMLDivElement;
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager.
     * The application code should not call it directly.
     *
     * @internal
     */
    _load(contextParameters: _IApplicationContextParameters): Promise<void>;
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager
     * to render the application.
     * The application code should not call it directly.
     *
     * @internal
     */
    _render(): void;
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked by the application manager
     * to unload the application. The page chrome is still available at this point
     * The application code should not call it directly.
     *
     * @internal
     */
    _unload(): void;
    /**
     * RESERVED FOR INTERNAL USAGE. This method is invoked automatically by the application manager
     * to load the application specific theme.
     * The application code should not call it directly.
     *
     * @internal
     */
    _loadTheme(): void;
    /**
     * RESERVED FOR INTERNAL USAGE.
     * Internal API to dispose the application.
     * See onDispose for more details
     */
    dispose(): void;
    /**
     * Returns browser compatibility information for the application.
     *
     * @remarks
     * The SharePoint Framework tracks browser compatibility for the application and the framework.
     * Taken together, this information will determine the experience for the end user.
     *
     * Implement this method to report the level of support that your application provides for the current web browser.
     * Since the User Agent field is impersonated by various browsers, itâ€™s recommended for the implementation to test
     * individual API features rather than trying to identify specific releases of browsers.
     */
    getBrowserCompatibility(): IBrowserCompatibility;
    /**
     * This virtual function returns the default configuration and can be configured by applications
     * when required.
     */
    suiteNavConfiguration(): ISuiteNavManagerConfiguration;
    /**
     * This virtual function returns the default application context and can be configured by applications
     * when required.
     *
     * @internal
     */
    protected _getApplicationContext(contextParameters: _IApplicationContextParameters): BaseApplicationContext;
    /**
     * This virtual function returns the default application theme provider and can be overridden by applications
     * when required.
     *
     * @internal
     */
    protected _getThemeProvider(): _SPThemeProvider;
    /**
     * This life cycle event occurs immediately after the application manager has loaded the application,
     * before the DOM is constructed.  Applications can use this event to load scripts
     * or start asynchronous operations that need to occur early in the lifecycle.
     * Inside the onLoad() event, applications may also modify the rendering of various
     * page chrome elements, for example by calling this.context.suiteNav.setComponentVisibility(false).
     */
    protected onLoad(): Promise<void>;
    /**
     * This lifecycle event occurs before hiding the application chrome. At this point the application still has
     * the DOM element available and can perform specific operations before the chrome is hidden from the view-port
     */
    protected onUnload(): void;
    /**
     * This lifecycle event occurs after the application manager has constructed the DOM for the page chrome.
     * At this time, the domElement property will be initialized, and the application can begin
     * rendering its own DOM elements.
     */
    protected onRender(): void;
    /**
     * This API is called at the end of the application lifecycle. It should be used to dispose any local
     * resources (i.e. DOM elements) that the application is holding onto.
     *
     * This API is expected to be called in scenarios like cross-application navigation
     * i.e. the host is transitioning from one application to another and disposes the application that is being
     * transitioned out.
     */
    protected onDispose(): void;
    /**
     * Provides the data necessary to construct an instance of SuiteNavManagerConfiguration
     * @internal
     */
    protected _getSuiteNavManagerConfigurationData(): ISuiteNavConfigurationData;
    /**
     * Causes the navigator to navigate to a new page
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     */
    protected _navigate(url: string, props?: _INavigationProperties): Promise<_INavigationResult>;
    /**
     * Allows the navigator to reinitialize SPFx components with `_IPreloadedData`.
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     *
     * Navigation is an async operation but calling this API ignores the promise.
     * This is used by List application to change the context, so the framework will send the appropriate events
     * for the context change, but it doesn't impact the application.
     */
    protected _navigateToPreloadedData(preloadedData: _IPreloadedData): void;
    /**
     * Invalidates a cached resource by its URL. Any subsequent request for the resource
     * will be fetched from its origin and recached.
     *
     * @param url - URL to invalidate
     *
     * @remarks
     * This will be removed soon. Please use navigator from application context
     * to invoke public APIs
     */
    protected _invalidate(url: string): Promise<void>;
    /**
     * Raises an event for a layout change.
     */
    protected raiseLayoutChangedEvent(): void;
    private _shouldDisableSuiteNav;
    /**
     * This is a handler to update Suite Nav container height, when sp-suite-nav wants to update it.
     *
     * @param height - Height of the suite nav bar container to be set.
     */
    private _suiteNavHeightHandler;
}

/**
 * Context object for a client-side applications.
 *
 * @alpha
 */
export declare class BaseApplicationContext extends BaseComponentContext {
    private _preloadedData;
    private _suiteNavManager;
    private _navigator;
    private _chrome;
    private _loadType;
    private _prefetchedDataEvent;
    private _disposed;
    /** @internal */
    constructor(parameters: _IApplicationContextParameters);
    /**
     * Diposes the application context
     */
    dispose(): void;
    /**
     * Sets the SuiteNav manager in the application context.
     */
    initializeSuiteNavManager(suiteNavManager: ISuiteNavManager): void;
    /**
     * The preloaded data used by SPFx
     */
    readonly preloadedData: _IPreloadedData;
    /**
     * The application navigator
     */
    readonly navigator: _Navigator | undefined;
    /**
     * The application page chrome
     */
    readonly chrome: _ISPPageChrome | undefined;
    /**
     * The application load type
     */
    readonly loadType: _ApplicationLoadType;
    /**
     * An event that gets fired when the application prefetched data is available.
     */
    readonly prefetchedDataEvent: SPEvent<_PrefetchedDataEventArgs>;
    /**
     * The SuiteNav manager
     *
     * @remarks
     * The SuiteNav manager is defined only after the application starts rendering.
     * Chromeless application do not have a SuiteNav manager.
     */
    readonly suiteNavManager: ISuiteNavManager | undefined;
}

/**
 * This is the base class that third parties should extend when implementing
 * a client-side extension that runs when an application is first starting.
 *
 * @remarks
 * In the component manifest, the "extensionType" should be set to "ApplicationCustomizer".
 *
 * Example usage scenarios for an application customizer might include: rendering custom
 * UI elements inside a SharePoint content placeholder, tracking page load statistics,
 * or automatically logging the user out after a certain time period.
 *
 * @public
 */
export declare abstract class BaseApplicationCustomizer<TProperties> extends BaseExtension<TProperties> {
    /**
     * {@inheritDoc @microsoft/sp-extension-base#BaseExtension.context}
     */
    protected readonly context: ApplicationCustomizerContext;
    private _placeholdersChangedCallback?;
    /**
     * Initialization code for all the application customizers.
     * Sets up the placeholder setup virtual function with the placeholder changed event.
     *
     * @internal
     */
    _initializeExtensionType(): void;
    /**
     * {@inheritDoc @microsoft/sp-component-base#BaseComponent.dispose}
     */
    dispose(): void;
    /**
     * This event method is called when the placeholders of the host application change, come into
     * existence, or disappear.
     */
    protected onPlaceholdersChanged(placeholderProvider: PlaceholderProvider): void;
}

/**
 * A singleton class that allows the application to configure the behavior of dialog manager. If `@microsoft/sp-dialog`
 * package is loaded on the page and a dialog manager is instantiated on the page, it will look for this singleton
 * as its configuration.
 *
 * @internal
 */
export declare class _DialogManagerConfiguration {
    private static _instance;
    private _allowDialogs;
    private _domElement;
    static readonly instance: _DialogManagerConfiguration;
    /**
     * If the application allows showing dialogs. Application can change this configuration in runtime. For example,
     * the application can decide to set this to false to block all dialogs based on its current state. If this property
     * is false, the dialog manager will deny all requests to show dialogs.
     *
     * Throws an error if allowDialogs is undefined.
     */
    /**
    * Sets the allowDialogs.
    * Throws an error in the parameter value is undefined.
    */
    allowDialogs: boolean;
    /**
     * The container div that the dialog manager will use to render the dialogs in.
     *
     * Throws an error if domElement is undefined.
     */
    readonly domElement: HTMLDivElement;
    /**
     * initialize dialog manager configuration.
     *
     * @param domElement - The container element for dialogs
     * @param allowDialogs - Whether the dialogs should be allowed. This defaults to true and can be updated later using
     * allowDialogs property.
     */
    initialize(domElement: HTMLDivElement, allowDialogs?: boolean): void;
    /**
     * Disposes the current configuration. Use this when the application is being disposed. This will make sure that
     * this config is not re-used in case another application is loaded on the same page.
     * IMPORTANT NOTE: SPFx assumption is that there is only one active application on the page at a given time.
     */
    dispose(): void;
}

/**
 * Constructor parameters for BaseApplicationContext.
 *
 * @internal
 */
export declare interface _IApplicationContextParameters extends _IComponentContextParameters {
    /**
     * Controller that allows application to navigate to a different url
     */
    navigator: _Navigator;
    /**
     * The application chrome
     */
    chrome: _ISPPageChrome | undefined;
    /**
     * The application load type
     */
    loadType: _ApplicationLoadType;
}

/**
 * Constructor parameters for ApplicationCustomizerContext.
 *
 * @internal
 */
export declare interface _IApplicationCustomizerContextParameters {
    /**
     * The sequence number from customAction that is used for ordering
     */
    sequence: number;
}

/**
 * Optional property bag provided to the Navigator
 *
 * @internal
 */
export declare interface _INavigationProperties {
    /**
     * Determines whether caching is enabled
     */
    enableCache: boolean;
    /**
     * Determines whether to prefetch application data
     */
    enableDataPrefetch: boolean;
}

/**
 * Result of a navigation operation.
 *
 * @internal
 */
export declare interface _INavigationResult {
    /**
     * Preloaded data of the new context.
     */
    preloadedData: _IPreloadedData;
    /**
     * Operation that is being performed as part of the navigation.
     * Unsupported when the destination doesn't map to a SPFx application.
     */
    operation: _NavigationOperation;
}
export { _IODSPThemeData }

/**
 * Constructor parameters for PlaceholderContent
 *
 * @internal
 */
export declare interface _IPlaceholderContentParameters {
    placeholder: _Placeholder;
    domElement: HTMLDivElement;
    sequence: number;
    options?: IPlaceholderCreateContentOptions;
}

/**
 * Options for the {@link PlaceholderProvider.tryCreateContent} method.
 *
 * @public
 */
export declare interface IPlaceholderCreateContentOptions {
    /**
     * An optional callback that will be invoked when the PlaceholderContent object
     * is disposed.
     *
     * @remarks
     * To avoid a resource leak, use this callback to free any resources that were allocated
     * when the placeholder content was rendered.  For example, if ReactDOM.render() was
     * used to mount a React component, then the onDispose handler might call
     * ReactDOM.unmountComponentAtNode() to unmount it.
     */
    onDispose?: (placeholderContent: PlaceholderContent) => void;
}

/**
 * Constuctor parameters for Placeholder.
 *
 * @internal
 */
export declare interface _IPlaceholderDefinition {
    /**
     * The placeholder name.
     */
    readonly name: PlaceholderName;
    /**
     * The placeholder's DOM element. The placeholder content will be attached as a child of this element.
     */
    readonly domElement: HTMLDivElement;
}

/**
 * Contains the instance of PlaceholderContent and its metadata
 *
 * @internal
 */
export declare interface _IPlaceholderEntry {
    readonly placeholderContent: PlaceholderContent;
    readonly sequence: number;
}

/**
 * Interface for the chrome where an application is rendered.
 *
 * @internal
 */
export declare interface _ISPPageChrome extends IDisposable {
    /**
     * Div element that hosts the SuiteNav.
     */
    suiteNavDiv: HTMLDivElement;
    /**
     * Div element that hosts the application.
     */
    appDiv: HTMLDivElement;
    /**
     * Theme provider.
     */
    themeProvider: _SPThemeProvider;
    /**
     * Function to change the height of the SuiteNav div.
     */
    changeSuiteNavHeight(pixels: string): void;
    /**
     * Shows the page chrome in the current document.
     */
    show(): void;
    /**
     * Hides the page chrome in the current document.
     */
    hide(): void;
}

/**
 * Operation that gets executed from a navigation request.
 * This is used by SPFx applications to understand what are their next operations after navigating to a different page.
 *
 * @internal
 */
export declare enum _NavigationOperation {
    /**
     * This operation updates the SPFx context but doesn't act on the application.
     * This includes extensions lifecycle operations, changing the PageContext object, etc.
     */
    UpdateContext = 0,
    /**
     * This operation loads a new SPFx application.
     * This implies that the previous application will be disposed.
     */
    LoadApplication = 1,
    /**
     * This operation happens when the URL doesn't map to a SPFx application or the preloaded data is in a corrupted
     * state.
     * The current application is responsible for handling this case.
     * This can mean open the URL in a different tab/window, going to error.aspx, or displaying an error in the console.
     */
    Unsupported = 2
}

/**
 * Navigator for SPFx applications.
 * It allows to navigate to a different URL that is backed by an SPFx application.
 *
 * Updates all SPFx-internal data structures with the information from the new URL.
 * This includes the page context, the manifest store, the session, telemetry and the themes.
 *
 * @internal
 */
export declare class _Navigator {
    private _navigationOrchestrator;
    private _navigationDataProvider;
    private _preloadedData;
    constructor(serviceScope: ServiceScope, applicationManager?: _ApplicationManager);
    /**
     * Returns the preloaded data used by the current page.
     * Throws if it hasn't navigated to a page yet.
     */
    readonly preloadedData: _IPreloadedData;
    /**
     * Navigates to a new page.
     * Requests a JSON to SharePoint server and updates all SPFx related data with the new information.
     * This includes new manifests, page context, theme, telemetry settings.
     *
     * @param url - Destination URL
     * @param props - Optional Navigation properties
     */
    navigate(url: string, props?: _INavigationProperties): Promise<_INavigationResult>;
    /**
     * Prefetches page navigation data
     *
     * @remarks
     * This is a required optimization that allows applications to pre-emptively fetch navigation data
     * so as to allow faster transitions between spfx-based applications.
     *
     * @param url - Destination URL
     * @param props - Optional Navigation properties
     *
     * @returns A promise
     */
    prefetch(url: string, props?: _INavigationProperties): Promise<void>;
    /**
     * Given a preloaded data object, it sets up all SPFx related data with the new information from the preloaded data.
     *
     * @remarks
     * This is necessary because ListView has its own router and will give us only the object itself.
     *
     * @param preloadedData - Preloaded data object
     */
    navigateToPreloadedData(preloadedData: _IPreloadedData): Promise<_INavigationResult>;
    /**
     * Given a preloaded data object, it sets up all SPFx related data with the new information from the preloaded data.
     * It returns a promise with the loaded application.
     *
     * @remarks
     * This is used by the PlatformLoader to bootstrap an application.
     *
     * @param preloadedData - Preloaded data object
     */
    navigateToApplication<TApplication extends BaseApplication>(preloadedData: _IPreloadedData): Promise<TApplication>;
    /**
     * This is an API used in the old boot sequence to load the application customizers after the application
     * has rendered. Once flight #182 (SppplatCrossAppNavigation) has been graduated this API should be removed.
     *
     * @internal
     */
    _loadApplicationCustomizers(preloadedData: _IPreloadedData): Promise<void>;
    /**
     * Invalidates a cached resource by its URL. Any subsequent request for the resource
     * will be fetched from its origin and recached.
     *
     * @param url - URL to invalidate
     */
    invalidate(url: string): Promise<void>;
    private _validatePreloadedData;
    private _isDataPrefetchSupported;
    private _processDataPrefetch;
}
export { _ODSPThemeProvider }

/**
 * Represents the placeholder div provided by the application
 *
 * @internal
 */
export declare class _Placeholder {
    private _name;
    private _domElement;
    private _applicationDomElement;
    private _entries;
    constructor(definition: _IPlaceholderDefinition, manager: _PlaceholderManager);
    readonly name: PlaceholderName;
    /**
     * Create a new placeholder content for this placeholder
     */
    createPlaceholderContent(sequence: number, options?: IPlaceholderCreateContentOptions): PlaceholderContent;
    removePlaceholderContent(placeholderContent: PlaceholderContent): void;
    attachToApplication(applicationDomElement: HTMLDivElement): void;
    detachFromApplication(): void;
    /**
     * Adds the DOM element of a placeholder content in the placeholder DIV element.
     * Returns the position inside of the placeholder where the content was placed.
     *
     * @param domElement - DOM element of the placeholder content
     * @param sequence - Sequence number of the placeholder content
     */
    private _addContentDiv;
}

/**
 * Represents custom content that is rendered inside a placeholder on a SharePoint page.
 *
 * @remarks
 * This object is returned by {@link PlaceholderProvider.tryCreateContent}.
 * It provides access to a Document Object Model (DOM) element where the owner can render
 * its custom content.
 *
 * @public
 */
export declare class PlaceholderContent implements IDisposable {
    private static _logSource;
    private _domElement;
    private _placeholder;
    private _disposeHandler;
    private _isDisposed;
    /**
     * @internal
     */
    constructor(parameters: _IPlaceholderContentParameters);
    /**
     * Identifies the placeholder that this content was added to.
     *
     * @remarks
     * Example: PlaceholderName.Top
     */
    readonly name: PlaceholderName;
    /**
     * The Document Object Model (DOM) element where the owner should render its custom content.
     *
     * @remarks
     * If the caller needs to be notified when the DOM element is disposed, use
     * the {@link IPlaceholderCreateContentOptions.onDispose} callback.
     */
    readonly domElement: HTMLDivElement;
    /**
     * Sets the placeholder of the content. This is used when the placeholders are modifying and the content may
     * hang from a new placeholder object.
     * @param placeholder - Placeholder that own this placeholder content.
     *
     * @internal
     */
    _setPlaceholder(placeholder: _Placeholder): void;
    /**
     * Disposes the PlaceholderContent object and removes its attached DOM element from the page.
     *
     * @remarks
     * This method can be called to immediately dispose the attached DOM element. Otherwise, it
     * will be disposed by the application when the containing placeholder is disposed. Calling dispose()
     * invokes the {@link IPlaceholderCreateContentOptions.onDispose} callback, removes the associated
     * DOM element from the page, and disposes the PlaceholderContent object.
     */
    dispose(): void;
    readonly isDisposed: boolean;
    /**
     * Return true if this PlacholderContent object is visible.  If you create a placeholder
     * and the host page isn't displaying it, this will return false.
     */
    readonly isVisible: boolean;
}

/**
 * PlaceholderManager is a service registered with the application's root ServiceScope.
 * The host application uses this object to define the placeholders which will
 * be consumed by third-party extensions.  The PlaceholderCollection then obtains its
 * data from the PlaceholderManager.
 *
 * @internal
 */
export declare class _PlaceholderManager {
    /**
     * The service key for PlaceholderManager.
     */
    static readonly serviceKey: ServiceKey<_PlaceholderManager>;
    /**
     * SPEvent name for placeholders change
     */
    private static readonly placeholdersChangedEventName;
    /**
     * undefined regions means they are not initialized yet, but empty array means there are none
     */
    private _placeholders;
    private _changedEvent;
    private _isEnabled;
    constructor(serviceScope: ServiceScope);
    /**
     * The event raised when the application changes placeholder definitions
     * @eventproperty
     */
    readonly changedEvent: SPEvent<SPEventArgs>;
    /**
     * Initializes the collection of placeholders for use by application customizers.
     */
    initializePlaceholders(definitions: _IPlaceholderDefinition[]): void;
    /**
     * Adds a placeholder.
     * If a placeholder already existed for the same name, it replaces it.
     */
    addPlaceholder(name: PlaceholderName, domElement: HTMLDivElement): void;
    /**
     * Removes a placeholder.
     */
    removePlaceholder(name: PlaceholderName): void;
    /**
     * Returns true if the placeholders are enabled for the current application
     */
    readonly isEnabled: boolean;
    /**
     * Allows the application to set if placeholders are enabled for the current application
     * @internal
     */
    _enable(): void;
    /**
     * Returns a map from PlaceholderName to Placeholder for all active placeholders.
     */
    readonly placeholders: Map<PlaceholderName, _Placeholder>;
    private _createPlaceholder;
}

/**
 * The identifier for a content placeholder, which is a region on the
 * page where third-party extensibility components can render custom content.
 *
 * @remarks
 * For more information about placeholders, see {@link PlaceholderProvider}.
 *
 * @public
 */
export declare enum PlaceholderName {
    /**
     * A region at the top of the page.
     * @privateRemarks
     * Used by Modern pages and Lists and libraries
     */
    Top = 1,
    /**
     * A region at the bottom of the page.
     * @privateRemarks
     * Used by Modern pages and Lists and libraries
     */
    Bottom = 2
}

/**
 * Allows third-party components to discover and use SharePoint placeholders.  Placeholders
 * enable third-party components to render custom content into designated regions on the page.
 *
 * @remarks
 * Placeholders are designated regions on the page, identified by one of the predefined
 * {@link PlaceholderName} constants.  Different applications and pages might support different
 * placeholder names.  Placeholders can appear and disappear as the user interacts with the page,
 * for example via in-place navigation.  Third-party components should not assume that a given placeholder
 * will always be available.
 *
 * Use {@link PlaceholderProvider.tryCreateContent} to test whether a placeholder is
 * available and add content to it.   Use the {@link PlaceholderProvider.changedEvent} event
 * to discover when new placeholders appear.
 *
 * @public
 */
export declare class PlaceholderProvider implements IDisposable {
    private static _logSource;
    private _sequence;
    private _placeholderManager;
    private _placeholderContents;
    private _isDisposed;
    /**
     * @internal
     */
    constructor(serviceScope: ServiceScope, sequence: number);
    dispose(): void;
    readonly isDisposed: boolean;
    /**
     * Tests whether the page contains the specified placeholder.  If so, a new PlaceholderContent
     * object is created, which allows the caller to render custom content inside the placeholder.
     *
     * @param name - The requested placeholder
     * @param options - Additional options, for example to detect when the placeholder is disposed.
     * @returns A new PlaceholderContent object, or undefined if the requested placeholder does not exist.
     *
     * @remarks
     *
     * The host application makes no guarantees about the availability of a given placeholder.
     * In situations where an expected placeholder is not available, the third-party extension
     * must handle it gracefully, e.g. by not rendering anything, or by choosing an alternative
     * placeholder.
     */
    tryCreateContent(name: PlaceholderName, options?: IPlaceholderCreateContentOptions): PlaceholderContent | undefined;
    /**
     * Returns the names of the currently available placeholders.
     */
    readonly placeholderNames: ReadonlyArray<PlaceholderName>;
    /**
     * This event is raised when the list of currently available placeholders is changed.
     *
     * @remarks
     * The application can change its list of available placeholders at any time. This means that the existing
     * placeholders may get disposed or new placeholders may be added. Use this event to discover new
     * placeholders when they appear.
     *
     * @eventproperty
     */
    readonly changedEvent: SPEvent<SPEventArgs>;
}

/**
 * Arguments for a prefetched data event.
 *
 * @internal
 */
export declare class _PrefetchedDataEventArgs extends SPEventArgs {
    /**
     * The application id associated with the event.
     */
    applicationId: string;
    /**
     * The page url associated with the event.
     */
    url: string;
    /**
     * The payload associated with the event.
     */
    data: any;
    /**
     * Initializes a new instance of the PrefetchedDataEventArgs class
     * @param appId - Represents the application Id
     * @param url - Represents the page url
     * @param data - Represents the payload
     */
    constructor(appId: string, url: string, data: any);
}

/**
 * The class controls applying a theme to the current Page.
 * The theme is a web level setting, if a theme is applied this class with call loadtheme
 * which will update the styles that are registered with load-themed-styles.
 *
 * The loadData method is called by the ThemeProvider class when it needs to get the IThemeData.
 * Once it has theme data it will cache it in local storage using the themedCssFolderUrl as the cache key.
 *
 * @internal
 */
export declare class _SPThemeProvider {
    private static _currentPalette;
    private _pageContext;
    private _httpClient;
    private _themeOverride;
    private _themeProvider;
    private _loadThemedStylesPromiseMap;
    private static _deleteNullThemeColor;
    private static _createDefaultTheme;
    constructor(serviceScope: ServiceScope);
    loadThemedStyles(): Promise_2<IColorPalette> | Promise<[IColorPalette, _IODSPThemeData]>;
    loadData(): Promise_2<_IODSPThemeData>;
    /**
     * Gets the Theme provider.
     *
     * @remarks
     * Derived classes can extend this method to provide a customized theme provider
     */
    protected _getThemeProvider(): _ODSPThemeProvider;
    private _getCacheToken;
}

export { }
